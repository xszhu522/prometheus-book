import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as r,d as o}from"./app-NWC4HiYT.js";const i="/prometheus-book/assets/prometheus-exporter-8VTYqSky.png",n={},a=o('<h1 id="exporter是什么" tabindex="-1"><a class="header-anchor" href="#exporter是什么" aria-hidden="true">#</a> Exporter是什么</h1><p>广义上讲，所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:</p><figure><img src="'+i+`" alt="Exporter" tabindex="0" loading="lazy"><figcaption>Exporter</figcaption></figure><h2 id="exporter的来源" tabindex="-1"><a class="header-anchor" href="#exporter的来源" aria-hidden="true">#</a> Exporter的来源</h2><p>从Exporter的来源上来讲，主要分为两类：</p><ul><li>社区提供的</li></ul><p>Prometheus社区提供了丰富的Exporter实现，涵盖了从基础设施，中间件以及网络等各个方面的监控功能。这些Exporter可以实现大部分通用的监控需求。下表列举一些社区中常用的Exporter：</p><table><thead><tr><th>范围</th><th>常用Exporter</th></tr></thead><tbody><tr><td>数据库</td><td>MySQL Exporter, Redis Exporter, MongoDB Exporter, MSSQL Exporter等</td></tr><tr><td>硬件</td><td>Apcupsd Exporter，IoT Edison Exporter， IPMI Exporter, Node Exporter等</td></tr><tr><td>消息队列</td><td>Beanstalkd Exporter, Kafka Exporter, NSQ Exporter, RabbitMQ Exporter等</td></tr><tr><td>存储</td><td>Ceph Exporter, Gluster Exporter, HDFS Exporter, ScaleIO Exporter等</td></tr><tr><td>HTTP服务</td><td>Apache Exporter, HAProxy Exporter, Nginx Exporter等</td></tr><tr><td>API服务</td><td>AWS ECS Exporter， Docker Cloud Exporter, Docker Hub Exporter, GitHub Exporter等</td></tr><tr><td>日志</td><td>Fluentd Exporter, Grok Exporter等</td></tr><tr><td>监控系统</td><td>Collectd Exporter, Graphite Exporter, InfluxDB Exporter, Nagios Exporter, SNMP Exporter等</td></tr><tr><td>其它</td><td>Blockbox Exporter, JIRA Exporter, Jenkins Exporter， Confluence Exporter等</td></tr></tbody></table><ul><li>用户自定义的</li></ul><p>除了直接使用社区提供的Exporter程序以外，用户还可以基于Prometheus提供的Client Library创建自己的Exporter程序，目前Prometheus社区官方提供了对以下编程语言的支持：Go、Java/Scala、Python、Ruby。同时还有第三方实现的如：Bash、C++、Common Lisp、Erlang,、Haskeel、Lua、Node.js、PHP、Rust等。</p><h2 id="exporter的运行方式" tabindex="-1"><a class="header-anchor" href="#exporter的运行方式" aria-hidden="true">#</a> Exporter的运行方式</h2><p>从Exporter的运行方式上来讲，又可以分为：</p><ul><li>独立使用的</li></ul><p>以我们已经使用过的Node Exporter为例，由于操作系统本身并不直接支持Prometheus，同时用户也无法通过直接从操作系统层面上提供对Prometheus的支持。因此，用户只能通过独立运行一个程序的方式，通过操作系统提供的相关接口，将系统的运行状态数据转换为可供Prometheus读取的监控数据。 除了Node Exporter以外，比如MySQL Exporter、Redis Exporter等都是通过这种方式实现的。 这些Exporter程序扮演了一个中间代理人的角色。</p><ul><li>集成到应用中的</li></ul><p>为了能够更好的监控系统的内部运行状态，有些开源项目如Kubernetes，ETCD等直接在代码中使用了Prometheus的Client Library，提供了对Prometheus的直接支持。这种方式打破的监控的界限，让应用程序可以直接将内部的运行状态暴露给Prometheus，适合于一些需要更多自定义监控指标需求的项目。</p><h2 id="exporter规范" tabindex="-1"><a class="header-anchor" href="#exporter规范" aria-hidden="true">#</a> Exporter规范</h2><p>所有的Exporter程序都需要按照Prometheus的规范，返回监控的样本数据。以Node Exporter为例，当访问/metrics地址时会返回以下内容：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># HELP node_cpu Seconds the cpus spent in each mode.
# TYPE node_cpu counter
node_cpu{cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;} 362812.7890625
# HELP node_load1 1m load average.
# TYPE node_load1 gauge
node_load1 3.0703125
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一种基于文本的格式规范，在Prometheus 2.0之前的版本还支持Protocol buffer规范。相比于Protocol buffer文本具有更好的可读性，以及跨平台性。Prometheus 2.0的版本也已经不再支持Protocol buffer，这里就不对Protocol buffer规范做详细的阐述。</p><p>Exporter返回的样本数据，主要由三个部分组成：样本的一般注释信息（HELP），样本的类型注释信息（TYPE）和样本。Prometheus会对Exporter响应的内容逐行解析：</p><p>如果当前行以# HELP开始，Prometheus将会按照以下规则对内容进行解析，得到当前的指标名称以及相应的说明信息：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># HELP &lt;metrics_name&gt; &lt;doc_string&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果当前行以# TYPE开始，Prometheus会按照以下规则对内容进行解析，得到当前的指标名称以及指标类型:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># TYPE &lt;metrics_name&gt; &lt;metrics_type&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>TYPE注释行必须出现在指标的第一个样本之前。如果没有明确的指标类型需要返回为untyped。 除了# 开头的所有行都会被视为是监控样本数据。 每一行样本需要满足以下格式规范:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>metric_name [
  &quot;{&quot; label_name &quot;=&quot; \`&quot;\` label_value \`&quot;\` { &quot;,&quot; label_name &quot;=&quot; \`&quot;\` label_value \`&quot;\` } [ &quot;,&quot; ] &quot;}&quot;
] value [ timestamp ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中metric_name和label_name必须遵循PromQL的格式规范要求。value是一个float格式的数据，timestamp的类型为int64（从1970-01-01 00:00:00以来的毫秒数），timestamp为可选默认为当前时间。具有相同metric_name的样本必须按照一个组的形式排列，并且每一行必须是唯一的指标名称和标签键值对组合。</p><p>需要特别注意的是对于histogram和summary类型的样本。需要按照以下约定返回样本数据：</p><ul><li><p>类型为summary或者histogram的指标x，该指标所有样本的值的总和需要使用一个单独的x_sum指标表示。</p></li><li><p>类型为summary或者histogram的指标x，该指标所有样本的总数需要使用一个单独的x_count指标表示。</p></li><li><p>对于类型为summary的指标x，其不同分位数quantile所代表的样本，需要使用单独的x{quantile=&quot;y&quot;}表示。</p></li><li><p>对于类型histogram的指标x为了表示其样本的分布情况，每一个分布需要使用x_bucket{le=&quot;y&quot;}表示，其中y为当前分布的上位数。同时必须包含一个样本x_bucket{le=&quot;+Inf&quot;}，并且其样本值必须和x_count相同。</p></li><li><p>对于histogram和summary的样本，必须按照分位数quantile和分布le的值的递增顺序排序。</p></li></ul><p>以下是类型为histogram和summary的样本输出示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># A histogram, which has a pretty complex representation in the text format:
# HELP http_request_duration_seconds A histogram of the request duration.
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{le=&quot;0.05&quot;} 24054
http_request_duration_seconds_bucket{le=&quot;0.1&quot;} 33444
http_request_duration_seconds_bucket{le=&quot;0.2&quot;} 100392
http_request_duration_seconds_bucket{le=&quot;+Inf&quot;} 144320
http_request_duration_seconds_sum 53423
http_request_duration_seconds_count 144320

# Finaly a summary, which has a complex representation, too:
# HELP rpc_duration_seconds A summary of the RPC duration in seconds.
# TYPE rpc_duration_seconds summary
rpc_duration_seconds{quantile=&quot;0.01&quot;} 3102
rpc_duration_seconds{quantile=&quot;0.05&quot;} 3272
rpc_duration_seconds{quantile=&quot;0.5&quot;} 4773
rpc_duration_seconds_sum 1.7560473e+07
rpc_duration_seconds_count 2693
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于某些Prometheus还没有提供支持的编程语言，用户只需要按照以上规范返回响应的文本数据即可。</p><h2 id="指定样本格式的版本" tabindex="-1"><a class="header-anchor" href="#指定样本格式的版本" aria-hidden="true">#</a> 指定样本格式的版本</h2><p>在Exporter响应的HTTP头信息中，可以通过Content-Type指定特定的规范版本，例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Length: 2906
Content-Type: text/plain; version=0.0.4
Date: Sat, 17 Mar 2018 08:47:06 GMT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中version用于指定Text-based的格式版本，当没有指定版本的时候，默认使用最新格式规范的版本。同时HTTP响应头还需要指定压缩格式为gzip。</p>`,37),d=[a];function s(u,l){return t(),r("div",null,d)}const m=e(n,[["render",s],["__file","what-is-prometheus-exporter.html.vue"]]);export{m as default};
