const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":406,\"nextId\":406,\"documentIds\":{\"0\":\"v-46b8dcd6\",\"1\":\"v-46b8dcd6#prometheus操作指南-云原生监控之道\",\"2\":\"v-3ca2f2c1\",\"3\":\"v-3ca2f2c1#版本更新历史\",\"4\":\"v-62e82e4c\",\"5\":\"v-3cca6706\",\"6\":\"v-f01ff508\",\"7\":\"v-8daa1a0e\",\"8\":\"v-8daa1a0e#part-i-prometheus基础\",\"9\":\"v-8daa1a0e#part-ii-prometheus进阶\",\"10\":\"v-8daa1a0e#part-iii-prometheus实战\",\"11\":\"v-f791c990\",\"12\":\"v-f791c990#参考资料\",\"13\":\"v-f791c990#install-configuration\",\"14\":\"v-f791c990#storage\",\"15\":\"v-f791c990#kubernetes\",\"16\":\"v-f791c990#others\",\"17\":\"v-f791c990#promsql\",\"18\":\"v-f791c990#exporters\",\"19\":\"v-1179968c\",\"20\":\"v-1179968c#part-i-prometheus基础\",\"21\":\"v-1179968c#part-ii-prometheus进阶\",\"22\":\"v-1179968c#part-iii-prometheus实战\",\"23\":\"v-4a15717a\",\"24\":\"v-7544b68c\",\"25\":\"v-3343959f\",\"26\":\"v-7672248c\",\"27\":\"v-26bf5d3e\",\"28\":\"v-26bf5d3e#使用golang创建webhook服务\",\"29\":\"v-26bf5d3e#与钉钉集成\",\"30\":\"v-26bf5d3e#自定义webhook群机器人\",\"31\":\"v-26bf5d3e#定义转换器将告警通知转化为dingtalk消息对象\",\"32\":\"v-26bf5d3e#创建dingtalk通知发送包\",\"33\":\"v-26bf5d3e#扩展启动函数\",\"34\":\"v-26bf5d3e#使用dingtalk扩展\",\"35\":\"v-7751684f\",\"36\":\"v-7751684f#抑制机制\",\"37\":\"v-7751684f#临时静默\",\"38\":\"v-080c2a03\",\"39\":\"v-080c2a03#临时屏蔽告警通知\",\"40\":\"v-215034ed\",\"41\":\"v-215034ed#路由匹配\",\"42\":\"v-215034ed#告警分组\",\"43\":\"v-5fa599b2\",\"44\":\"v-d3a3403c\",\"45\":\"v-d3a3403c#自定义告警模板\",\"46\":\"v-45652d9a\",\"47\":\"v-45652d9a#认识slack\",\"48\":\"v-45652d9a#添加应用-incomming-webhooks\",\"49\":\"v-45652d9a#在alertmanager中使用slack\",\"50\":\"v-1c746519\",\"51\":\"v-051d6cc9\",\"52\":\"v-3e31bb1b\",\"53\":\"v-3e31bb1b#使用二进制包部署alertmanager\",\"54\":\"v-3e31bb1b#获取并安装软件包\",\"55\":\"v-3e31bb1b#创建alertmanager配置文件\",\"56\":\"v-3e31bb1b#启动alertmanager\",\"57\":\"v-3e31bb1b#查看运行状态\",\"58\":\"v-3e31bb1b#关联prometheus与alertmanager\",\"59\":\"v-3e31bb1b#接下来\",\"60\":\"v-5586a350\",\"61\":\"v-5586a350#alertmanager特性\",\"62\":\"v-5586a350#分组\",\"63\":\"v-5586a350#抑制\",\"64\":\"v-5586a350#静默\",\"65\":\"v-9fa23656\",\"66\":\"v-9fa23656#定义告警规则\",\"67\":\"v-9fa23656#模板化\",\"68\":\"v-9fa23656#查看告警状态\",\"69\":\"v-9fa23656#实例-定义主机监控告警\",\"70\":\"v-9fa23656#接下来\",\"71\":\"v-201b12db\",\"72\":\"v-201b12db#定义recoding-rules\",\"73\":\"v-14640238\",\"74\":\"v-66d4a6e8\",\"75\":\"v-305e8b6c\",\"76\":\"v-2be9f785\",\"77\":\"v-2be9f785#格式化时间序列\",\"78\":\"v-2be9f785#使用table可视化时间序列\",\"79\":\"v-2be9f785#按行显示时间序列\",\"80\":\"v-2be9f785#按列显示时间序列\",\"81\":\"v-2be9f785#对样本数据进行聚合\",\"82\":\"v-17a1be15\",\"83\":\"v-6b6c97a8\",\"84\":\"v-248c05d8\",\"85\":\"v-248c05d8#自定义collector\",\"86\":\"v-248c05d8#使用http-server暴露样本数据\",\"87\":\"v-248c05d8#使用内置的collector\",\"88\":\"v-248c05d8#在业务代码中进行监控埋点\",\"89\":\"v-248c05d8#简单类型gauge和counter\",\"90\":\"v-248c05d8#复杂类型summary和histogram\",\"91\":\"v-248c05d8#与pushgateway集成\",\"92\":\"v-5a741f5c\",\"93\":\"v-03d7cab0\",\"94\":\"v-03d7cab0#添加拦截器-为监控埋点做准备\",\"95\":\"v-03d7cab0#自定义监控指标\",\"96\":\"v-03d7cab0#使用collector暴露其它指标\",\"97\":\"v-19ba463a\",\"98\":\"v-28f7d6fe\",\"99\":\"v-28f7d6fe#使用blackbox-exporter\",\"100\":\"v-28f7d6fe#与prometheus集成\",\"101\":\"v-28f7d6fe#http探针\",\"102\":\"v-28f7d6fe#自定义http请求\",\"103\":\"v-28f7d6fe#自定义探针行为\",\"104\":\"v-479e335a\",\"105\":\"v-479e335a#使用cadvisor\",\"106\":\"v-479e335a#与prometheus集成\",\"107\":\"v-f551d39c\",\"108\":\"v-f551d39c#部署mysqld-exporter\",\"109\":\"v-f551d39c#监控数据库吞吐量\",\"110\":\"v-f551d39c#连接情况\",\"111\":\"v-f551d39c#监控缓冲池使用情况\",\"112\":\"v-f551d39c#查询性能\",\"113\":\"v-5b7d1c44\",\"114\":\"v-5b7d1c44#exporter的来源\",\"115\":\"v-5b7d1c44#exporter的运行方式\",\"116\":\"v-5b7d1c44#exporter规范\",\"117\":\"v-5b7d1c44#指定样本格式的版本\",\"118\":\"v-47cce5b8\",\"119\":\"v-21534837\",\"120\":\"v-387ee40c\",\"121\":\"v-387ee40c#grafana基本概念\",\"122\":\"v-387ee40c#数据源-data-source\",\"123\":\"v-387ee40c#仪表盘-dashboard\",\"124\":\"v-387ee40c#组织和用户\",\"125\":\"v-52a278dd\",\"126\":\"v-52a278dd#认识面板-panel\",\"127\":\"v-93f8a244\",\"128\":\"v-93f8a244#变量\",\"129\":\"v-93f8a244#变量定义\",\"130\":\"v-93f8a244#使用变量过滤时间序列\",\"131\":\"v-93f8a244#使用变量动态创建panel和row\",\"132\":\"v-79954a3f\",\"133\":\"v-79954a3f#快速开始\",\"134\":\"v-79954a3f#定义页面菜单\",\"135\":\"v-79954a3f#定义图表\",\"136\":\"v-123b807c\",\"137\":\"v-123b807c#graph面板与prometheus\",\"138\":\"v-123b807c#使用graph面板可视化counter-gauge\",\"139\":\"v-123b807c#使用graph面板可视化histogram\",\"140\":\"v-82196c38\",\"141\":\"v-82196c38#使用heatmap可视化histogram样本分布情况\",\"142\":\"v-82196c38#使用heatmap可视化其它类型样本分布情况\",\"143\":\"v-696c2d08\",\"144\":\"v-696c2d08#使用singlestat-panel\",\"145\":\"v-2bbc0322\",\"146\":\"v-b3b2a360\",\"147\":\"v-1fb0e192\",\"148\":\"v-1fb0e192#gossip协议\",\"149\":\"v-1fb0e192#搭建本地集群环境\",\"150\":\"v-1fb0e192#创建alertmanager集群\",\"151\":\"v-1fb0e192#多实例prometheus与alertmanager集群\",\"152\":\"v-be33dc62\",\"153\":\"v-be33dc62#基本ha-服务可用性\",\"154\":\"v-be33dc62#基本ha-远程存储\",\"155\":\"v-be33dc62#基本ha-远程存储-联邦集群\",\"156\":\"v-be33dc62#按照实例进行功能分区\",\"157\":\"v-be33dc62#高可用方案选择\",\"158\":\"v-584afc86\",\"159\":\"v-584afc86#本地存储\",\"160\":\"v-584afc86#本地存储配置\",\"161\":\"v-584afc86#从失败中恢复\",\"162\":\"v-f9b2b002\",\"163\":\"v-f9b2b002#remote-write\",\"164\":\"v-f9b2b002#remote-read\",\"165\":\"v-f9b2b002#配置文件\",\"166\":\"v-f9b2b002#自定义remote-storage-adaptor\",\"167\":\"v-f9b2b002#使用influxdb作为remote-storage\",\"168\":\"v-f75dbb5c\",\"169\":\"v-f75dbb5c#使用联邦集群\",\"170\":\"v-f75dbb5c#功能分区\",\"171\":\"v-a0312f88\",\"172\":\"v-cde303ba\",\"173\":\"v-2d449918\",\"174\":\"v-2d449918#使用configmaps管理应用配置\",\"175\":\"v-2d449918#使用deployment部署prometheus\",\"176\":\"v-e035c4a4\",\"177\":\"v-4aca2165\",\"178\":\"v-4aca2165#kubernetes应用管理模型\",\"179\":\"v-4aca2165#kubernetes架构模型\",\"180\":\"v-4aca2165#kubernetes监控策略\",\"181\":\"v-4aca2165#搭建本地kubernetes集群\",\"182\":\"v-e45b7782\",\"183\":\"v-e45b7782#kubernetes架构\",\"184\":\"v-e45b7782#监控kubernetes\",\"185\":\"v-5060551e\",\"186\":\"v-5060551e#kubernetes的访问授权\",\"187\":\"v-5060551e#服务发现\",\"188\":\"v-46805560\",\"189\":\"v-46805560#基于node的服务发现模式\",\"190\":\"v-46805560#使用relabeling修改采集任务\",\"191\":\"v-493e27bc\",\"192\":\"v-493e27bc#使用prometheus采集api-server监控数据\",\"193\":\"v-493e27bc#评估kubernetes性能\",\"194\":\"v-0951474a\",\"195\":\"v-0951474a#在kubernetes下部署blackbox-exporter\",\"196\":\"v-0951474a#探测service可用性\",\"197\":\"v-0951474a#探测ingress可用性\",\"198\":\"v-430de613\",\"199\":\"v-430de613#从kubelet获取节点运行状态\",\"200\":\"v-430de613#从kubelet获取节点容器资源使用情况\",\"201\":\"v-430de613#使用nodeexporter监控集群资源使用情况\",\"202\":\"v-430de613#从kube-apiserver获取集群运行监控指标\",\"203\":\"v-430de613#对ingress和service进行网络探测\",\"204\":\"v-10fb3130\",\"205\":\"v-10fb3130#使用daemonset部署node-exporter\",\"206\":\"v-10fb3130#kubernetes下service负载均衡原理\",\"207\":\"v-10fb3130#使用endpoint发现node-exporter实例\",\"208\":\"v-618f4132\",\"209\":\"v-4b055745\",\"210\":\"v-79f8fd28\",\"211\":\"v-f2c3c794\",\"212\":\"v-f2c3c794#使用operator管理告警\",\"213\":\"v-f2c3c794#使用prometheusrule定义告警规则\",\"214\":\"v-f2c3c794#使用operator管理alertmanager实例\",\"215\":\"v-d1a8fb50\",\"216\":\"v-d1a8fb50#创建prometheus实例\",\"217\":\"v-d1a8fb50#使用servicemonitor管理监控配置\",\"218\":\"v-d1a8fb50#关联promethues与servicemonitor\",\"219\":\"v-d1a8fb50#自定义serviceaccount\",\"220\":\"v-1b1b97fe\",\"221\":\"v-1b1b97fe#prometheus-operator的工作原理\",\"222\":\"v-1b1b97fe#prometheus-operator能做什么\",\"223\":\"v-1b1b97fe#在kubernetes集群中部署prometheus-operator\",\"224\":\"v-579748fb\",\"225\":\"v-4f1af98e\",\"226\":\"v-eb88bf0a\",\"227\":\"v-14cf85f2\",\"228\":\"v-14cf85f2#counter-只增不减的计数器\",\"229\":\"v-14cf85f2#gauge-可增可减的仪表盘\",\"230\":\"v-14cf85f2#使用histogram和summary分析数据分布情况\",\"231\":\"v-edc62998\",\"232\":\"v-edc62998#监控所有\",\"233\":\"v-edc62998#监控模式\",\"234\":\"v-edc62998#_4个黄金指标\",\"235\":\"v-edc62998#red方法\",\"236\":\"v-edc62998#use方法\",\"237\":\"v-23a69908\",\"238\":\"v-23a69908#计算counter指标增长率\",\"239\":\"v-23a69908#预测gauge指标变化趋势\",\"240\":\"v-23a69908#统计histogram指标的分位数\",\"241\":\"v-23a69908#动态标签替换\",\"242\":\"v-23a69908#其它内置函数\",\"243\":\"v-97828d96\",\"244\":\"v-97828d96#数学运算\",\"245\":\"v-97828d96#使用布尔运算过滤时间序列\",\"246\":\"v-97828d96#使用bool修饰符改变布尔运算符的行为\",\"247\":\"v-97828d96#使用集合运算符\",\"248\":\"v-97828d96#操作符优先级\",\"249\":\"v-97828d96#匹配模式详解\",\"250\":\"v-97828d96#一对一匹配\",\"251\":\"v-97828d96#多对一和一对多\",\"252\":\"v-ef1d8872\",\"253\":\"v-ef1d8872#api响应格式\",\"254\":\"v-ef1d8872#在http-api中使用promql-1\",\"255\":\"v-ef1d8872#瞬时数据查询\",\"256\":\"v-ef1d8872#响应数据类型\",\"257\":\"v-ef1d8872#区间数据查询\",\"258\":\"v-6cf062d8\",\"259\":\"v-6cf062d8#查询时间序列\",\"260\":\"v-6cf062d8#范围查询\",\"261\":\"v-6cf062d8#时间位移操作\",\"262\":\"v-6cf062d8#使用聚合操作\",\"263\":\"v-6cf062d8#标量和字符串\",\"264\":\"v-6cf062d8#标量-scalar-一个浮点型的数字值\",\"265\":\"v-6cf062d8#字符串-string-一个简单的字符串值\",\"266\":\"v-6cf062d8#合法的promql表达式\",\"267\":\"v-f395da68\",\"268\":\"v-f395da68#样本\",\"269\":\"v-f395da68#指标-metric\",\"270\":\"v-7465afa1\",\"271\":\"v-f712d198\",\"272\":\"v-1ff48934\",\"273\":\"v-1ff48934#从二进制包安装\",\"274\":\"v-1ff48934#使用容器安装\",\"275\":\"v-6196cb7e\",\"276\":\"v-6196cb7e#prometheus-server\",\"277\":\"v-6196cb7e#exporters\",\"278\":\"v-6196cb7e#alertmanager\",\"279\":\"v-6196cb7e#pushgateway\",\"280\":\"v-19707648\",\"281\":\"v-e8f8284e\",\"282\":\"v-00e27581\",\"283\":\"v-0357bae6\",\"284\":\"v-5f8fcc74\",\"285\":\"v-5f8fcc74#安装node-exporter\",\"286\":\"v-5f8fcc74#初始node-exporter监控指标\",\"287\":\"v-5f8fcc74#从node-exporter收集监控数据\",\"288\":\"v-5354d745\",\"289\":\"v-5354d745#监控的目标\",\"290\":\"v-5354d745#与常见监控系统比较\",\"291\":\"v-5354d745#prometheus的优势\",\"292\":\"v-5354d745#易于管理\",\"293\":\"v-5354d745#监控服务的内部运行状态\",\"294\":\"v-5354d745#强大的数据模型\",\"295\":\"v-5354d745#强大的查询语言promql\",\"296\":\"v-5354d745#高效\",\"297\":\"v-5354d745#可扩展\",\"298\":\"v-5354d745#易于集成\",\"299\":\"v-5354d745#可视化\",\"300\":\"v-5354d745#开放性\",\"301\":\"v-34f75852\",\"302\":\"v-2d0aba65\",\"303\":\"v-282d9bf8\",\"304\":\"v-526ca384\",\"305\":\"v-526ca384#consul初体验\",\"306\":\"v-526ca384#与prometheus集成\",\"307\":\"v-4bdf6cd0\",\"308\":\"v-f25aaff6\",\"309\":\"v-f25aaff6#prometheus的relabeling机制\",\"310\":\"v-f25aaff6#使用replace-labelmap重写标签\",\"311\":\"v-f25aaff6#使用keep-drop过滤target实例\",\"312\":\"v-f25aaff6#使用hashmod计算source-labels的hash值\",\"313\":\"v-03937a64\",\"314\":\"v-7efed55e\",\"315\":\"v-3784c6c6\",\"316\":\"v-3784c6c6#http探针\",\"317\":\"v-3784c6c6#自定义http请求\",\"318\":\"v-3784c6c6#自定义探针行为\",\"319\":\"v-8e6d1470\",\"320\":\"v-5d95cf48\",\"321\":\"v-462537a6\",\"322\":\"v-3edbbbc8\",\"323\":\"v-3edbbbc8#prometheus-vs-graphite\",\"324\":\"v-3edbbbc8#范围\",\"325\":\"v-3edbbbc8#数据模型\",\"326\":\"v-3edbbbc8#存储\",\"327\":\"v-3edbbbc8#总结\",\"328\":\"v-3edbbbc8#prometheus-vs-influxdb\",\"329\":\"v-3edbbbc8#范围-1\",\"330\":\"v-3edbbbc8#数据模型-存储\",\"331\":\"v-3edbbbc8#架构设计\",\"332\":\"v-3edbbbc8#总结-1\",\"333\":\"v-3edbbbc8#prometheus-vs-opentsdb\",\"334\":\"v-3edbbbc8#范围-2\",\"335\":\"v-3edbbbc8#数据模型-1\",\"336\":\"v-3edbbbc8#存储-1\",\"337\":\"v-3edbbbc8#总结-2\",\"338\":\"v-3edbbbc8#prometheus-vs-nagios\",\"339\":\"v-3edbbbc8#范围-3\",\"340\":\"v-3edbbbc8#架构\",\"341\":\"v-3edbbbc8#总结-3\",\"342\":\"v-3edbbbc8#prometheus-vs-sensu\",\"343\":\"v-3edbbbc8#范围-4\",\"344\":\"v-3edbbbc8#数据模型-2\",\"345\":\"v-3edbbbc8#架构-1\",\"346\":\"v-3edbbbc8#总结-4\",\"347\":\"v-409908da\",\"348\":\"v-4433c486\",\"349\":\"v-4433c486#初识client-java\",\"350\":\"v-4433c486#client-java的实现过程\",\"351\":\"v-4433c486#自定义collector\",\"352\":\"v-4433c486#直接在代码中集成\",\"353\":\"v-568f80aa\",\"354\":\"v-3af2ed49\",\"355\":\"v-3af2ed49#数学运算符\",\"356\":\"v-3af2ed49#标量与标量\",\"357\":\"v-3af2ed49#标量与瞬时向量\",\"358\":\"v-3af2ed49#瞬时向量与瞬时向量\",\"359\":\"v-3af2ed49#比较运算符\",\"360\":\"v-3af2ed49#瞬时向量与标量\",\"361\":\"v-3af2ed49#使用bool改变比较运算的默认行为\",\"362\":\"v-3af2ed49#标量和标量\",\"363\":\"v-3af2ed49#瞬时向量和瞬时向量\",\"364\":\"v-3af2ed49#逻辑-集合运算符\",\"365\":\"v-3af2ed49#向量匹配模式\",\"366\":\"v-3af2ed49#一对一匹配\",\"367\":\"v-3af2ed49#多对一和一对多\",\"368\":\"v-3af2ed49#聚合操作\",\"369\":\"v-3af2ed49#操作符优先级\",\"370\":\"v-90ba82ea\",\"371\":\"v-90ba82ea#安装node-exporter\",\"372\":\"v-90ba82ea#创建用户\",\"373\":\"v-90ba82ea#获取并安装软件包\",\"374\":\"v-90ba82ea#创建node-exporter的service-unit文件\",\"375\":\"v-90ba82ea#启动node-exporter\",\"376\":\"v-90ba82ea#配置主机监控采集任务\",\"377\":\"v-90ba82ea#配置prometheus采集主机信息\",\"378\":\"v-90ba82ea#验证结果\",\"379\":\"v-8d56add0\",\"380\":\"v-5fb35964\",\"381\":\"v-5fb35964#时间序列选择器\",\"382\":\"v-5fb35964#瞬时向量选择器\",\"383\":\"v-5fb35964#区间向量选择器\",\"384\":\"v-5fb35964#位移选择器\",\"385\":\"v-d3f55732\",\"386\":\"v-2249ac5f\",\"387\":\"v-2249ac5f#从nginx-stats获取监控样本\",\"388\":\"v-2249ac5f#从日志文件中获取监控样本\",\"389\":\"v-2249ac5f#与prometheus集成\",\"390\":\"v-4dcad50a\",\"391\":\"v-63db1e20\",\"392\":\"v-63db1e20#components\",\"393\":\"v-29e3ad5c\",\"394\":\"v-4e634c7e\",\"395\":\"v-4e634c7e#prepare-helm\",\"396\":\"v-4e634c7e#kubernetes-rbd\",\"397\":\"v-4e634c7e#install-operator\",\"398\":\"v-15ff8f86\",\"399\":\"v-15ff8f86#components\",\"400\":\"v-15ff8f86#how-to-run\",\"401\":\"v-7ab5cee7\",\"402\":\"v-2d0a90bd\",\"403\":\"v-21e54510\",\"404\":\"v-3ebfc570\",\"405\":\"v-0aca7ba6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,9],\"1\":[2,35],\"2\":[1],\"3\":[1,25],\"4\":[1,40],\"5\":[1,66],\"6\":[1,1],\"7\":[1,1],\"8\":[3,42],\"9\":[3,42],\"10\":[3,17],\"11\":[1],\"12\":[1],\"13\":[2,14],\"14\":[1,10],\"15\":[1,14],\"16\":[1,51],\"17\":[1,6],\"18\":[2,8],\"19\":[1,1],\"20\":[3,42],\"21\":[3,42],\"22\":[3,17],\"23\":[1,24],\"24\":[2,16],\"25\":[1,8],\"26\":[1,103],\"27\":[1,78],\"28\":[1,86],\"29\":[1,28],\"30\":[1,67],\"31\":[1,82],\"32\":[1,61],\"33\":[1,50],\"34\":[1,26],\"35\":[1,3],\"36\":[1,48],\"37\":[1,35],\"38\":[1],\"39\":[1,35],\"40\":[1,59],\"41\":[1,26],\"42\":[1,72],\"43\":[1,43],\"44\":[1],\"45\":[1,66],\"46\":[1,10],\"47\":[1,18],\"48\":[3,100],\"49\":[1,77],\"50\":[1,89],\"51\":[1,144],\"52\":[1,7],\"53\":[1],\"54\":[1,24],\"55\":[1,67],\"56\":[1,11],\"57\":[1,14],\"58\":[1,34],\"59\":[1,5],\"60\":[1,41],\"61\":[1,5],\"62\":[1,20],\"63\":[1,8],\"64\":[1,5],\"65\":[1,8],\"66\":[1,66],\"67\":[1,81],\"68\":[1,24],\"69\":[2,82],\"70\":[1,9],\"71\":[2,11],\"72\":[2,92],\"73\":[1,6],\"74\":[1],\"75\":[1,20],\"76\":[3,9],\"77\":[1,18],\"78\":[1],\"79\":[1],\"80\":[1],\"81\":[1],\"82\":[2,15],\"83\":[1,6],\"84\":[2,8],\"85\":[1,98],\"86\":[2,82],\"87\":[1,68],\"88\":[1,9],\"89\":[1,51],\"90\":[1,82],\"91\":[1,36],\"92\":[1,8],\"93\":[1,104],\"94\":[2,44],\"95\":[1,220],\"96\":[1,75],\"97\":[1,7],\"98\":[3,21],\"99\":[2,157],\"100\":[1,87],\"101\":[1,26],\"102\":[1,64],\"103\":[1,103],\"104\":[2,44],\"105\":[1,146],\"106\":[1,61],\"107\":[3,9],\"108\":[2,94],\"109\":[1,90],\"110\":[1,90],\"111\":[1,90],\"112\":[1,64],\"113\":[1,6],\"114\":[1,80],\"115\":[1,28],\"116\":[1,151],\"117\":[1,34],\"118\":[2,26],\"119\":[1,12],\"120\":[1,13],\"121\":[1,8],\"122\":[4,16],\"123\":[3,59],\"124\":[1,17],\"125\":[1,12],\"126\":[3,116],\"127\":[1,26],\"128\":[1,30],\"129\":[1,33],\"130\":[1,95],\"131\":[1,40],\"132\":[2,14],\"133\":[1,29],\"134\":[1,112],\"135\":[1,181],\"136\":[2,10],\"137\":[1,7],\"138\":[2,117],\"139\":[1,64],\"140\":[2,11],\"141\":[1,67],\"142\":[1,40],\"143\":[2,9],\"144\":[2,79],\"145\":[2,43],\"146\":[1,8],\"147\":[1,35],\"148\":[1,60],\"149\":[1,52],\"150\":[1,179],\"151\":[1,159],\"152\":[1,17],\"153\":[2,16],\"154\":[3,20],\"155\":[4,35],\"156\":[1,69],\"157\":[1,15],\"158\":[1],\"159\":[1,77],\"160\":[1,79],\"161\":[1,5],\"162\":[1,15],\"163\":[2,12],\"164\":[2,23],\"165\":[1,47],\"166\":[3,120],\"167\":[2,157],\"168\":[1,6],\"169\":[1,75],\"170\":[1,13],\"171\":[2,18],\"172\":[1,5],\"173\":[1,4],\"174\":[1,40],\"175\":[1,101],\"176\":[1,4],\"177\":[1,13],\"178\":[1,73],\"179\":[1,40],\"180\":[1,95],\"181\":[1,226],\"182\":[1,12],\"183\":[1,42],\"184\":[1,55],\"185\":[1,14],\"186\":[1,116],\"187\":[1,171],\"188\":[1,47],\"189\":[1,80],\"190\":[1,116],\"191\":[1,10],\"192\":[2,84],\"193\":[1,45],\"194\":[1,14],\"195\":[2,87],\"196\":[1,43],\"197\":[1,48],\"198\":[1,41],\"199\":[1,135],\"200\":[1,70],\"201\":[1,174],\"202\":[2,118],\"203\":[1,134],\"204\":[1,10],\"205\":[2,120],\"206\":[1,102],\"207\":[2,127],\"208\":[3,12],\"209\":[1,3],\"210\":[2,96],\"211\":[1],\"212\":[1],\"213\":[1,64],\"214\":[1,168],\"215\":[1],\"216\":[1,69],\"217\":[1,149],\"218\":[1,131],\"219\":[1,75],\"220\":[2,17],\"221\":[2,38],\"222\":[2,19],\"223\":[2,68],\"224\":[2,13],\"225\":[1,7],\"226\":[1,77],\"227\":[1,54],\"228\":[2,27],\"229\":[2,39],\"230\":[1,115],\"231\":[2,7],\"232\":[1,43],\"233\":[1,4],\"234\":[1,63],\"235\":[1,19],\"236\":[1,33],\"237\":[1,9],\"238\":[1,59],\"239\":[1,42],\"240\":[1,51],\"241\":[1,58],\"242\":[1,8],\"243\":[1,8],\"244\":[1,59],\"245\":[1,43],\"246\":[1,40],\"247\":[1,21],\"248\":[1,32],\"249\":[1,14],\"250\":[1,60],\"251\":[1,65],\"252\":[2,5],\"253\":[1,37],\"254\":[2,8],\"255\":[1,54],\"256\":[1,43],\"257\":[1,71],\"258\":[1,22],\"259\":[1,55],\"260\":[1,59],\"261\":[1,20],\"262\":[1,26],\"263\":[1,6],\"264\":[3,14],\"265\":[3,16],\"266\":[1,33],\"267\":[1,39],\"268\":[1,65],\"269\":[3,61],\"270\":[2,9],\"271\":[1,9],\"272\":[2,7],\"273\":[1,167],\"274\":[1,18],\"275\":[1,6],\"276\":[2,25],\"277\":[1,24],\"278\":[1,10],\"279\":[1,9],\"280\":[1,66],\"281\":[1,10],\"282\":[1,51],\"283\":[1,57],\"284\":[2],\"285\":[2,69],\"286\":[2,71],\"287\":[2,42],\"288\":[1,15],\"289\":[1,39],\"290\":[1,63],\"291\":[1,6],\"292\":[1,18],\"293\":[1,5],\"294\":[1,39],\"295\":[1,14],\"296\":[1,8],\"297\":[1,14],\"298\":[1,43],\"299\":[1,12],\"300\":[1,18],\"301\":[1],\"302\":[2,17],\"303\":[1,5],\"304\":[1,3],\"305\":[1,215],\"306\":[1,25],\"307\":[1,85],\"308\":[1,36],\"309\":[1,57],\"310\":[2,191],\"311\":[2,57],\"312\":[2,52],\"313\":[1,76],\"314\":[1,42],\"315\":[1],\"316\":[1,26],\"317\":[1,64],\"318\":[1,98],\"319\":[1,37],\"320\":[1],\"321\":[1,47],\"322\":[1,1],\"323\":[3],\"324\":[1,9],\"325\":[1,34],\"326\":[1,12],\"327\":[1,5],\"328\":[3,7],\"329\":[1],\"330\":[2],\"331\":[1],\"332\":[1],\"333\":[3],\"334\":[1],\"335\":[1],\"336\":[1],\"337\":[1],\"338\":[3],\"339\":[1],\"340\":[1],\"341\":[1],\"342\":[3],\"343\":[1],\"344\":[1],\"345\":[1],\"346\":[1],\"347\":[1,22],\"348\":[2,15],\"349\":[2,111],\"350\":[2,175],\"351\":[1,52],\"352\":[1,107],\"353\":[1],\"354\":[1,4],\"355\":[1,14],\"356\":[1,5],\"357\":[1,31],\"358\":[1,40],\"359\":[1,20],\"360\":[1,36],\"361\":[1,34],\"362\":[1,15],\"363\":[1,18],\"364\":[2,19],\"365\":[1,14],\"366\":[1,60],\"367\":[1,65],\"368\":[1,77],\"369\":[1,32],\"370\":[1,25],\"371\":[2],\"372\":[1,8],\"373\":[1,30],\"374\":[3,27],\"375\":[2,15],\"376\":[1],\"377\":[1,30],\"378\":[1,49],\"379\":[1],\"380\":[1],\"381\":[1],\"382\":[1],\"383\":[1],\"384\":[1],\"385\":[1],\"386\":[1],\"387\":[2],\"388\":[1],\"389\":[1],\"390\":[1],\"391\":[3],\"392\":[1,5],\"393\":[1,20],\"394\":[4],\"395\":[2,6],\"396\":[2,22],\"397\":[2,24],\"398\":[3],\"399\":[2,5],\"400\":[3,16],\"401\":[1],\"402\":[1],\"403\":[1],\"404\":[1],\"405\":[1]},\"averageFieldLength\":[1.317733990147782,46.636176339777656],\"storedFields\":{\"0\":{\"h\":\"作者介绍\",\"t\":[\"郑云龙，全栈工程师，CNCF基金会Certified Kubernetes Administrator。在敏捷和DevOps领域有丰富的实践经验，曾作为敏捷和DevOps技术教练向多家大型企业提供咨询和培训。当前在一家容器创业公司负责CaaS产品研发和设计。\"]},\"1\":{\"h\":\"Prometheus操作指南：云原生监控之道\",\"t\":[\"“You can't fixed what you can't see”。 Prometheus被誉为下一代监控系统的首选，是继Kubernetes之后的第一个CNCF基金会顶级项目。本书是一本介绍Prometheus以及周边相关技术的实践书籍。本书主要分为三个部分。第一部分，主要通过一个实际的案例介绍了Prometheus的是什么？能做什么？以及Prometheus的基础架构，让读者对Prometheus有一个基本的认识以及概念。第二部分，本书则重点放在Prometheus的高级实践，包括社区提供的已经实现的Exporter的使用场景以及方法，以及教会读者如果通过Prometheus提供的Client Library根据自身需求创建自定义的Exporter。基于如何使用Prometheus的服务发现能力，提升平台的动态能力。在第二部分的最后我们会介绍如何对Prometheus运维管理，根据需求的不同实现Prometheus的扩容。以及如何通过一些其他的开源工具如Prometheus Operator实现对Prometheus的管理。最后，在第三部分，我们将会在Kubernetes下基于Prometheus构建我们的容器云监控平台，并且基于监控数据实现应用的Auto Scaling。\",\"在通读这些内容后，相信读者能够对Prometheus有一个全面的认识。\"]},\"2\":{\"h\":\"\"},\"3\":{\"h\":\"版本更新历史\",\"t\":[\"4月变更内容：\",\"修改Feedback反馈的内容\",\"在“初始Prometheus小节”中添加Grafana可视化内容；\",\"重构第1章，Prometheus简介小节\",\"重构第2章，理解时间序列小节\",\"重构第2章，Metrics类型小节\",\"重构第2章，PromQL内置函数\",\"第4章，添加使用Blackbox进行黑盒监控\",\"第7章，Prometheus与服务发现\",\"第7章，服务发现与Relabel\",\"第7章 基于文件的服务发现\",\"第7章 基于Consul的服务发现\",\"第8章，初识Kubernetes\",\"第8章，部署Prometheus\",\"第8章 Kubernetes下的服务发现\",\"第8章 监控Kubernetes中的容器\",\"第8章 监控Kubernetes集群中的节点\",\"第8章 监控Kubernetes集群状态\"]},\"4\":{\"h\":\"检查清单\",\"t\":[\"标点符号是否使用正确：逗号、顿号、句号。\",\"语言表达是否太过口语化。\",\"科技类图示，凡事章节号应该使用阿拉伯数字。\",\"是否有明显的错别字。\",\"是否区分了\\\"地\\\"和\\\"的\\\"。\",\"术语在第一次出现的时候，如果标注了英文，后面就可以直接使用中文，或者直接使用英文。\",\"术语的写法要规范，MySQL, CPU。\",\"文中的图，应该有图号，图题，并且在文中应该对图进行一点说明。\",\"文中的图例，需要考虑印刷效果。\",\"关于术语的表述一定要统一，不能一会儿使用中文，一会儿又使用英文。如果对于标签这个词，要使用英文的话，除了在第一次出现的时候给出对应的中文，后面就应该一直使用label这个词（而且首字母的大小写要一致）\",\"常见拼写错误：\",\"源\",\"错误\",\"反映\",\"反应\",\"称为\",\"成为\"]},\"5\":{\"h\":\"全书组织\",\"t\":[\"这里假定你已经对Linux系统以及Docker技术有一定的基本认识，也可能使用过像Java，Golang这样的编程语言，在本书中我们不会事无巨细的讲述所有事。\",\"第1章，是Prometheus基础的综述，通过一个简单案例（使用Prometheus采集主机的监控数据）来了解Prometheus是什么，能做什么，以及它的架构组成。通过阅读本章希望读者能对Prometheus有一个基本的理解和认识。\",\"第2章，读者将会了解到Prometheus的数据模型，以及时间序列模型。同时会学习到如何利用Prometheus的数据查询语言PrmQL(Prometheus Query Language)对监控数据进行查询、聚合、计算等。\",\"第3章，我们的重点将放在监控告警部分，作为监控系统的重要能力之一，我们希望能够及时的了解系统的变化。这一章中读者将学习如何在Prometheus中自定义告警规则，同时了解如何使用AlertManager对告警进行处理。\",\"第4章，介绍Prometheus中一些常用的Exporter的使用场景以及使用方法。之后还会带领读者通过Java和Golang实现自定义的Exporter，同时了解如何在现有应用系统上添加对Prometheus支持，从而实现应用层面的监控对接。\",\"从第1章到第4章的部分都是本书的基础性章节，对大部分的研发或者运维人员来说可以快速掌握，并且能够使用Prometheus来完成一些基本的日常任务。余下的章节我们会关注到Prometheus的高级\\b用法部分。\",\"第5章，\\\"You can't fix what you can't see\\\"。可视化是监控的核心目标之一，这部分将会基于Grafana这一可视化工具实现监控数据可视化，并且了解Grafana作为一个通用的可视化工具是如何与Prometheus进行配合的。\",\"第6章，读者将会了解到如何通过Prometheus的服务发现能力，自动的发现那些需要监控的资源和服务。特别是在云平台或者容器平台中，资源的创建和销毁成本变得更加频繁，通过服务发现自动地去发现监控目标，能够充分简化Prometheus的运维和管理难度。\",\"第7章，在单个节点的情况下Prometheus能够轻松完成对数以百万的监控指标的处理，但是当监控的目标资源以及数据量变得更大的时候，我们如何实现对Prometheus的扩展？这一章节中重点讨论Prometheus高可用方面的能力。\",\"第8章，这一章节中我们的另外一位重要成员Kubernetes将会登场，这里我们会带领读者对Kubernetes有一个基本的认识，并且通过Prometheus构建我们的容器云监控系统。并且介绍如何通过Prometheus与Kubernetes结合实现应用程序的弹性伸缩。\"]},\"6\":{\"h\":\"\",\"t\":[\"内容正在建设中\"]},\"7\":{\"h\":\"项目主页\",\"t\":[\"全书组织\"]},\"8\":{\"h\":\"Part I - Prometheus基础\",\"t\":[\"第1章 天降奇兵\",\"Prometheus简介\",\"初识Prometheus\",\"安装Prometheus Server\",\"使用Node Exporter采集主机数据\",\"使用PromQL查询监控数据\",\"监控数据可视化\",\"任务和实例\",\"Prometheus核心组件\",\"小结\",\"第2章 探索PromQL\",\"理解时间序列\",\"Metrics类型\",\"初识PromQL\",\"PromQL操作符\",\"PromQL聚合操作\",\"PromQL内置函数\",\"在HTTP API中使用PromQL\",\"最佳实践：4个黄金指标和USE方法\",\"小结\",\"第3章 Prometheus告警处理\",\"Prometheus告警简介\",\"自定义Prometheus告警规则\",\"部署AlertManager\",\"Alertmanager配置概述\",\"基于标签的告警处理路由\",\"使用Receiver接收告警信息\",\"集成邮件系统\",\"集成Slack\",\"集成企业微信\",\"集成钉钉：基于Webhook的扩展\",\"告警模板详解\",\"屏蔽告警通知\",\"使用Recoding Rules优化性能\",\"小结\"]},\"9\":{\"h\":\"Part II - Prometheus进阶\",\"t\":[\"第4章 Exporter详解\",\"Exporter是什么\",\"常用Exporter\",\"容器监控：cAdvisor\",\"监控MySQL运行状态：MySQLD Exporter\",\"网络探测：Blackbox Exporter\",\"使用Java自定义Exporter\",\"使用Client Java构建Exporter程序\",\"在应用中内置Prometheus支持\",\"小结\",\"第5章 数据与可视化\",\"使用Console Template\",\"Grafana的基本概念\",\"Grafana与数据可视化\",\"变化趋势：Graph面板\",\"分布统计：Heatmap面板\",\"当前状态：SingleStat面板\",\"模板化Dashboard\",\"小结\",\"第6章 集群与高可用\",\"本地存储\",\"远程存储\",\"联邦集群\",\"Prometheus高可用\",\"Alertmanager高可用\",\"小结\",\"第7章 Prometheus服务发现\",\"Prometheus与服务发现\",\"基于文件的服务发现\",\"基于Consul的服务发现\",\"服务发现与Relabel\",\"小结\"]},\"10\":{\"h\":\"Part III - Prometheus实战\",\"t\":[\"第8章 监控Kubernetes\",\"初识Kubernetes\",\"部署Prometheus\",\"Kubernetes下的服务发现\",\"监控Kubernetes集群\",\"基于Prometheus的弹性伸缩\",\"小结\",\"第9章 Prometheus Operator\",\"什么是Prometheus Operator\",\"使用Operator管理Prometheus\",\"使用Operator管理监控配置\",\"在Prometheus Operator中使用自定义配置\",\"小结\",\"参考资料\"]},\"11\":{\"h\":\"\"},\"12\":{\"h\":\"参考资料\"},\"13\":{\"h\":\"Install & Configuration\",\"t\":[\"https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04\"]},\"14\":{\"h\":\"Storage\",\"t\":[\"https://coreos.com/blog/prometheus-2.0-storage-layer-optimization\"]},\"15\":{\"h\":\"Kubernetes\",\"t\":[\"https://docs.bitnami.com/kubernetes/how-to/configure-autoscaling-custom-metrics/\",\"https://github.com/kubernetes/kube-state-metrics\"]},\"16\":{\"h\":\"Others\",\"t\":[\"https://news.ycombinator.com/item?id=12455045\",\"https://github.com/digitalocean/vulcan\",\"https://github.com/coreos/prometheus-operator/blob/master/Documentation/high-availability.md\",\"https://github.com/katosys/kato/issues/43\",\"https://www.robustperception.io/tag/tuning/\",\"https://www.robustperception.io/how-much-ram-does-my-prometheus-need-for-ingestion/\",\"https://jaxenter.com/prometheus-product-devops-mindset-130860.html\",\"https://www.slideshare.net/brianbrazil/so-you-want-to-write-an-exporter\"]},\"17\":{\"h\":\"PromSQL\",\"t\":[\"https://www.youtube.com/watch?v=lrfTpnzq3Kw\"]},\"18\":{\"h\":\"Exporters:\",\"t\":[\"https://blog.csdn.net/zhaowenbo168/article/details/53196063\"]},\"19\":{\"h\":\"目录\",\"t\":[\"全书组织\"]},\"20\":{\"h\":\"Part I - Prometheus基础\",\"t\":[\"第1章 天降奇兵\",\"Prometheus简介\",\"初识Prometheus\",\"安装Prometheus Server\",\"使用Node Exporter采集主机数据\",\"使用PromQL查询监控数据\",\"监控数据可视化\",\"任务和实例\",\"Prometheus核心组件\",\"小结\",\"第2章 探索PromQL\",\"理解时间序列\",\"Metrics类型\",\"初识PromQL\",\"PromQL操作符\",\"PromQL聚合操作\",\"PromQL内置函数\",\"在HTTP API中使用PromQL\",\"最佳实践：4个黄金指标和USE方法\",\"小结\",\"第3章 Prometheus告警处理\",\"Prometheus告警简介\",\"自定义Prometheus告警规则\",\"部署AlertManager\",\"Alertmanager配置概述\",\"基于标签的告警处理路由\",\"使用Receiver接收告警信息\",\"集成邮件系统\",\"集成Slack\",\"集成企业微信\",\"集成钉钉：基于Webhook的扩展\",\"告警模板详解\",\"屏蔽告警通知\",\"使用Recoding Rules优化性能\",\"小结\"]},\"21\":{\"h\":\"Part II - Prometheus进阶\",\"t\":[\"第4章 Exporter详解\",\"Exporter是什么\",\"常用Exporter\",\"容器监控：cAdvisor\",\"监控MySQL运行状态：MySQLD Exporter\",\"网络探测：Blackbox Exporter\",\"使用Java自定义Exporter\",\"使用Client Java构建Exporter程序\",\"在应用中内置Prometheus支持\",\"小结\",\"第5章 数据与可视化\",\"使用Console Template\",\"Grafana的基本概念\",\"Grafana与数据可视化\",\"变化趋势：Graph面板\",\"分布统计：Heatmap面板\",\"当前状态：SingleStat面板\",\"模板化Dashboard\",\"小结\",\"第6章 集群与高可用\",\"本地存储\",\"远程存储\",\"联邦集群\",\"Prometheus高可用\",\"Alertmanager高可用\",\"小结\",\"第7章 Prometheus服务发现\",\"Prometheus与服务发现\",\"基于文件的服务发现\",\"基于Consul的服务发现\",\"服务发现与Relabel\",\"小结\"]},\"22\":{\"h\":\"Part III - Prometheus实战\",\"t\":[\"第8章 监控Kubernetes\",\"初识Kubernetes\",\"部署Prometheus\",\"Kubernetes下的服务发现\",\"监控Kubernetes集群\",\"基于Prometheus的弹性伸缩\",\"小结\",\"第9章 Prometheus Operator\",\"什么是Prometheus Operator\",\"使用Operator管理Prometheus\",\"使用Operator管理监控配置\",\"在Prometheus Operator中使用自定义配置\",\"小结\",\"参考资料\"]},\"23\":{\"h\":\"\",\"t\":[\"TODO:\",\"Relabeling:\",\"metric_relabel_configs: Metric relabeling is applied to samples as the last step before ingestion\",\"alert_relabel_configs:Alert relabeling is applied to alerts before they are sent to the Alertmanager\"]},\"24\":{\"h\":\"第3章 Prometheus告警处理\",\"t\":[\"本章我们将带领读者探索Prometheus的告警处理机制，在前面的部分中已经介绍了告警能力在Prometheus的架构中被划分为两个部分，在Prometheus Server中定义告警规则以及产生告警，Alertmanager组件则用于处理这些由Prometheus产生的告警。Alertmanager即Prometheus体系中告警的统一处理中心。Alertmanager提供了多种内置第三方告警通知方式，同时还提供了对Webhook通知的支持，通过Webhook用户可以完成对告警更多个性化的扩展。\",\"本章主要内容：\",\"在Prometheus中自定义告警规则\",\"理解Alertmanager特性\",\"基于标签的动态告警处理\",\"将告警通知发送到第三方服务\",\"如何使用Webhook扩展Alertmanager\",\"以及一些其他的性能优化模式\"]},\"25\":{\"h\":\"小结\",\"t\":[\"当故障发生时，即时获取到异常结果是大多数用户使用监控系统的最主要的目的之一。通过Prometheus提供的告警以及告警处理能力，通过内置的告警通知能力，能过帮助用户快速实现告警的通知。同时其还提供了简单有效的扩展方式，让用户可以基于Prometheus的告警处理模式实现更多的定制化需求。\"]},\"26\":{\"h\":\"Alertmanager配置概述\",\"t\":[\"在上面的部分中已经简单介绍过，在Alertmanager中通过路由(Route)来定义告警的处理方式。路由是一个基于标签匹配的树状匹配结构。根据接收到告警的标签匹配相应的处理方式。这里将详细介绍路由相关的内容。\",\"Alertmanager主要负责对Prometheus产生的告警进行统一处理，因此在Alertmanager配置中一般会包含以下几个主要部分：\",\"全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容；\",\"模板（templates）：用于定义告警通知时的模板，如HTML模板，邮件模板等；\",\"告警路由（route）：根据标签匹配，确定当前告警应该如何处理；\",\"接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用；\",\"抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生\",\"其完整配置格式如下：\",\"global: [ resolve_timeout: <duration> | default = 5m ] [ smtp_from: <tmpl_string> ] [ smtp_smarthost: <string> ] [ smtp_hello: <string> | default = \\\"localhost\\\" ] [ smtp_auth_username: <string> ] [ smtp_auth_password: <secret> ] [ smtp_auth_identity: <string> ] [ smtp_auth_secret: <secret> ] [ smtp_require_tls: <bool> | default = true ] [ slack_api_url: <secret> ] [ victorops_api_key: <secret> ] [ victorops_api_url: <string> | default = \\\"https://alert.victorops.com/integrations/generic/20131114/alert/\\\" ] [ pagerduty_url: <string> | default = \\\"https://events.pagerduty.com/v2/enqueue\\\" ] [ opsgenie_api_key: <secret> ] [ opsgenie_api_url: <string> | default = \\\"https://api.opsgenie.com/\\\" ] [ hipchat_api_url: <string> | default = \\\"https://api.hipchat.com/\\\" ] [ hipchat_auth_token: <secret> ] [ wechat_api_url: <string> | default = \\\"https://qyapi.weixin.qq.com/cgi-bin/\\\" ] [ wechat_api_secret: <secret> ] [ wechat_api_corp_id: <string> ] [ http_config: <http_config> ] templates: [ - <filepath> ... ] route: <route> receivers: - <receiver> ... inhibit_rules: [ - <inhibit_rule> ... ] \",\"在全局配置中需要注意的是resolve_timeout，该参数定义了当Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）。该参数的定义可能会影响到告警恢复通知的接收时间，读者可根据自己的实际场景进行定义，其默认值为5分钟。在接下来的部分，我们将已一些实际的例子解释Alertmanager的其它配置内容。\"]},\"27\":{\"h\":\"使用Webhook扩展Alertmanager\",\"t\":[\"在某些情况下除了Alertmanager已经内置的集中告警通知方式以外，对于不同的用户和组织而言还需要一些自定义的告知方式支持。通过Alertmanager提供的webhook支持可以轻松实现这一类的扩展。除了用于支持额外的通知方式，webhook还可以与其他第三方系统集成实现运维自动化，或者弹性伸缩等。\",\"在Alertmanager中可以使用如下配置定义基于webhook的告警接收器receiver。一个receiver可以对应一组webhook配置。\",\"name: <string> webhook_configs: [ - <webhook_config>, ... ] \",\"每一项webhook_config的具体配置格式如下：\",\"# Whether or not to notify about resolved alerts. [ send_resolved: <boolean> | default = true ] # The endpoint to send HTTP POST requests to. url: <string> # The HTTP client's configuration. [ http_config: <http_config> | default = global.http_config ] \",\"send_resolved用于指定是否在告警消除时发送回执消息。url则是用于接收webhook请求的地址。http_configs则是在需要对请求进行SSL配置时使用。\",\"当用户定义webhook用于接收告警信息后，当告警被触发时，Alertmanager会按照以下格式向这些url地址发送HTTP Post请求，请求内容如下：\",\"{ \\\"version\\\": \\\"4\\\", \\\"groupKey\\\": <string>, // key identifying the group of alerts (e.g. to deduplicate) \\\"status\\\": \\\"<resolved|firing>\\\", \\\"receiver\\\": <string>, \\\"groupLabels\\\": <object>, \\\"commonLabels\\\": <object>, \\\"commonAnnotations\\\": <object>, \\\"externalURL\\\": <string>, // backlink to the Alertmanager. \\\"alerts\\\": [ { \\\"labels\\\": <object>, \\\"annotations\\\": <object>, \\\"startsAt\\\": \\\"<rfc3339>\\\", \\\"endsAt\\\": \\\"<rfc3339>\\\" } ] } \"]},\"28\":{\"h\":\"使用Golang创建webhook服务\",\"t\":[\"首先我们尝试使用Golang创建用于接收webhook告警通知的服务。首先创建model包，用于映射ALertmanager发送的告警信息，Alertmanager的一个通知中根据配置的group_by规则可能会包含多条告警信息Alert。创建告警通知对应的结构体Notification。\",\"package model import \\\"time\\\" type Alert struct { Labels map[string]string `json:\\\"labels\\\"` Annotations map[string]string `json:annotations` StartsAt time.Time `json:\\\"startsAt\\\"` EndsAt time.Time `json:\\\"endsAt\\\"` } type Notification struct { Version string `json:\\\"version\\\"` GroupKey string `json:\\\"groupKey\\\"` Status string `json:\\\"status\\\"` Receiver string `json:receiver` GroupLabels map[string]string `json:groupLabels` CommonLabels map[string]string `json:commonLabels` CommonAnnotations map[string]string `json:commonAnnotations` ExternalURL string `json:externalURL` Alerts []Alert `json:alerts` } \",\"这里使用gin-gonic框架创建用于接收Webhook通知的Web服务。定义路由/webhook接收来自Alertmanager的POST请求。\",\"package main import ( \\\"net/http\\\" \\\"github.com/gin-gonic/gin\\\" model \\\"github.com/yunlzheng/alertmanaer-dingtalk-webhook/model\\\" ) func main() { router := gin.Default() router.POST(\\\"/webhook\\\", func(c *gin.Context) { var notification model.Notification err := c.BindJSON(&notification) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\\\"error\\\": err.Error()}) return } c.JSON(http.StatusOK, gin.H{\\\"message\\\": \\\" successful receive alert notification message!\\\"}) }) router.Run() } \"]},\"29\":{\"h\":\"与钉钉集成\",\"t\":[\"钉钉，阿里巴巴出品，专为中国企业打造的免费智能移动办公平台，提供了即时通讯以及移动办公等丰富的功能。\",\"钉钉群机器人是钉钉群的高级扩展功能。群机器人可以将第三方服务的信息聚合到群聊中，实现自动化的信息同步。例如：通过聚合GitHub，GitLab等源码管理服务，实现源码更新同步；通过聚合Trello，JIRA等项目协调服务，实现项目信息同步。不仅如此，群机器人支持Webhook协议的自定义接入，支持更多可能性。这里我们将演示如果将Alertmanager运维报警提醒通过自定义机器人聚合到钉钉群。\",\"这里将继续扩展webhook服务，以支持将Alertmanager的告警通知转发到钉钉平台。完整的示例代码可以从github仓库https://github.com/yunlzheng/alertmanaer-dingtalk-webhook中获取。\"]},\"30\":{\"h\":\"自定义webhook群机器人\",\"t\":[\"通过钉钉客户端（如：桌面或者手机）进入到群设置后选择“群机器人”。将显示如下界面：\",\"群机器人\",\"选择“自定义机器人”，并且按照提示填写机器人名称，获取机器人webhook地址，如下所示：\",\"获取webhook地址\",\"webhook机器人创建成功后，用户就可以使用任何方式向该地址发起HTTP POST请求，即可实现向该群主发送消息。目前自定义机器人支持文本(text)，连接(link)，markdown三种消息类型。\",\"例如，可以向webhook地址以POST形式发送以下\",\"{ \\\"msgtype\\\": \\\"markdown\\\", \\\"markdown\\\": { \\\"title\\\":\\\"Prometheus告警信息\\\", \\\"text\\\": \\\"#### 监控指标\\\\n\\\" + \\\"> 监控描述信息\\\\n\\\\n\\\" + \\\"> ###### 告警时间 \\\\n\\\" }, \\\"at\\\": { \\\"atMobiles\\\": [ \\\"156xxxx8827\\\", \\\"189xxxx8325\\\" ], \\\"isAtAll\\\": false } } \",\"可以使用curl验证钉钉webhook是否能够成功调用：\",\"$ curl -l -H \\\"Content-type: application/json\\\" -X POST -d '{\\\"msgtype\\\": \\\"markdown\\\",\\\"markdown\\\": {\\\"title\\\":\\\"Prometheus告警信息\\\",\\\"text\\\": \\\"#### 监控指标\\\\n> 监控描述信息\\\\n\\\\n> ###### 告警时间 \\\\n\\\"},\\\"at\\\": {\\\"isAtAll\\\": false}}' https://oapi.dingtalk.com/robot/send?access_token=xxxx {\\\"errcode\\\":0,\\\"errmsg\\\":\\\"ok\\\"} \",\"调用成功后，可以在钉钉应用群消息中接收到类似于如下通知消息:\",\"测试消息\"]},\"31\":{\"h\":\"定义转换器将告警通知转化为Dingtalk消息对象\",\"t\":[\"这里定义结构体DingTalkMarkdown用于映射Dingtalk的消息体。\",\"package model type At struct { AtMobiles []string `json:\\\"atMobiles\\\"` IsAtAll bool `json:\\\"isAtAll\\\"` } type DingTalkMarkdown struct { MsgType string `json:\\\"msgtype\\\"` At *At `json:at` Markdown *Markdown `json:\\\"markdown\\\"` } type Markdown struct { Title string `json:\\\"title\\\"` Text string `json:\\\"text\\\"` } \",\"定义转换器将Alertmanager发送的告警通知转换为Dingtalk的消息体。\",\"package transformer import ( \\\"bytes\\\" \\\"fmt\\\" \\\"github.com/yunlzheng/alertmanaer-dingtalk-webhook/model\\\" ) // TransformToMarkdown transform alertmanager notification to dingtalk markdow message func TransformToMarkdown(notification model.Notification) (markdown *model.DingTalkMarkdown, err error) { groupKey := notification.GroupKey status := notification.Status annotations := notification.CommonAnnotations var buffer bytes.Buffer buffer.WriteString(fmt.Sprintf(\\\"### 通知组%s(当前状态:%s) \\\\n\\\", groupKey, status)) buffer.WriteString(fmt.Sprintf(\\\"#### 告警项:\\\\n\\\")) for _, alert := range notification.Alerts { annotations := alert.Annotations buffer.WriteString(fmt.Sprintf(\\\"##### %s\\\\n > %s\\\\n\\\", annotations[\\\"summary\\\"], annotations[\\\"description\\\"])) buffer.WriteString(fmt.Sprintf(\\\"\\\\n> 开始时间：%s\\\\n\\\", alert.StartsAt.Format(\\\"15:04:05\\\"))) } markdown = &model.DingTalkMarkdown{ MsgType: \\\"markdown\\\", Markdown: &model.Markdown{ Title: fmt.Sprintf(\\\"通知组：%s(当前状态:%s)\\\", groupKey, status), Text: buffer.String(), }, At: &model.At{ IsAtAll: false, }, } return } \"]},\"32\":{\"h\":\"创建Dingtalk通知发送包\",\"t\":[\"notifier包中使用golang的net/http包实现与Dingtalk群机器人的交互。Send方法包含两个参数：接收到的告警通知结构体指针，以及Dingtalk群机器人的Webhook地址。\",\"通过包transformer.TransformToMarkdown将Alertmanager告警通知与Dingtalk消息进行映射。\",\"package notifier import ( \\\"bytes\\\" \\\"encoding/json\\\" \\\"fmt\\\" \\\"net/http\\\" \\\"github.com/yunlzheng/alertmanaer-dingtalk-webhook/model\\\" \\\"github.com/yunlzheng/alertmanaer-dingtalk-webhook/transformer\\\" ) func Send(notification model.Notification, dingtalkRobot string) (err error) { markdown, err := transformer.TransformToMarkdown(notification) if err != nil { return } data, err := json.Marshal(markdown) if err != nil { return } req, err := http.NewRequest( \\\"POST\\\", dingtalkRobot, bytes.NewBuffer(data)) if err != nil { return } req.Header.Set(\\\"Content-Type\\\", \\\"application/json\\\") client := &http.Client{} resp, err := client.Do(req) if err != nil { return } defer resp.Body.Close() fmt.Println(\\\"response Status:\\\", resp.Status) fmt.Println(\\\"response Headers:\\\", resp.Header) return } \"]},\"33\":{\"h\":\"扩展启动函数\",\"t\":[\"首先为程序添加命令行参数支持，用于在启动时添加全局的Dingtalk群聊机器人地址。\",\"package main import ( \\\"flag\\\" ... \\\"github.com/yunlzheng/alertmanaer-dingtalk-webhook/notifier\\\" ) var ( h bool defaultRobot string ) func init() { flag.BoolVar(&h, \\\"h\\\", false, \\\"help\\\") flag.StringVar(&defaultRobot, \\\"defaultRobot\\\", \\\"\\\", \\\"global dingtalk robot webhook\\\") } func main() { flag.Parse() if h { flag.Usage() return } ... } \",\"同时通过notifier包的Send方法将告警通知发送给Dingtalk群聊机器人\",\"func main() { ... err = notifier.Send(notification, defaultRobot) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\\\"error\\\": err.Error()}) } c.JSON(http.StatusOK, gin.H{\\\"message\\\": \\\"send to dingtalk successful!\\\"}) } \"]},\"34\":{\"h\":\"使用Dingtalk扩展\",\"t\":[\"运行并启动dingtalk webhook服务之后，修改Alertmanager配置文件, 为default-receiver添加webhook配置，如下所示：\",\"receivers: - name: default-receiver email_configs: - to: yunl.zheng@wise2c.com webhook_configs: - url: http://localhost:8080/webhook \",\"重启Alertmanager服务后，手动拉高虚拟机CPU使用率触发告警条件，此时Dingtalk即可接收到相应的告警通知信息:\",\"钉钉群机器人告警信息\"]},\"35\":{\"h\":\"屏蔽告警通知\",\"t\":[\"Alertmanager提供了方式可以帮助用户控制告警通知的行为，包括预先定义的抑制机制和临时定义的静默规则。\"]},\"36\":{\"h\":\"抑制机制\",\"t\":[\"Alertmanager的抑制机制可以避免当某种问题告警产生之后用户接收到大量由此问题导致的一系列的其它告警通知。例如当集群不可用时，用户可能只希望接收到一条告警，告诉他这时候集群出现了问题，而不是大量的如集群中的应用异常、中间件服务异常的告警通知。\",\"在Alertmanager配置文件中，使用inhibit_rules定义一组告警的抑制规则：\",\"inhibit_rules: [ - <inhibit_rule> ... ] \",\"每一条抑制规则的具体配置如下：\",\"target_match: [ <labelname>: <labelvalue>, ... ] target_match_re: [ <labelname>: <regex>, ... ] source_match: [ <labelname>: <labelvalue>, ... ] source_match_re: [ <labelname>: <regex>, ... ] [ equal: '[' <labelname>, ... ']' ] \",\"当已经发送的告警通知匹配到target_match和target_match_re规则，当有新的告警规则如果满足source_match或者定义的匹配规则，并且已发送的告警与新产生的告警中equal定义的标签完全相同，则启动抑制机制，新的告警不会发送。\",\"例如，定义如下抑制规则：\",\"- source_match: alertname: NodeDown severity: critical target_match: severity: critical equal: - node \",\"例如当集群中的某一个主机节点异常宕机导致告警NodeDown被触发，同时在告警规则中定义了告警级别severity=critical。由于主机异常宕机，该主机上部署的所有服务，中间件会不可用并触发报警。根据抑制规则的定义，如果有新的告警级别为severity=critical，并且告警中标签node的值与NodeDown告警的相同，则说明新的告警是由NodeDown导致的，则启动抑制机制停止向接收器发送通知。\"]},\"37\":{\"h\":\"临时静默\",\"t\":[\"除了基于抑制机制可以控制告警通知的行为以外，用户或者管理员还可以直接通过Alertmanager的UI临时屏蔽特定的告警通知。通过定义标签的匹配规则(字符串或者正则表达式)，如果新的告警通知满足静默规则的设置，则停止向receiver发送通知。\",\"进入Alertmanager UI，点击\\\"New Silence\\\"显示如下内容：\",\"创建静默规则\",\"用户可以通过该UI定义新的静默规则的开始时间以及持续时间，通过Matchers部分可以设置多条匹配规则(字符串匹配或者正则匹配)。填写当前静默规则的创建者以及创建原因后，点击\\\"Create\\\"按钮即可。\",\"通过\\\"Preview Alerts\\\"可以查看预览当前匹配规则匹配到的告警信息。静默规则创建成功后，Alertmanager会开始加载该规则并且设置状态为Pending,当规则生效后则进行到Active状态。\",\"活动的静默规则\",\"当静默规则生效以后，从Alertmanager的Alerts页面下用户将不会看到该规则匹配到的告警信息。\",\"告警信息\",\"对于已经生效的规则，用户可以通过手动点击“Expire”按钮使当前规则过期。\"]},\"38\":{\"h\":\"\"},\"39\":{\"h\":\"临时屏蔽告警通知\",\"t\":[\"除了基于抑制机制可以控制告警通知的行为以外，用户或者管理员还可以直接通过Alertmanager的UI临时屏蔽特定的告警通知。通过定义标签的匹配规则(字符串或者正则表达式)，如果新的告警通知满足静默规则的设置，则不停止向receiver发送通知。\",\"进入Alertmanager UI，点击\\\"New Silence\\\"显示如下内容：\",\"创建静默规则\",\"用户可以通过该UI定义新的静默规则的开始时间以及持续时间，通过Matchers部分可以设置多条匹配规则(字符串匹配或者正则匹配)。填写当前静默规则的创建者以及创建原因后，点击\\\"Create\\\"按钮即可。\",\"通过\\\"Preview Alerts\\\"可以查看预览当前匹配规则匹配到的告警信息。静默规则创建成功后，Alertmanager会开始加载该规则并且设置状态为Pending,当规则生效后则进行到Active状态。\",\"活动的静默规则\",\"当静默规则生效以后，从Alertmanager的Alerts页面下用户将不会看到该规则匹配到的告警信息。\",\"告警信息\",\"对于已经生效的规则，用户可以通过手动点击“Expire”按钮使当前规则过期。\"]},\"40\":{\"h\":\"基于标签的告警路由\",\"t\":[\"在Alertmanager的配置中会定义一个基于标签匹配规则的告警路由树，以确定在接收到告警后Alertmanager需要如何对其进行处理：\",\"route: <route> \",\"其中route中则主要定义了告警的路由匹配规则，以及Alertmanager需要将匹配到的告警发送给哪一个receiver，一个最简单的route定义如下所示：\",\"route: group_by: ['alertname'] receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' \",\"如上所示：在Alertmanager配置文件中，我们只定义了一个路由，那就意味着所有由Prometheus产生的告警在发送到Alertmanager之后都会通过名为web.hook的receiver接收。这里的web.hook定义为一个webhook地址。当然实际场景下，告警处理可不是这么简单的一件事情，对于不同级别的告警，我们可能会有完全不同的处理方式，因此在route中，我们还可以定义更多的子Route，这些Route通过标签匹配告警的处理方式，route的完整定义如下：\",\"[ receiver: <string> ] [ group_by: '[' <labelname>, ... ']' ] [ continue: <boolean> | default = false ] match: [ <labelname>: <labelvalue>, ... ] match_re: [ <labelname>: <regex>, ... ] [ group_wait: <duration> | default = 30s ] [ group_interval: <duration> | default = 5m ] [ repeat_interval: <duration> | default = 4h ] routes: [ - <route> ... ] \"]},\"41\":{\"h\":\"路由匹配\",\"t\":[\"每一个告警都会从配置文件中顶级的route进入路由树，需要注意的是顶级的route必须匹配所有告警(即不能有任何的匹配设置match和match_re)，每一个路由都可以定义自己的接受人以及匹配规则。默认情况下，告警进入到顶级route后会遍历所有的子节点，直到找到最深的匹配route，并将告警发送到该route定义的receiver中。但如果route中设置continue的值为false，那么告警在匹配到第一个子节点之后就直接停止。如果continue为true，报警则会继续进行后续子节点的匹配。如果当前告警匹配不到任何的子节点，那该告警将会基于当前路由节点的接收器配置方式进行处理。\",\"其中告警的匹配有两种方式可以选择。一种方式基于字符串验证，通过设置match规则判断当前告警中是否存在标签labelname并且其值等于labelvalue。第二种方式则基于正则表达式，通过设置match_re验证当前告警标签的值是否满足正则表达式的内容。\",\"如果警报已经成功发送通知, 如果想设置发送告警通知之前要等待时间，则可以通过repeat_interval参数进行设置。\"]},\"42\":{\"h\":\"告警分组\",\"t\":[\"在之前的部分有讲过，Alertmanager可以对告警通知进行分组，将多条告警合合并为一个通知。这里我们可以使用group_by来定义分组规则。基于告警中包含的标签，如果满足group_by中定义标签名称，那么这些告警将会合并为一个通知发送给接收器。\",\"有的时候为了能够一次性收集和发送更多的相关信息时，可以通过group_wait参数设置等待时间，如果在等待时间内，当前group接收到了新的告警，这些告警将会合并为一个通知向receiver发送。\",\"而group_interval配置，则用于定义相同的Group之间发送告警通知的时间间隔。\",\"例如，当使用Prometheus监控多个集群以及部署在集群中的应用和数据库服务，并且定义以下的告警处理路由规则来对集群中的异常进行通知。\",\"route: receiver: 'default-receiver' group_wait: 30s group_interval: 5m repeat_interval: 4h group_by: [cluster, alertname] routes: - receiver: 'database-pager' group_wait: 10s match_re: service: mysql|cassandra - receiver: 'frontend-pager' group_by: [product, environment] match: team: frontend \",\"默认情况下所有的告警都会发送给集群管理员default-receiver，因此在Alertmanager的配置文件的根路由中，对告警信息按照集群以及告警的名称对告警进行分组。\",\"如果告警时来源于数据库服务如MySQL或者Cassandra，此时则需要将告警发送给相应的数据库管理员(database-pager)。这里定义了一个单独子路由，如果告警中包含service标签，并且service为MySQL或者Cassandra,则向database-pager发送告警通知，由于这里没有定义group_by等属性，这些属性的配置信息将从上级路由继承，database-pager将会接收到按cluster和alertname进行分组的告警通知。\",\"而某些告警规则可能来源于开发团队的定义，这些告警中通过添加标签team来标示这些告警的创建者。在Alertmanager配置文件的告警路由下，定义单独子路由用于处理这一类的告警通知，如果匹配到告警中包含标签team，并且team的值为frontend，Alertmanager将会按照标签product和environment对告警进行分组。此时如果应用出现异常，开发团队就能清楚的知道哪一个环境(environment)中的哪一个应用程序出现了问题，可以快速对应用进行问题定位。\"]},\"43\":{\"h\":\"内置告警接收器Receiver\",\"t\":[\"前上一小节已经讲过，在Alertmanager中路由负责对告警信息进行分组匹配，并将像告警接收器发送通知。告警接收器可以通过以下形式进行配置：\",\"receivers: - <receiver> ... \",\"每一个receiver具有一个全局唯一的名称，并且对应一个或者多个通知方式：\",\"name: <string> email_configs: [ - <email_config>, ... ] hipchat_configs: [ - <hipchat_config>, ... ] pagerduty_configs: [ - <pagerduty_config>, ... ] pushover_configs: [ - <pushover_config>, ... ] slack_configs: [ - <slack_config>, ... ] opsgenie_configs: [ - <opsgenie_config>, ... ] webhook_configs: [ - <webhook_config>, ... ] victorops_configs: [ - <victorops_config>, ... ] \",\"目前官方内置的第三方通知集成包括：邮件、 即时通讯软件（如Slack、Hipchat）、移动应用消息推送(如Pushover)和自动化运维工具（例如：Pagerduty、Opsgenie、Victorops）。Alertmanager的通知方式中还可以支持Webhook，通过这种方式开发者可以实现更多个性化的扩展支持。\"]},\"44\":{\"h\":\"\"},\"45\":{\"h\":\"自定义告警模板\",\"t\":[\"默认情况下Alertmanager使用了系统自带的默认通知模板，模板源码可以从https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl获得。Alertmanager的通知模板基于Go的模板系统。Alertmanager也支持用户定义和使用自己的模板，一般来说有两种方式可以选择。\",\"第一种，基于模板字符串。用户可以直接在Alertmanager的配置文件中使用模板字符串，例如:\",\"receivers: - name: 'slack-notifications' slack_configs: - channel: '#alerts' text: 'https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}' \",\"第二种方式，自定义可复用的模板文件。例如，可以创建自定义模板文件custom-template.tmpl，如下所示：\",\"{{ define \\\"slack.myorg.text\\\" }}https://internal.myorg.net/wiki/alerts/{{ .GroupLabels.app }}/{{ .GroupLabels.alertname }}{{ end}} \",\"通过在Alertmanager的全局设置中定义templates配置来指定自定义模板的访问路径:\",\"# Files from which custom notification template definitions are read. # The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'. templates: [ - <filepath> ... ] \",\"在设置了自定义模板的访问路径后，用户则可以直接在配置中使用该模板：\",\"receivers: - name: 'slack-notifications' slack_configs: - channel: '#alerts' text: '{{ template \\\"slack.myorg.text\\\" . }}' templates: - '/etc/alertmanager/templates/myorg.tmpl' \"]},\"46\":{\"h\":\"与Slack集成\",\"t\":[\"Slack是非常流行的团队沟通应用，提供群组聊天和直接消息发送功能，支持移动端，Web 和桌面平台。在国外有大量的IT团队使用Slack作为团队协作平台。同时其提供了强大的集成能力，在Slack的基础上也衍生出了大量的ChatOps相关的技术实践。这部分将介绍如何将Slack集成到Alertmanager中。\"]},\"47\":{\"h\":\"认识Slack\",\"t\":[\"Slack\",\"Slack作为一款即时通讯工具，协作沟通主要通过Channel（平台）来完成，用户可以在企业中根据用途添加多个Channel，并且通过Channel来集成各种第三方工具。\",\"例如，我们可以为监控建立一个单独的Channel用于接收各种监控信息：\",\"创建Channel\",\"通过一个独立的Channle可以减少信息对用户工作的干扰，并且将相关信息聚合在一起：\",\"Monitoring\",\"Slack的强大之处在于在Channel中添加各种第三方服务的集成，用户也可以基于Slack开发自己的聊天机器人来实现一些更高级的能力，例如自动化运维，提高开发效率等。\"]},\"48\":{\"h\":\"添加应用：Incomming Webhooks\",\"t\":[\"为了能够在Monitoring中接收来自Alertmanager的消息，我们需要在Channel的设置选项中使用\\\"Add an App\\\"为Monitoring channel添加一个名为Incoming WebHooks的应用：\",\"添加Incomming Webhooks\",\"添加成功后Slack会显示Incoming WebHooks配置和使用方式：\",\"Incomming Webhhook配置\",\"Incomming Webhook的工作方式很简单，Slack为当前Channel创建了一个用于接收消息的API地址：\",\"https://hooks.slack.com/services/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 \",\"用户只需要使用Post方式向Channel发送需要通知的消息即可，例如，我们可以在命令行中通过curl模拟一次消息通知：\",\"curl -d \\\"payload={'text': 'This is a line of text in a channel.\\\\nAnd this is another line of text.'}\\\" https://hooks.slack.com/services/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 \",\"在网络正常的情况下，在Channel中会显示新的通知信息，如下所示：\",\"测试消息\",\"除了发送纯文本以外，slack还支持在文本内容中添加链接，例如：\",\"payload={\\\"text\\\": \\\"A very important thing has occurred! <https://alert-system.com/alerts/1234|Click here> for details!\\\"} \",\"此时接收到的消息中建辉包含一个可点击的超链接地址。除了payload以外，Incomming Webhhook还支持一些其他的参数：\",\"参数\",\"作用\",\"示例\",\"username\",\"设置当前聊天机器人的名称\",\"webhookbot\",\"icon_url\",\"当前聊天机器人的头像地址\",\"https://slack.com/img/icons/app-57.png\",\"icon_emoji\",\"使用emoji作为聊天机器人的头像\",\"👻\",\"channel\",\"消息发送的目标channel, 需要直接发给特定用户时使用@username即可\",\"#monitoring 或者 @username\",\"例如，使用以上参数发送一条更有趣的消息：\",\"curl -X POST --data-urlencode \\\"payload={'channel': '#monitoring', 'username': 'webhookbot', 'text': 'This is posted to #monitoring and comes from a bot named webhookbot.', 'icon_emoji': ':ghost:'}\\\" https://hooks.slack.com/services/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 \",\"自定义消息\"]},\"49\":{\"h\":\"在Alertmanager中使用Slack\",\"t\":[\"在了解了Slack以及Incomming Webhhook的基本使用方式后，在Alertmanager中添加Slack支持就非常简单了。\",\"在Alertmanager的全局配置中，将Incomming Webhhook地址作为slack_api_url添加到全局配置中即可：\",\"global: slack_api_url: https://hooks.slack.com/services/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 \",\"当然，也可以在每个receiver中单独定义自己的slack_configs即可：\",\"receivers： - name: slack slack_configs: - channel: '#monitoring' send_resolved: true \",\"这里如果我们手动拉高当前主机的CPU利用率，在#Monitoring平台中，我们会接收到一条告警信息如下所示：\",\"告警信息\",\"而当告警项恢复正常后，则可以接收到如下通知：\",\"告警恢复信息\",\"对于Incomming Webhhook支持的其它自定义参数，也可以在slack_config中进行定义，slack_config的主要配置如下：\",\"channel: <tmpl_string> [ send_resolved: <boolean> | default = false ] [ api_url: <secret> | default = global.slack_api_url ] [ icon_emoji: <tmpl_string> ] [ icon_url: <tmpl_string> ] [ link_names: <boolean> | default = false ] [ username: <tmpl_string> | default = '{{ template \\\"slack.default.username\\\" . }}' ] [ color: <tmpl_string> | default = '{{ if eq .Status \\\"firing\\\" }}danger{{ else }}good{{ end }}' ] [ footer: <tmpl_string> | default = '{{ template \\\"slack.default.footer\\\" . }}' ] [ pretext: <tmpl_string> | default = '{{ template \\\"slack.default.pretext\\\" . }}' ] [ text: <tmpl_string> | default = '{{ template \\\"slack.default.text\\\" . }}' ] [ title: <tmpl_string> | default = '{{ template \\\"slack.default.title\\\" . }}' ] [ title_link: <tmpl_string> | default = '{{ template \\\"slack.default.titlelink\\\" . }}' ] [ image_url: <tmpl_string> ] [ thumb_url: <tmpl_string> ] \",\"如果要覆盖默认的告警内容，直接使用Go Template即可。例如：\",\"color: '{{ if eq .Status \\\"firing\\\" }}danger{{ else }}good{{ end }}' \"]},\"50\":{\"h\":\"与SMTP邮件集成\",\"t\":[\"邮箱应该是目前企业最常用的告警通知方式，Alertmanager内置了对SMTP协议的支持，因此对于企业用户而言，只需要一些基本的配置即可实现通过邮件的通知。\",\"在Alertmanager使用邮箱通知，用户只需要定义好SMTP相关的配置，并且在receiver中定义接收方的邮件地址即可。在Alertmanager中我们可以直接在配置文件的global中定义全局的SMTP配置：\",\"global: [ smtp_from: <tmpl_string> ] [ smtp_smarthost: <string> ] [ smtp_hello: <string> | default = \\\"localhost\\\" ] [ smtp_auth_username: <string> ] [ smtp_auth_password: <secret> ] [ smtp_auth_identity: <string> ] [ smtp_auth_secret: <secret> ] [ smtp_require_tls: <bool> | default = true ] \",\"完成全局SMTP之后，我们只需要为receiver配置email_configs用于定义一组接收告警的邮箱地址即可，如下所示：\",\"name: <string> email_configs: [ - <email_config>, ... ] \",\"每个email_config中定义相应的接收人邮箱地址，邮件通知模板等信息即可，当然如果当前接收人需要单独的SMTP配置，那直接在email_config中覆盖即可：\",\"[ send_resolved: <boolean> | default = false ] to: <tmpl_string> [ html: <tmpl_string> | default = '{{ template \\\"email.default.html\\\" . }}' ] [ headers: { <string>: <tmpl_string>, ... } ] \",\"如果当前收件人需要接受告警恢复的通知的话，在email_config中定义send_resolved为true即可。\",\"如果所有的邮件配置使用了相同的SMTP配置，则可以直接定义全局的SMTP配置。\",\"这里，以Gmail邮箱为例，我们定义了一个全局的SMTP配置，并且通过route将所有告警信息发送到default-receiver中:\",\"global: smtp_smarthost: smtp.gmail.com:587 smtp_from: <smtp mail from> smtp_auth_username: <usernae> smtp_auth_identity: <username> smtp_auth_password: <password> route: group_by: ['alertname'] receiver: 'default-receiver' receivers: - name: default-receiver email_configs: - to: <mail to address> send_resolved: true \",\"需要注意的是新的Google账号安全规则需要使用“应用专有密码”作为邮箱登录密码\",\"这时如果手动拉高主机CPU使用率，使得监控样本数据满足告警触发条件。在SMTP配置正确的情况下，可以接收到如下的告警内容：\",\"告警\"]},\"51\":{\"h\":\"与企业微信集成\",\"t\":[\"Alertmanager已经内置了对企业微信的支持，我们可以通过企业微信来管理报警，更进一步可以通过企业微信和微信的互通来直接将告警消息转发到个人微信上。\",\"prometheus官网中给出了企业微信的相关配置说明\",\"# Whether or not to notify about resolved alerts. [ send_resolved: <boolean> | default = false ] # The API key to use when talking to the WeChat API. [ api_secret: <secret> | default = global.wechat_api_secret ] # The WeChat API URL. [ api_url: <string> | default = global.wechat_api_url ] # The corp id for authentication. [ corp_id: <string> | default = global.wechat_api_corp_id ] # API request data as defined by the WeChat API. [ message: <tmpl_string> | default = '{{ template \\\"wechat.default.message\\\" . }}' ] [ agent_id: <string> | default = '{{ template \\\"wechat.default.agent_id\\\" . }}' ] [ to_user: <string> | default = '{{ template \\\"wechat.default.to_user\\\" . }}' ] [ to_party: <string> | default = '{{ template \\\"wechat.default.to_party\\\" . }}' ] [ to_tag: <string> | default = '{{ template \\\"wechat.default.to_tag\\\" . }}' ] \",\"企业微信相关概念说明请参考企业微信API说明，可以在企业微信的后台中建立多个应用，每个应用对应不同的报警分组，由企业微信来做接收成员的划分。具体配置参考如下：\",\"global: resolve_timeout: 10m wechat_api_url: 'https://qyapi.weixin.qq.com/cgi-bin/' wechat_api_secret: '应用的secret，在应用的配置页面可以看到' wechat_api_corp_id: '企业id，在企业的配置页面可以看到' templates: - '/etc/alertmanager/config/*.tmpl' route: group_by: ['alertname'] group_wait: 30s group_interval: 5m repeat_interval: 12h routes: - receiver: 'wechat' continue: true inhibit_rules: - source_match: receivers: - name: 'wechat' wechat_configs: - send_resolved: false corp_id: '企业id，在企业的配置页面可以看到' to_user: '@all' to_party: ' PartyID1 | PartyID2 ' message: '{{ template \\\"wechat.default.message\\\" . }}' agent_id: '应用的AgentId，在应用的配置页面可以看到' api_secret: '应用的secret，在应用的配置页面可以看到' \",\"配置模板示例如下：\",\"{{ define \\\"wechat.default.message\\\" }} {{- if gt (len .Alerts.Firing) 0 -}} {{- range $index, $alert := .Alerts -}} {{- if eq $index 0 -}} 告警类型: {{ $alert.Labels.alertname }} 告警级别: {{ $alert.Labels.severity }} ===================== {{- end }} ===告警详情=== 告警详情: {{ $alert.Annotations.message }} 故障时间: {{ $alert.StartsAt.Format \\\"2006-01-02 15:04:05\\\" }} ===参考信息=== {{ if gt (len $alert.Labels.instance) 0 -}}故障实例ip: {{ $alert.Labels.instance }};{{- end -}} {{- if gt (len $alert.Labels.namespace) 0 -}}故障实例所在namespace: {{ $alert.Labels.namespace }};{{- end -}} {{- if gt (len $alert.Labels.node) 0 -}}故障物理机ip: {{ $alert.Labels.node }};{{- end -}} {{- if gt (len $alert.Labels.pod_name) 0 -}}故障pod名称: {{ $alert.Labels.pod_name }}{{- end }} ===================== {{- end }} {{- end }} {{- if gt (len .Alerts.Resolved) 0 -}} {{- range $index, $alert := .Alerts -}} {{- if eq $index 0 -}} 告警类型: {{ $alert.Labels.alertname }} 告警级别: {{ $alert.Labels.severity }} ===================== {{- end }} ===告警详情=== 告警详情: {{ $alert.Annotations.message }} 故障时间: {{ $alert.StartsAt.Format \\\"2006-01-02 15:04:05\\\" }} 恢复时间: {{ $alert.EndsAt.Format \\\"2006-01-02 15:04:05\\\" }} ===参考信息=== {{ if gt (len $alert.Labels.instance) 0 -}}故障实例ip: {{ $alert.Labels.instance }};{{- end -}} {{- if gt (len $alert.Labels.namespace) 0 -}}故障实例所在namespace: {{ $alert.Labels.namespace }};{{- end -}} {{- if gt (len $alert.Labels.node) 0 -}}故障物理机ip: {{ $alert.Labels.node }};{{- end -}} {{- if gt (len $alert.Labels.pod_name) 0 -}}故障pod名称: {{ $alert.Labels.pod_name }};{{- end }} ===================== {{- end }} {{- end }} {{- end }} \",\"这时如果某一容器频繁重启，可以接收到如下的告警内容：\",\"告警\"]},\"52\":{\"h\":\"部署Alertmanager\",\"t\":[\"Alertmanager和Prometheus Server一样均采用Golang实现，并且没有第三方依赖。一般来说我们可以通过以下几种方式来部署Alertmanager：二进制包、容器以及源码方式安装。\"]},\"53\":{\"h\":\"使用二进制包部署AlertManager\"},\"54\":{\"h\":\"获取并安装软件包\",\"t\":[\"Alertmanager最新版本的下载地址可以从Prometheus官方网站https://prometheus.io/download/获取。\",\"export VERSION=0.15.2 curl -LO https://github.com/prometheus/alertmanager/releases/download/v$VERSION/alertmanager-$VERSION.darwin-amd64.tar.gz tar xvf alertmanager-$VERSION.darwin-amd64.tar.gz \"]},\"55\":{\"h\":\"创建alertmanager配置文件\",\"t\":[\"Alertmanager解压后会包含一个默认的alertmanager.yml配置文件，内容如下所示：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 10s group_interval: 10s repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"Alertmanager的配置主要包含两个部分：路由(route)以及接收器(receivers)。所有的告警信息都会从配置中的顶级路由(route)进入路由树，根据路由规则将告警信息发送给相应的接收器。\",\"在Alertmanager中可以定义一组接收器，比如可以按照角色(比如系统运维，数据库管理员)来划分多个接收器。接收器可以关联邮件，Slack以及其它方式接收告警信息。\",\"当前配置文件中定义了一个默认的接收者default-receiver由于这里没有设置接收方式，目前只相当于一个占位符。关于接收器的详细介绍会在后续章节介绍。\",\"在配置文件中使用route定义了顶级的路由，路由是一个基于标签匹配规则的树状结构。所有的告警信息从顶级路由开始，根据标签匹配规则进入到不同的子路由，并且根据子路由设置的接收器发送告警。目前配置文件中只设置了一个顶级路由route并且定义的接收器为default-receiver。因此，所有的告警都会发送给default-receiver。关于路由的详细内容会在后续进行详细介绍。\"]},\"56\":{\"h\":\"启动Alertmanager\",\"t\":[\"Alermanager会将数据保存到本地中，默认的存储路径为data/。因此，在启动Alertmanager之前需要创建相应的目录：\",\"./alertmanager \",\"用户也在启动Alertmanager时使用参数修改相关配置。--config.file用于指定alertmanager配置文件路径，--storage.path用于指定数据存储路径。\"]},\"57\":{\"h\":\"查看运行状态\",\"t\":[\"Alertmanager启动后可以通过9093端口访问，http://192.168.33.10:9093\",\"Alertmanager页面\",\"Alert菜单下可以查看Alertmanager接收到的告警内容。Silences菜单下则可以通过UI创建静默规则，这部分我们会在后续部分介绍。进入Status菜单，可以看到当前系统的运行状态以及配置信息。\"]},\"58\":{\"h\":\"关联Prometheus与Alertmanager\",\"t\":[\"在Prometheus的架构中被划分成两个独立的部分。Prometheus负责产生告警，而Alertmanager负责告警产生后的后续处理。因此Alertmanager部署完成后，需要在Prometheus中设置Alertmanager相关的信息。\",\"编辑Prometheus配置文件prometheus.yml,并添加以下内容\",\"alerting: alertmanagers: - static_configs: - targets: ['localhost:9093'] \",\"重启Prometheus服务，成功后，可以从http://192.168.33.10:9090/config查看alerting配置是否生效。\",\"此时，再次尝试手动拉高系统CPU使用率：\",\"cat /dev/zero>/dev/null \",\"等待Prometheus告警进行触发状态：\",\"查看Alertmanager UI此时可以看到Alertmanager接收到的告警信息。\"]},\"59\":{\"h\":\"接下来\",\"t\":[\"目前为止，我们已经成功安装部署了Alertmanager并且与Prometheus关联，能够正常接收来自Prometheus的告警信息。接下来我们将详细介绍Alertmanager是如何处理这些接收到的告警信息的。\"]},\"60\":{\"h\":\"Prometheus告警简介\",\"t\":[\"告警能力在Prometheus的架构中被划分成两个独立的部分。如下所示，通过在Prometheus中定义AlertRule（告警规则），Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager发送告警信息。\",\"Prometheus告警处理\",\"在Prometheus中一条告警规则主要由以下几部分组成：\",\"告警名称：用户需要为告警规则命名，当然对于命名而言，需要能够直接表达出该告警的主要内容\",\"告警规则：告警规则实际上主要由PromQL进行定义，其实际意义是当表达式（PromQL）查询结果持续多长时间（During）后出发告警\",\"在Prometheus中，还可以通过Group（告警组）对一组相关的告警进行统一定义。当然这些定义都是通过YAML文件来统一管理的。\",\"Alertmanager作为一个独立的组件，负责接收并处理来自Prometheus Server(也可以是其它的客户端程序)的告警信息。Alertmanager可以对这些告警信息进行进一步的处理，比如当接收到大量重复告警时能够消除重复的告警信息，同时对告警信息进行分组并且路由到正确的通知方，Prometheus内置了对邮件，Slack等多种通知方式的支持，同时还支持与Webhook的集成，以支持更多定制化的场景。例如，目前Alertmanager还不支持钉钉，那用户完全可以通过Webhook与钉钉机器人进行集成，从而通过钉钉接收告警信息。同时AlertManager还提供了静默和告警抑制机制来对告警通知行为进行优化。\"]},\"61\":{\"h\":\"Alertmanager特性\",\"t\":[\"Alertmanager除了提供基本的告警通知能力以外，还主要提供了如：分组、抑制以及静默等告警特性：\",\"Alertmanager特性\"]},\"62\":{\"h\":\"分组\",\"t\":[\"分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。\",\"例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到Alertmanager。\",\"而作为用户，可能只希望能够在一个通知中就能查看哪些服务实例受到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。\",\"告警分组，告警时间，以及告警的接受方式可以通过Alertmanager的配置文件进行配置。\"]},\"63\":{\"h\":\"抑制\",\"t\":[\"抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。\",\"例如，当集群不可访问时触发了一次告警，通过配置Alertmanager可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。\",\"抑制机制同样通过Alertmanager的配置文件进行设置。\"]},\"64\":{\"h\":\"静默\",\"t\":[\"静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager则不会发送告警通知。\",\"静默设置需要在Alertmanager的Web页面上进行设置。\"]},\"65\":{\"h\":\"自定义Prometheus告警规则\",\"t\":[\"Prometheus中的告警规则允许你基于PromQL表达式定义告警触发条件，Prometheus后端对这些触发规则进行周期性计算，当满足触发条件后则会触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Prometheus与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。\"]},\"66\":{\"h\":\"定义告警规则\",\"t\":[\"一条典型的告警规则如下所示：\",\"groups: - name: example rules: - alert: HighErrorRate expr: job:request_latency_seconds:mean5m{job=\\\"myjob\\\"} > 0.5 for: 10m labels: severity: page annotations: summary: High request latency description: description info \",\"在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：\",\"alert：告警规则的名称。\",\"expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。\",\"for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。\",\"labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。\",\"annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。\",\"为了能够让Prometheus启用定义的告警规则，我们需要在Prometheus全局配置文件中通过__rule_files__指定一组告警规则文件的访问路径，Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知：\",\"rule_files: [ - <filepath_glob> ... ] \",\"默认情况下Prometheus会每分钟对这些告警规则进行计算，如果用户想定义自己的告警计算周期，则可以通过evaluation_interval来覆盖默认的计算周期：\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"67\":{\"h\":\"模板化\",\"t\":[\"一般来说，在告警规则文件的annotations中使用summary描述告警的概要信息，description用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。\",\"通过$labels.<labelname>变量可以访问当前告警实例中指定标签的值。$value则可以获取当前PromQL表达式计算的样本值。\",\"# To insert a firing element's label values: {{ $labels.<labelname> }} # To insert the numeric expression value of the firing element: {{ $value }} \",\"例如，可以通过模板化优化summary以及description的内容的可读性：\",\"groups: - name: example rules: # Alert for any instance that is unreachable for >5 minutes. - alert: InstanceDown expr: up == 0 for: 5m labels: severity: page annotations: summary: \\\"Instance {{ $labels.instance }} down\\\" description: \\\"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\\\" # Alert for any instance that has a median request latency >1s. - alert: APIHighRequestLatency expr: api_http_request_latencies_second{quantile=\\\"0.5\\\"} > 1 for: 10m annotations: summary: \\\"High request latency on {{ $labels.instance }}\\\" description: \\\"{{ $labels.instance }} has a median request latency above 1s (current value: {{ $value }}s)\\\" \"]},\"68\":{\"h\":\"查看告警状态\",\"t\":[\"如下所示，用户可以通过Prometheus WEB界面中的Alerts菜单查看当前Prometheus下的所有告警规则，以及其当前所处的活动状态。\",\"告警活动状态\",\"同时对于已经pending或者firing的告警，Prometheus也会将它们存储到时间序列ALERTS{}中。\",\"可以通过表达式，查询告警实例：\",\"ALERTS{alertname=\\\"<alert name>\\\", alertstate=\\\"pending|firing\\\", <additional alert labels>} \",\"样本值为1表示当前告警处于活动状态（pending或者firing），当告警从活动状态转换为非活动状态时，样本值则为0。\"]},\"69\":{\"h\":\"实例：定义主机监控告警\",\"t\":[\"修改Prometheus配置文件prometheus.yml,添加以下配置：\",\"rule_files: - /etc/prometheus/rules/*.rules \",\"在目录/etc/prometheus/rules/下创建告警文件hoststats-alert.rules内容如下：\",\"groups: - name: hostStatsAlert rules: - alert: hostCpuUsageAlert expr: sum(avg without (cpu)(irate(node_cpu{mode!='idle'}[5m]))) by (instance) > 0.85 for: 1m labels: severity: page annotations: summary: \\\"Instance {{ $labels.instance }} CPU usgae high\\\" description: \\\"{{ $labels.instance }} CPU usage above 85% (current value: {{ $value }})\\\" - alert: hostMemUsageAlert expr: (node_memory_MemTotal - node_memory_MemAvailable)/node_memory_MemTotal > 0.85 for: 1m labels: severity: page annotations: summary: \\\"Instance {{ $labels.instance }} MEM usgae high\\\" description: \\\"{{ $labels.instance }} MEM usage above 85% (current value: {{ $value }})\\\" \",\"重启Prometheus后访问Prometheus UIhttp://127.0.0.1:9090/rules可以查看当前以加载的规则文件。\",\"告警规则\",\"切换到Alerts标签http://127.0.0.1:9090/alerts可以查看当前告警的活动状态。\",\"告警活动状态\",\"此时，我们可以手动拉高系统的CPU使用率，验证Prometheus的告警流程，在主机上运行以下命令：\",\"cat /dev/zero>/dev/null \",\"运行命令后查看CPU使用率情况，如下图所示：\",\"Prometheus首次检测到满足触发条件后，hostCpuUsageAlert显示由一条告警处于活动状态。由于告警规则中设置了1m的等待时间，当前告警状态为PENDING，如下图所示：\",\"如果1分钟后告警条件持续满足，则会实际触发告警并且告警状态为FIRING，如下图所示：\"]},\"70\":{\"h\":\"接下来\",\"t\":[\"在这一小节中介绍了如何配置和使用Prometheus提供的告警能力，并且尝试实现了对主机CPU以及内存的告警规则设置。目前为止，我们只能通过Prometheus UI查看当前告警的活动状态。接下来，我们将尝试利用Prometheus体系中的另一个组件Alertmanager对这些触发的告警进行处理，实现告警通知。\"]},\"71\":{\"h\":\"使用Recoding Rules优化性能\",\"t\":[\"通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。\"]},\"72\":{\"h\":\"定义Recoding rules\",\"t\":[\"在Prometheus配置文件中，通过rule_files定义recoding rule规则文件的访问路径。\",\"rule_files: [ - <filepath_glob> ... ] \",\"每一个规则文件通过以下格式进行定义：\",\"groups: [ - <rule_group> ] \",\"一个简单的规则文件可能是这个样子的：\",\"groups: - name: example rules: - record: job:http_inprogress_requests:sum expr: sum(http_inprogress_requests) by (job) \",\"rule_group的具体配置项如下所示：\",\"# The name of the group. Must be unique within a file. name: <string> # How often rules in the group are evaluated. [ interval: <duration> | default = global.evaluation_interval ] rules: [ - <rule> ... ] \",\"与告警规则一致，一个group下可以包含多条规则rule。\",\"# The name of the time series to output to. Must be a valid metric name. record: <string> # The PromQL expression to evaluate. Every evaluation cycle this is # evaluated at the current time, and the result recorded as a new set of # time series with the metric name as given by 'record'. expr: <string> # Labels to add or overwrite before storing the result. labels: [ <labelname>: <labelvalue> ] \",\"根据规则中的定义，Prometheus会在后台完成expr中定义的PromQL表达式计算，并且将计算结果保存到新的时间序列record中。同时还可以通过labels为这些样本添加额外的标签。\",\"这些规则文件的计算频率与告警规则计算频率一致，都通过global.evaluation_interval定义:\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"73\":{\"h\":\"与微信进行集成\",\"t\":[\"在国内，微信已经是最大的即时通讯工具。微信针对企业的应用场景专门退出了面向企业版微信。在这部分，我们将介绍如何将企业微信集成到Alertmanager中。\"]},\"74\":{\"h\":\"共享Dashboard\"},\"75\":{\"h\":\"使用Prometheus构建联邦集群\",\"t\":[\"通过本章前几节的内容读者应该对Prometheus Operator有了一个基本的认识。 这部分，我们将介绍如何通过Prometheus Operator搭建Prometheus联邦集群。\",\"references:\",\"https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint\",\"https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#prometheusspec\",\"additionalScrapeConfigs\"]},\"76\":{\"h\":\"表格：Table Panel\",\"t\":[\"通过表格的形式可以同时显示多条时间序列中的数据，可以方便的查看和比较监控指标的数据。Table Panel是Grafana提供的基础可视化组件之一。\",\"Table Panel示例\",\"对于Prometheus采集到的时间序列数据，Table Panel支持直接将PromQL返回的时间序列格式化为表格的形式进行展示，也可以直接展示时间序列并且对样本数据进行统计聚合。\"]},\"77\":{\"h\":\"格式化时间序列\",\"t\":[\"如下所示，\\bTable Panel在默认情况下Format as配置选项为Table。该配置会直接将PromQL查询到的所有样本格式化为Grafana的Table数据结构，并直接展示到表格当中。\",\"Format As Table\",\"其中样本的所有标签都被映射成表格的列，其中名为Value列会显示当前样本的值。默认情况下样本值不带任何的单位，为了让Table Panel能够自动化格式化样本值，可以通过Column Styles为\\b\\bValue定义样本值的格式化方式，如下所示：\",\"Column Styles选项\"]},\"78\":{\"h\":\"使用Table可视化时间序列\"},\"79\":{\"h\":\"按行显示时间序列\"},\"80\":{\"h\":\"按列显示时间序列\"},\"81\":{\"h\":\"对样本数据进行聚合\"},\"82\":{\"h\":\"第4章 使用Exporter\",\"t\":[\"在第1章中为了采集主机的监控样本数据，我们在主机上安装了一个Node Exporter程序，该程序对外暴露了一个用于获取当前监控样本数据的HTTP访问地址。这样的一个程序称为Exporter，Exporter的实例称为一个Target。Prometheus通过轮询的方式定时从这些Target中获取监控数据样本，并且存储在数据库当中。 在这一章节当中我们将重点讨论这些用于获取特定目标监控样本数据的程序Exporter。\",\"本章的主要内容：\",\"常用Exporter的使用，例如如何监控数据库，消息中间件等\",\"如何实现自定义的Exporter程序\",\"如何对已有的应用程序扩展Prometheus监控支持\"]},\"83\":{\"h\":\"小结\",\"t\":[\"Prometheus负责数据的统一收集并且提供统一的查询接口PromQL，而所有监控数据的产生则是由Exporter来进行实现，对于任何能够提供Promethues标准的监控样本的程序都可以称为Exporter。Exporter可以是一个单独的为了采集特定数据而构建的应用程序，也可以直接内置于特定的系统当中。\"]},\"84\":{\"h\":\"使用Client Java构建Exporter程序\",\"t\":[\"client_java是Prometheus针对JVM类开发语言的client library库，我们可以直接基于client_java用户可以快速实现独立运行的Exporter程序，也可以在我们的项目源码中集成client_java以支持Prometheus。\"]},\"85\":{\"h\":\"自定义Collector\",\"t\":[\"在client_java的simpleclient模块中提供了自定义监控指标的核心接口。\",\"如果使用Gradle作为项目构建工具，可以通过向build.gradle添加simpleclient依赖：\",\"compile 'io.prometheus:simpleclient:0.3.0' \",\"当无法直接修改监控目标时，可以通过自定义Collector的方式，实现对监控样本收集，该收集器需要实现collect()方法并返回一组监控样本，如下所示：\",\"public class YourCustomCollector extends Collector { public List<MetricFamilySamples> collect() { List<MetricFamilySamples> mfs = new ArrayList<MetricFamilySamples>(); String metricName = \\\"my_guage_1\\\"; // Your code to get metrics MetricFamilySamples.Sample sample = new MetricFamilySamples.Sample(metricName, Arrays.asList(\\\"l1\\\"), Arrays.asList(\\\"v1\\\"), 4); MetricFamilySamples.Sample sample2 = new MetricFamilySamples.Sample(metricName, Arrays.asList(\\\"l1\\\", \\\"l2\\\"), Arrays.asList(\\\"v1\\\", \\\"v2\\\"), 3); MetricFamilySamples samples = new MetricFamilySamples(metricName, Type.GAUGE, \\\"help\\\", Arrays.asList(sample, sample2)); mfs.add(samples); return mfs; } } \",\"这里定义了一个名为my_guage的监控指标，该监控指标的所有样本数据均转换为一个MetricFamilySamples.Sample实例，该实例中包含了该样本的指标名称、标签名数组、标签值数组以及样本数据的值。\",\"监控指标my_guage的所有样本值，需要持久化到一个MetricFamilySamples实例中，MetricFamilySamples指定了当前监控指标的名称、类型、注释信息等。需要注意的是MetricFamilySamples中所有样本的名称必须保持一致，否则生成的数据将无法符合Prometheus的规范。\",\"直接使用MetricFamilySamples.Sample和MetricFamilySamples的方式适用于当某监控指标的样本之间的标签可能不一致的情况，例如，当监控容器时，不同容器实例可能包含一些自定义的标签，如果需要将这些标签反应到样本上，那么每个样本的标签则不可能保持一致。而如果所有样本的是一致的情况下，我们还可以使用client_java针对不同指标类型的实现GaugeMetricFamily，CounterMetricFamily，SummaryMetricFamily等，例如：\",\"class YourCustomCollector2 extends Collector { List<MetricFamilySamples> collect() { List<MetricFamilySamples> mfs = new ArrayList<MetricFamilySamples>(); // With no labels. mfs.add(new GaugeMetricFamily(\\\"my_gauge_2\\\", \\\"help\\\", 42)); // With labels GaugeMetricFamily labeledGauge = new GaugeMetricFamily(\\\"my_other_gauge\\\", \\\"help\\\", Arrays.asList(\\\"labelname\\\")); labeledGauge.addMetric(Arrays.asList(\\\"foo\\\"), 4); labeledGauge.addMetric(Arrays.asList(\\\"bar\\\"), 5); mfs.add(labeledGauge); return mfs; } } \"]},\"86\":{\"h\":\"使用HTTP Server暴露样本数据\",\"t\":[\"client_java下的simpleclient_httpserver模块实现了一个简单的HTTP服务器，当向该服务器发送获取样本数据的请求后，它会自动调用所有Collector的collect()方法，并将所有样本数据转换为Prometheus要求的数据输出格式规范。如果用户使用了Gradle构建项目，可以添加以下依赖：\",\"compile 'io.prometheus:simpleclient_httpserver:0.3.0' \",\"添加依赖之后，就可以在Exporter程序的main方法中启动一个HTTPServer实例：\",\"public class CustomExporter { public static void main(String[] args) throws IOException { HTTPServer server = new HTTPServer(1234); } } \",\"而在启动之前，别忘记调用Collector的register()方法。否则HTTPServer是找不到任何的Collector实例的：\",\"new YourCustomCollector().register(); new YourCustomCollector2().register(); \",\"运行CustomExporter并访问http://127.0.0.1:1234/metrics，即可获取到以下数据：\",\"$ curl http://127.0.0.1:1234/metrics # HELP my_gauge help # TYPE my_gauge gauge my_gauge 42.0 # HELP my_other_gauge help # TYPE my_other_gauge gauge my_other_gauge{labelname=\\\"foo\\\",} 4.0 my_other_gauge{labelname=\\\"bar\\\",} 5.0 # HELP my_guage help # TYPE my_guage gauge my_guage{l1=\\\"v1\\\",} 4.0 my_guage{l1=\\\"v1\\\",l2=\\\"v2\\\",} 3.0 \",\"当然HTTPServer中并不存在什么黑魔法，其内部实现如下所示：\",\"HTTPServer处理流程\",\"当调用Collector实例register()方法时，会将该实例保存到CollectorRegistry当中，CollectorRegistry负责维护当前系统中所有的Collector实例。 HTTPServer在接收到HTTP请求之后，会从CollectorRegistry中拿到所有的Collector实例，并调用其collect()方法获取所有样本，最后格式化为Prometheus的标准输出。\",\"除了直接使用HTTPServer以外暴露样本数据以外，client_java中还提供了对Spring Boot、Spring Web以及Servlet的支持。\"]},\"87\":{\"h\":\"使用内置的Collector\",\"t\":[\"通过client_java中定义的标准接口，用户可以快速实现自己的监控数据收集器，并通过HTTPServer将样本数据输出给Prometheus。除了提供接口规范以外，client_java还提供了多个内置的Collector模块，以simpleclient_hotspot为例，该模块中内置了对JVM虚拟机运行状态（GC，内存池，JMX，类加载，线程池等）数据的Collector实现，用户可以通过在Gradle中添加以下依赖，导入simpleclient_hotspot：\",\"compile 'io.prometheus:simpleclient_hotspot:0.3.0' \",\"通过调用io.prometheus.client.hotspot.DefaultExport的initialize方法注册该模块中所有的Collector实例：\",\"DefaultExports.initialize(); \",\"重新运行CustomExporter，并获取样本数据：\",\"$ curl http://127.0.0.1:1234/metrics # HELP jvm_buffer_pool_used_bytes Used bytes of a given JVM buffer pool. # TYPE jvm_buffer_pool_used_bytes gauge jvm_buffer_pool_used_bytes{pool=\\\"direct\\\",} 8192.0 jvm_buffer_pool_used_bytes{pool=\\\"mapped\\\",} 0.0 \",\"除了之前自定义的监控指标以外，在响应内容中还会得到当前JVM的运行状态数据。在client_java项目中除了使用内置了对JVM监控的Collector以外，还实现了对Hibernate，Guava Cache，Jetty，Log4j、Logback等监控数据收集的支持。用户只需要添加相应的依赖，就可以直接进行使用。\"]},\"88\":{\"h\":\"在业务代码中进行监控埋点\",\"t\":[\"在client_java中除了使用Collector直接采集样本数据以外，还直接提供了对Prometheus中4种监控类型的实现分别是：Counter、Gauge、Summary和Histogram。 基于这些实现，开发人员可以非常方便的在应用程序的业务流程中进行监控埋点。\"]},\"89\":{\"h\":\"简单类型Gauge和Counter\",\"t\":[\"以Gauge为例，当我们需要监控某个业务当前正在处理的请求数量，可以使用以下方式实现：\",\"public class YourClass { static final Gauge inprogressRequests = Gauge.build() .name(\\\"inprogress_requests\\\").help(\\\"Inprogress requests.\\\").register(); void processRequest() { inprogressRequests.inc(); // Your code here. inprogressRequests.dec(); } } \",\"Gauge继承自Collector，registoer()方法会将该Gauge实例注册到CollectorRegistry中。这里创建了一个名为inprogress_requests的监控指标，其注释信息为\\\"Inprogress requests\\\"。\",\"Gauge对象主要包含两个方法inc()和dec()，分别用于计数器+1和-1。\",\"如果监控指标中还需要定义标签，则可以使用Gauge构造器的labelNames()方法，声明监控指标的标签，同时在样本计数时，通过指标的labels()方法指定标签的值，如下所示：\",\"public class YourClass { static final Gauge inprogressRequests = Gauge.build() .name(\\\"inprogress_requests\\\") .labelNames(\\\"method\\\") .help(\\\"Inprogress requests.\\\").register(); void processRequest() { inprogressRequests.labels(\\\"get\\\").inc(); // Your code here. inprogressRequests.labels(\\\"get\\\").dec(); } } \",\"Counter与Gauge的使用方法一致，唯一的区别在于Counter实例只包含一个inc()方法，用于计数器+1。\"]},\"90\":{\"h\":\"复杂类型Summary和Histogram\",\"t\":[\"Summary和Histogram用于统计和分析样本的分布情况。如下所示，通过Summary可以将HTTP请求的字节数以及请求处理时间作为统计样本，直接统计其样本的分布情况。\",\"class YourClass { static final Summary receivedBytes = Summary.build() .name(\\\"requests_size_bytes\\\").help(\\\"Request size in bytes.\\\").register(); static final Summary requestLatency = Summary.build() .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\").register(); void processRequest(Request req) { Summary.Timer requestTimer = requestLatency.startTimer(); try { // Your code here. } finally { receivedBytes.observe(req.size()); requestTimer.observeDuration(); } } } \",\"除了使用Timer进行计时以外，Summary实例也提供了timer()方法，可以对线程或者Lamda表达式运行时间进行统计：\",\"class YourClass { static final Summary requestLatency = Summary.build() .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\").register(); void processRequest(Request req) { requestLatency.timer(new Runnable() { public abstract void run() { // Your code here. } }); // Or the Java 8 lambda equivalent requestLatency.timer(() -> { // Your code here. }); } } \",\"Summary和Histogram的用法基本保持一致，区别在于Summary可以指定在客户端统计的分位数，如下所示：\",\"static final Summary requestLatency = Summary.build() .quantile(0.5, 0.05) // 其中0.05为误差 .quantile(0.9, 0.01) // 其中0.01为误差 .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\").register(); \",\"对于Histogram而言，默认的分布桶为[.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10]，如果需要指定自定义的桶分布，可以使用buckets()方法指定，如下所示：\",\" static final Histogram requestLatency = Histogram.build() .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\") .buckets(0.1, 0.2, 0.4, 0.8) .register(); \"]},\"91\":{\"h\":\"与PushGateway集成\",\"t\":[\"对于一些短周期或者临时采集的样本数据，client_java还提供了对PushGateway的支持：\",\"添加依赖：\",\"compile 'io.prometheus:simpleclient_pushgateway:0.3.0' \",\"如下所示，PushGateway的实现类可以从所有注册到defaultRegistry的Collector实例中获取样本数据并直接推送 到外部部署的PushGateway服务中。\",\"public class PushGatewayIntegration { public void push() throws IOException { CollectorRegistry registry = CollectorRegistry.defaultRegistry; PushGateway pg = new PushGateway(\\\"127.0.0.1:9091\\\"); pg.pushAdd(registry, \\\"my_batch_job\\\"); } } \"]},\"92\":{\"h\":\"常用Exporter\",\"t\":[\"在第1章中，我们已经初步了解了Node Exporter的使用场景和方法。本小节，将会介绍更多常用的Exporter用法。包括如何监控容器运行状态，如何监控和评估MySQL服务的运行状态以及如何通过Prometheus实现基于网络探测的黑盒监控。\"]},\"93\":{\"h\":\"在应用中内置Prometheus支持\",\"t\":[\"本小节将以Spring Boot为例，介绍如何在应用代码中集成client_java。\",\"添加Prometheus Java Client相关的依赖：\",\"dependencies { compile 'io.prometheus:simpleclient:0.0.24' compile \\\"io.prometheus:simpleclient_spring_boot:0.0.24\\\" compile \\\"io.prometheus:simpleclient_hotspot:0.0.24\\\" } \",\"通过注解@EnablePrometheusEndpoint启用Prometheus Endpoint，这里同时使用了simpleclient_hotspot中提供的DefaultExporter。该Exporter会在metrics endpoint中统计当前应用JVM的相关信息：\",\"@SpringBootApplication @EnablePrometheusEndpoint public class SpringApplication implements CommandLineRunner { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } @Override public void run(String... strings) throws Exception { DefaultExports.initialize(); } } \",\"默认情况下Prometheus暴露的metrics endpoint为 /prometheus，可以通过endpoint配置进行修改:\",\"endpoints: prometheus: id: metrics metrics: id: springmetrics sensitive: false enabled: true \",\"启动应用程序访问http://localhost:8080/metrics可以看到以下输出内容：\",\"# HELP jvm_gc_collection_seconds Time spent in a given JVM garbage collector in seconds. # TYPE jvm_gc_collection_seconds summary jvm_gc_collection_seconds_count{gc=\\\"PS Scavenge\\\",} 11.0 jvm_gc_collection_seconds_sum{gc=\\\"PS Scavenge\\\",} 0.18 jvm_gc_collection_seconds_count{gc=\\\"PS MarkSweep\\\",} 2.0 jvm_gc_collection_seconds_sum{gc=\\\"PS MarkSweep\\\",} 0.121 # HELP jvm_classes_loaded The number of classes that are currently loaded in the JVM # TYPE jvm_classes_loaded gauge jvm_classes_loaded 8376.0 # HELP jvm_classes_loaded_total The total number of classes that have been loaded since the JVM has started execution # TYPE jvm_classes_loaded_total counter ... \"]},\"94\":{\"h\":\"添加拦截器，为监控埋点做准备\",\"t\":[\"除了获取应用JVM相关的状态以外，我们还可能需要添加一些自定义的监控Metrics实现对系统性能，以及业务状态进行采集，以提供日后优化的相关支撑数据。首先我们使用拦截器处理对应用的所有请求。\",\"继承WebMvcConfigurerAdapter类并复写addInterceptors方法，对所有请求/**添加拦截器\",\"@SpringBootApplication @EnablePrometheusEndpoint public class SpringApplication extends WebMvcConfigurerAdapter implements CommandLineRunner { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new PrometheusMetricsInterceptor()).addPathPatterns(\\\"/**\\\"); } } \",\"PrometheusMetricsInterceptor继承自HandlerInterceptorAdapter，通过复写父方法preHandle和afterCompletion可以拦截一个HTTP请求生命周期的不同阶段：\",\"public class PrometheusMetricsInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return super.preHandle(request, response, handler); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { super.afterCompletion(request, response, handler, ex); } } \"]},\"95\":{\"h\":\"自定义监控指标\",\"t\":[\"一旦PrometheusMetricsInterceptor能够成功拦截和处理请求之后，我们就可以使用client java自定义多种监控指标。\",\"计数器可以用于记录只会增加不会减少的指标类型，比如记录应用请求的总量(http_requests_total)，cpu使用时间(process_cpu_seconds_total)等。 一般而言，Counter类型的metrics指标在命名中我们使用_total结束。\",\"使用Counter.build()创建Counter类型的监控指标，并且通过name()方法定义监控指标的名称，通过labelNames()定义该指标包含的标签。最后通过register()将该指标注册到Collector的defaultRegistry中中。\",\"public class PrometheusMetricsInterceptor extends HandlerInterceptorAdapter { static final Counter requestCounter = Counter.build() .name(\\\"io_namespace_http_requests_total\\\").labelNames(\\\"path\\\", \\\"method\\\", \\\"code\\\") .help(\\\"Total requests.\\\").register(); @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { String requestURI = request.getRequestURI(); String method = request.getMethod(); int status = response.getStatus(); requestCounter.labels(requestURI, method, String.valueOf(status)).inc(); super.afterCompletion(request, response, handler, ex); } } \",\"在afterCompletion方法中，可以获取到当前请求的请求路径、请求方法以及状态码。 这里通过labels指定了当前样本各个标签对应的值，最后通过.inc()计数器+1：\",\"requestCounter.labels(requestURI, method, String.valueOf(status)).inc(); \",\"通过指标io_namespace_http_requests_total我们可以实现：\",\"查询应用的请求总量\",\"# PromQL sum(io_namespace_http_requests_total) \",\"查询每秒Http请求量\",\"# PromQL sum(rate(io_wise2c_gateway_requests_total[5m])) \",\"查询当前应用请求量Top N的URI\",\"# PromQL topk(10, sum(io_namespace_http_requests_total) by (path)) \",\"使用Gauge可以反映应用的__当前状态__,例如在监控主机时，主机当前空闲的内容大小(node_memory_MemFree)，可用内存大小(node_memory_MemAvailable)。或者容器当前的CPU使用率,内存使用率。这里我们使用Gauge记录当前应用正在处理的Http请求数量。\",\"public class PrometheusMetricsInterceptor extends HandlerInterceptorAdapter { ...省略的代码 static final Gauge inprogressRequests = Gauge.build() .name(\\\"io_namespace_http_inprogress_requests\\\").labelNames(\\\"path\\\", \\\"method\\\") .help(\\\"Inprogress requests.\\\").register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ...省略的代码 // 计数器+1 inprogressRequests.labels(requestURI, method).inc(); return super.preHandle(request, response, handler); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { ...省略的代码 // 计数器-1 inprogressRequests.labels(requestURI, method).dec(); super.afterCompletion(request, response, handler, ex); } } \",\"通过指标io_namespace_http_inprogress_requests我们可以直接查询应用当前正在处理中的Http请求数量：\",\"# PromQL io_namespace_http_inprogress_requests{} \",\"Histogram主要用于在指定分布范围内(Buckets)记录大小(如http request bytes)或者事件发生的次数。以请求响应时间requests_latency_seconds为例。\",\"public class PrometheusMetricsInterceptor extends HandlerInterceptorAdapter { static final Histogram requestLatencyHistogram = Histogram.build().labelNames(\\\"path\\\", \\\"method\\\", \\\"code\\\") .name(\\\"io_namespace_http_requests_latency_seconds_histogram\\\").help(\\\"Request latency in seconds.\\\") .register(); private Histogram.Timer histogramRequestTimer; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ...省略的代码 histogramRequestTimer = requestLatencyHistogram.labels(requestURI, method, String.valueOf(status)).startTimer(); ...省略的代码 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { ...省略的代码 histogramRequestTimer.observeDuration(); ...省略的代码 } } \",\"Histogram会自动创建3个指标，分别为：\",\"事件发生总次数： basename_count\",\"# 实际含义： 当前一共发生了2次http请求 io_namespace_http_requests_latency_seconds_histogram_count{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",} 2.0 \",\"所有事件产生值的大小的总和： basename_sum\",\"# 实际含义： 发生的2次http请求总的响应时间为13.107670803000001 秒 io_namespace_http_requests_latency_seconds_histogram_sum{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",} 13.107670803000001 \",\"事件产生的值分布在bucket中的次数： basename_bucket\",\"# 在总共2次请求当中。http请求响应时间 <=0.005 秒 的请求次数为0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.005\\\",} 0.0 # 在总共2次请求当中。http请求响应时间 <=0.01 秒 的请求次数为0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.01\\\",} 0.0 # 在总共2次请求当中。http请求响应时间 <=0.025 秒 的请求次数为0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.025\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.05\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.075\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.1\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.25\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.5\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"0.75\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"1.0\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"2.5\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"5.0\\\",} 0.0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"7.5\\\",} 2.0 # 在总共2次请求当中。http请求响应时间 <=10 秒 的请求次数为0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"10.0\\\",} 2.0 # 在总共2次请求当中。http请求响应时间 10 秒 的请求次数为0 io_namespace_http_requests_latency_seconds_histogram_bucket{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",le=\\\"+Inf\\\",} 2.0 \",\"Summary和Histogram非常类型相似，都可以统计事件发生的次数或者发小，以及其分布情况。Summary和Histogram都提供了对于事件的计数_count以及值的汇总_sum。 因此使用_count,和_sum时间序列可以计算出相同的内容，例如http每秒的平均响应时间：rate(basename_sum[5m]) / rate(basename_count[5m])。同时Summary和Histogram都可以计算和统计样本的分布情况，比如中位数，9分位数等等。其中 0.0<= 分位数Quantiles <= 1.0。\",\"不同在于Histogram可以通过histogram_quantile函数在服务器端计算分位数，而Sumamry的分位数则是直接在客户端进行定义。因此对于分位数的计算。 Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。相对的对于客户端而言Histogram消耗的资源更少。\",\"public class PrometheusMetricsInterceptor extends HandlerInterceptorAdapter { static final Summary requestLatency = Summary.build() .name(\\\"io_namespace_http_requests_latency_seconds_summary\\\") .quantile(0.5, 0.05) .quantile(0.9, 0.01) .labelNames(\\\"path\\\", \\\"method\\\", \\\"code\\\") .help(\\\"Request latency in seconds.\\\").register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ...省略的代码 requestTimer = requestLatency.labels(requestURI, method, String.valueOf(status)).startTimer(); ...省略的代码 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { ...省略的代码 requestTimer.observeDuration(); ...省略的代码 } } \",\"使用Summary指标，会自动创建多个时间序列：\",\"事件发生总的次数\",\"# 含义：当前http请求发生总次数为12次 io_namespace_http_requests_latency_seconds_summary_count{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",} 12.0 \",\"事件产生的值的总和\",\"# 含义：这12次http请求的总响应时间为 51.029495508s io_namespace_http_requests_latency_seconds_summary_sum{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",} 51.029495508 \",\"事件产生的值的分布情况\",\"# 含义：这12次http请求响应时间的中位数是3.052404983s io_namespace_http_requests_latency_seconds_summary{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",quantile=\\\"0.5\\\",} 3.052404983 # 含义：这12次http请求响应时间的9分位数是8.003261666s io_namespace_http_requests_latency_seconds_summary{path=\\\"/\\\",method=\\\"GET\\\",code=\\\"200\\\",quantile=\\\"0.9\\\",} 8.003261666 \"]},\"96\":{\"h\":\"使用Collector暴露其它指标\",\"t\":[\"除了在拦截器中使用Prometheus提供的Counter,Summary,Gauage等构造监控指标以外，我们还可以通过自定义的Collector实现对相关业务指标的暴露。例如，我们可以通过自定义Collector直接从应用程序的数据库中统计监控指标.\",\"@SpringBootApplication @EnablePrometheusEndpoint public class SpringApplication extends WebMvcConfigurerAdapter implements CommandLineRunner { @Autowired private CustomExporter customExporter; ...省略的代码 @Override public void run(String... args) throws Exception { ...省略的代码 customExporter.register(); } } \",\"CustomExporter继承自io.prometheus.client.Collector，在调用Collector的register()方法后，当访问/metrics时，则会自动从Collector的collection()方法中获取采集到的监控指标。\",\"由于这里CustomExporter存在于Spring的IOC容器当中，这里可以直接访问业务代码，返回需要的业务相关的指标。\",\"import io.prometheus.client.Collector; import io.prometheus.client.GaugeMetricFamily; import org.springframework.stereotype.Component; import java.util.ArrayList; import java.util.Collections; import java.util.List; @Component public class CustomExporter extends Collector { @Override public List<MetricFamilySamples> collect() { List<MetricFamilySamples> mfs = new ArrayList<>(); # 创建metrics指标 GaugeMetricFamily labeledGauge = new GaugeMetricFamily(\\\"io_namespace_custom_metrics\\\", \\\"custom metrics\\\", Collections.singletonList(\\\"labelname\\\")); # 设置指标的label以及value labeledGauge.addMetric(Collections.singletonList(\\\"labelvalue\\\"), 1); mfs.add(labeledGauge); return mfs; } } \",\"这里也可以使用CounterMetricFamily，SummaryMetricFamily声明其它的指标类型。\"]},\"97\":{\"h\":\"使用Java自定义Exporter\",\"t\":[\"本小节将带领读者了解Promrtheus提供的client_java的基本用法，并且在最后在Spring Boot应用程序中使用client_java，直接在应用程序层面提供对Prometheus的支持。\"]},\"98\":{\"h\":\"网络探测：Blackbox Exporter\",\"t\":[\"在本章的前几个小节中我们主要介绍了Prometheus下如何进行白盒监控，我们监控主机的资源用量、容器的运行状态、数据库中间件的运行数据。 这些都是支持业务和服务的基础设施，通过白盒能够了解其内部的实际运行状态，通过对监控指标的观察能够预判可能出现的问题，从而对潜在的不确定因素进行优化。而从完整的监控逻辑的角度，除了大量的应用白盒监控以外，还应该添加适当的黑盒监控。黑盒监控即以用户的身份测试服务的外部可见性，常见的黑盒监控包括HTTP探针、TCP探针等用于检测站点或者服务的可访问性，以及访问效率等。\",\"黑盒监控相较于白盒监控最大的不同在于黑盒监控是以故障为导向当故障发生时，黑盒监控能快速发现故障，而白盒监控则侧重于主动发现或者预测潜在的问题。一个完善的监控目标是要能够从白盒的角度发现潜在问题，能够在黑盒的角度快速发现已经发生的问题。\",\"黑盒监控和白盒监控\"]},\"99\":{\"h\":\"使用Blackbox Exporter\",\"t\":[\"Blackbox Exporter是Prometheus社区提供的官方黑盒监控解决方案，其允许用户通过：HTTP、HTTPS、DNS、TCP以及ICMP的方式对网络进行探测。用户可以直接使用go get命令获取Blackbox Exporter源码并生成本地可执行文件：\",\"go get prometheus/blackbox_exporter \",\"运行Blackbox Exporter时，需要用户提供探针的配置信息，这些配置信息可能是一些自定义的HTTP头信息，也可能是探测时需要的一些TSL配置，也可能是探针本身的验证行为。在Blackbox Exporter每一个探针配置称为一个module，并且以YAML配置文件的形式提供给Blackbox Exporter。 每一个module主要包含以下配置内容，包括探针类型（prober）、验证访问超时时间（timeout）、以及当前探针的具体配置项：\",\" # 探针类型：http、 tcp、 dns、 icmp. prober: <prober_string> # 超时时间 [ timeout: <duration> ] # 探针的详细配置，最多只能配置其中的一个 [ http: <http_probe> ] [ tcp: <tcp_probe> ] [ dns: <dns_probe> ] [ icmp: <icmp_probe> ] \",\"下面是一个简化的探针配置文件blockbox.yml，包含两个HTTP探针配置项：\",\"modules: http_2xx: prober: http http: method: GET http_post_2xx: prober: http http: method: POST \",\"通过运行以下命令，并指定使用的探针配置文件启动Blockbox Exporter实例：\",\"blackbox_exporter --config.file=/etc/prometheus/blackbox.yml \",\"启动成功后，就可以通过访问http://127.0.0.1:9115/probe?module=http_2xx&target=baidu.com对baidu.com进行探测。这里通过在URL中提供module参数指定了当前使用的探针，target参数指定探测目标，探针的探测结果通过Metrics的形式返回：\",\"# HELP probe_dns_lookup_time_seconds Returns the time taken for probe dns lookup in seconds # TYPE probe_dns_lookup_time_seconds gauge probe_dns_lookup_time_seconds 0.011633673 # HELP probe_duration_seconds Returns how long the probe took to complete in seconds # TYPE probe_duration_seconds gauge probe_duration_seconds 0.117332275 # HELP probe_failed_due_to_regex Indicates if probe failed due to regex # TYPE probe_failed_due_to_regex gauge probe_failed_due_to_regex 0 # HELP probe_http_content_length Length of http content response # TYPE probe_http_content_length gauge probe_http_content_length 81 # HELP probe_http_duration_seconds Duration of http request by phase, summed over all redirects # TYPE probe_http_duration_seconds gauge probe_http_duration_seconds{phase=\\\"connect\\\"} 0.055551141 probe_http_duration_seconds{phase=\\\"processing\\\"} 0.049736019 probe_http_duration_seconds{phase=\\\"resolve\\\"} 0.011633673 probe_http_duration_seconds{phase=\\\"tls\\\"} 0 probe_http_duration_seconds{phase=\\\"transfer\\\"} 3.8919e-05 # HELP probe_http_redirects The number of redirects # TYPE probe_http_redirects gauge probe_http_redirects 0 # HELP probe_http_ssl Indicates if SSL was used for the final redirect # TYPE probe_http_ssl gauge probe_http_ssl 0 # HELP probe_http_status_code Response HTTP status code # TYPE probe_http_status_code gauge probe_http_status_code 200 # HELP probe_http_version Returns the version of HTTP of the probe response # TYPE probe_http_version gauge probe_http_version 1.1 # HELP probe_ip_protocol Specifies whether probe ip protocol is IP4 or IP6 # TYPE probe_ip_protocol gauge probe_ip_protocol 4 # HELP probe_success Displays whether or not the probe was a success # TYPE probe_success gauge probe_success 1 \",\"从返回的样本中，用户可以获取站点的DNS解析耗时、站点响应时间、HTTP响应状态码等等和站点访问质量相关的监控指标，从而帮助管理员主动的发现故障和问题。\"]},\"100\":{\"h\":\"与Prometheus集成\",\"t\":[\"接下来，只需要在Prometheus下配置对Blockbox Exporter实例的采集任务即可。最直观的配置方式：\",\"- job_name: baidu_http2xx_probe params: module: - http_2xx target: - baidu.com metrics_path: /probe static_configs: - targets: - 127.0.0.1:9115 - job_name: prometheus_http2xx_probe params: module: - http_2xx target: - prometheus.io metrics_path: /probe static_configs: - targets: - 127.0.0.1:9115 \",\"这里分别配置了名为baidu_http2x_probe和prometheus_http2xx_probe的采集任务，并且通过params指定使用的探针（module）以及探测目标（target）。\",\"那问题就来了，假如我们有N个目标站点且都需要M种探测方式，那么Prometheus中将包含N * M个采集任务，从配置管理的角度来说显然是不可接受的。 在第7章的“服务发现与Relabel”小节，我们介绍了Prometheus的Relabeling能力，这里我们也可以采用Relabling的方式对这些配置进行简化，配置方式如下：\",\"scrape_configs: - job_name: 'blackbox' metrics_path: /probe params: module: [http_2xx] static_configs: - targets: - http://prometheus.io # Target to probe with http. - https://prometheus.io # Target to probe with https. - http://example.com:8080 # Target to probe with http on port 8080. relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 127.0.0.1:9115 \",\"这里针对每一个探针服务（如http_2xx）定义一个采集任务，并且直接将任务的采集目标定义为我们需要探测的站点。在采集样本数据之前通过relabel_configs对采集任务进行动态设置。\",\"第1步，根据Target实例的地址，写入__param_target标签中。__param_<name>形式的标签表示，在采集任务时会在请求目标地址中添加<name>参数，等同于params的设置；\",\"第2步，获取__param_target的值，并复写到instance标签中；\",\"第3步，复写Target实例的__address__标签值为BlockBox Exporter实例的访问地址。\",\"通过以上3个relabel步骤，即可大大简化Prometheus任务配置的复杂度:\",\"Blackbox Target实例\",\"接下来，我们将详细介绍Blackbox中常用的HTTP探针使用方式\"]},\"101\":{\"h\":\"HTTP探针\",\"t\":[\"HTTP探针是进行黑盒监控时最常用的探针之一，通过HTTP探针能够网站或者HTTP服务建立有效的监控，包括其本身的可用性，以及用户体验相关的如响应时间等等。除了能够在服务出现异常的时候及时报警，还能帮助系统管理员分析和优化网站体验。\",\"在上一小节讲过，Blockbox Exporter中所有的探针均是以Module的信息进行配置。如下所示，配置了一个最简单的HTTP探针：\",\"modules: http_2xx_example: prober: http http: \",\"通过prober配置项指定探针类型。配置项http用于自定义探针的探测方式，这里有没对http配置项添加任何配置，表示完全使用HTTP探针的默认配置，该探针将使用HTTP GET的方式对目标服务进行探测，并且验证返回状态码是否为2XX，是则表示验证成功，否则失败。\"]},\"102\":{\"h\":\"自定义HTTP请求\",\"t\":[\"HTTP服务通常会以不同的形式对外展现，有些可能就是一些简单的网页，而有些则可能是一些基于REST的API服务。 对于不同类型的HTTP的探测需要管理员能够对HTTP探针的行为进行更多的自定义设置，包括：HTTP请求方法、HTTP头信息、请求参数等。对于某些启用了安全认证的服务还需要能够对HTTP探测设置相应的Auth支持。对于HTTPS类型的服务还需要能够对证书进行自定义设置。\",\"如下所示，这里通过method定义了探测时使用的请求方法，对于一些需要请求参数的服务，还可以通过headers定义相关的请求头信息，使用body定义请求内容：\",\"http_post_2xx: prober: http timeout: 5s http: method: POST headers: Content-Type: application/json body: '{}' \",\"如果HTTP服务启用了安全认证，Blockbox Exporter内置了对basic_auth的支持，可以直接设置相关的认证信息即可：\",\"http_basic_auth_example: prober: http timeout: 5s http: method: POST headers: Host: \\\"login.example.com\\\" basic_auth: username: \\\"username\\\" password: \\\"mysecret\\\" \",\"对于使用了Bear Token的服务也可以通过bearer_token配置项直接指定令牌字符串，或者通过bearer_token_file指定令牌文件。\",\"对于一些启用了HTTPS的服务，但是需要自定义证书的服务，可以通过tls_config指定相关的证书信息：\",\" http_custom_ca_example: prober: http http: method: GET tls_config: ca_file: \\\"/certs/my_cert.crt\\\" \"]},\"103\":{\"h\":\"自定义探针行为\",\"t\":[\"在默认情况下HTTP探针只会对HTTP返回状态码进行校验，如果状态码为2XX（200 <= StatusCode < 300）则表示探测成功，并且探针返回的指标probe_success值为1。\",\"如果用户需要指定HTTP返回状态码，或者对HTTP版本有特殊要求，如下所示，可以使用valid_http_versions和valid_status_codes进行定义：\",\" http_2xx_example: prober: http timeout: 5s http: valid_http_versions: [\\\"HTTP/1.1\\\", \\\"HTTP/2\\\"] valid_status_codes: [] \",\"默认情况下，Blockbox返回的样本数据中也会包含指标probe_http_ssl，用于表明当前探针是否使用了SSL：\",\"# HELP probe_http_ssl Indicates if SSL was used for the final redirect # TYPE probe_http_ssl gauge probe_http_ssl 0 \",\"而如果用户对于HTTP服务是否启用SSL有强制的标准。则可以使用fail_if_ssl和fail_if_not_ssl进行配置。fail_if_ssl为true时，表示如果站点启用了SSL则探针失败，反之成功。fail_if_not_ssl刚好相反。\",\" http_2xx_example: prober: http timeout: 5s http: valid_status_codes: [] method: GET no_follow_redirects: false fail_if_ssl: false fail_if_not_ssl: false \",\"除了基于HTTP状态码，HTTP协议版本以及是否启用SSL作为控制探针探测行为成功与否的标准以外，还可以匹配HTTP服务的响应内容。使用fail_if_matches_regexp和fail_if_not_matches_regexp用户可以定义一组正则表达式，用于验证HTTP返回内容是否符合或者不符合正则表达式的内容。\",\" http_2xx_example: prober: http timeout: 5s http: method: GET fail_if_matches_regexp: - \\\"Could not connect to database\\\" fail_if_not_matches_regexp: - \\\"Download the latest version here\\\" \",\"最后需要提醒的时，默认情况下HTTP探针会走IPV6的协议。 在大多数情况下，可以使用preferred_ip_protocol=ip4强制通过IPV4的方式进行探测。在Bloackbox响应的监控样本中，也会通过指标probe_ip_protocol，表明当前的协议使用情况：\",\"# HELP probe_ip_protocol Specifies whether probe ip protocol is IP4 or IP6 # TYPE probe_ip_protocol gauge probe_ip_protocol 6 \",\"除了支持对HTTP协议进行网络探测以外，Blackbox还支持对TCP、DNS、ICMP等其他网络协议，感兴趣的读者可以从Blackbox的Github项目中获取更多使用信息。\"]},\"104\":{\"h\":\"容器监控：cAdvisor\",\"t\":[\"Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux/Windows/Mac机器上。容器镜像正成为一个新的标准化软件交付方式。\",\"例如，可以通过以下命令快速在本地启动一个Nginx服务：\",\"docker run -itd nginx \",\"为了能够获取到Docker容器的运行状态，用户可以通过Docker的stats命令获取到当前主机上运行容器的统计信息，可以查看容器的CPU利用率、内存使用量、网络IO总量以及磁盘IO总量等信息。\",\"$ docker stats CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 9a1648bec3b2 0.30% 196KiB / 3.855GiB 0.00% 828B / 0B 827kB / 0B 1 \",\"除了使用命令以外，用户还可以通过Docker提供的HTTP API查看容器详细的监控统计信息。\"]},\"105\":{\"h\":\"使用CAdvisor\",\"t\":[\"CAdvisor是Google开源的一款用于展示和分析容器运行状态的可视化工具。通过在主机上运行CAdvisor用户可以轻松的获取到当前主机上容器的运行统计信息，并以图表的形式向用户展示。\",\"在本地运行CAdvisor也非常简单，直接运行一下命令即可：\",\"docker run \\\\ --volume=/:/rootfs:ro \\\\ --volume=/var/run:/var/run:rw \\\\ --volume=/sys:/sys:ro \\\\ --volume=/var/lib/docker/:/var/lib/docker:ro \\\\ --publish=8080:8080 \\\\ --detach=true \\\\ --name=cadvisor \\\\ google/cadvisor:latest \",\"通过访问http://localhost:8080可以查看，当前主机上容器的运行状态，如下所示：\",\"CAdvisor可视化：CPU总量\",\"CAdvisor是一个简单易用的工具，相比于使用Docker命令行工具，用户不用再登录到服务器中即可以可视化图表的形式查看主机上所有容器的运行状态。\",\"而在多主机的情况下，在所有节点上运行一个CAdvisor再通过各自的UI查看监控信息显然不太方便，同时CAdvisor默认只保存2分钟的监控数据。好消息是CAdvisor已经内置了对Prometheus的支持。访问http://localhost:8080/metrics即可获取到标准的Prometheus监控样本输出:\",\"# HELP cadvisor_version_info A metric with a constant '1' value labeled by kernel version, OS version, docker version, cadvisor version & cadvisor revision. # TYPE cadvisor_version_info gauge cadvisor_version_info{cadvisorRevision=\\\"1e567c2\\\",cadvisorVersion=\\\"v0.28.3\\\",dockerVersion=\\\"17.09.1-ce\\\",kernelVersion=\\\"4.9.49-moby\\\",osVersion=\\\"Alpine Linux v3.4\\\"} 1 # HELP container_cpu_load_average_10s Value of container cpu load average over the last 10 seconds. # TYPE container_cpu_load_average_10s gauge container_cpu_load_average_10s{container_label_maintainer=\\\"\\\",id=\\\"/\\\",image=\\\"\\\",name=\\\"\\\"} 0 container_cpu_load_average_10s{container_label_maintainer=\\\"\\\",id=\\\"/docker\\\",image=\\\"\\\",name=\\\"\\\"} 0 container_cpu_load_average_10s{container_label_maintainer=\\\"\\\",id=\\\"/docker/15535a1e09b3a307b46d90400423d5b262ec84dc55b91ca9e7dd886f4f764ab3\\\",image=\\\"busybox\\\",name=\\\"lucid_shaw\\\"} 0 container_cpu_load_average_10s{container_label_maintainer=\\\"\\\",id=\\\"/docker/46750749b97bae47921d49dccdf9011b503e954312b8cffdec6268c249afa2dd\\\",image=\\\"google/cadvisor:latest\\\",name=\\\"cadvisor\\\"} 0 container_cpu_load_average_10s{container_label_maintainer=\\\"NGINX Docker Maintainers <docker-maint@nginx.com>\\\",id=\\\"/docker/f51fd4d4f410965d3a0fd7e9f3250218911c1505e12960fb6dd7b889e75fc114\\\",image=\\\"nginx\\\",name=\\\"confident_brattain\\\"} 0 \",\"下面表格中列举了一些CAdvisor中获取到的典型监控指标：\",\"指标名称\",\"类型\",\"含义\",\"container_cpu_load_average_10s\",\"gauge\",\"过去10秒容器CPU的平均负载\",\"container_cpu_usage_seconds_total\",\"counter\",\"容器在每个CPU内核上的累积占用时间 (单位：秒)\",\"container_cpu_system_seconds_total\",\"counter\",\"System CPU累积占用时间（单位：秒）\",\"container_cpu_user_seconds_total\",\"counter\",\"User CPU累积占用时间（单位：秒）\",\"container_fs_usage_bytes\",\"gauge\",\"容器中文件系统的使用量(单位：字节)\",\"container_fs_limit_bytes\",\"gauge\",\"容器可以使用的文件系统总量(单位：字节)\",\"container_fs_reads_bytes_total\",\"counter\",\"容器累积读取数据的总量(单位：字节)\",\"container_fs_writes_bytes_total\",\"counter\",\"容器累积写入数据的总量(单位：字节)\",\"container_memory_max_usage_bytes\",\"gauge\",\"容器的最大内存使用量（单位：字节）\",\"container_memory_usage_bytes\",\"gauge\",\"容器当前的内存使用量（单位：字节\",\"container_spec_memory_limit_bytes\",\"gauge\",\"容器的内存使用量限制\",\"machine_memory_bytes\",\"gauge\",\"当前主机的内存总量\",\"container_network_receive_bytes_total\",\"counter\",\"容器网络累积接收数据总量（单位：字节）\",\"container_network_transmit_bytes_total\",\"counter\",\"容器网络累积传输数据总量（单位：字节）\"]},\"106\":{\"h\":\"与Prometheus集成\",\"t\":[\"修改/etc/prometheus/prometheus.yml，将cAdvisor添加监控数据采集任务目标当中：\",\"- job_name: cadvisor static_configs: - targets: - localhost:8080 \",\"启动Prometheus服务:\",\"prometheus --config.file=/etc/prometheus/prometheus.yml --storage.tsdb.path=/data/prometheus \",\"启动完成后，可以在Prometheus UI中查看到当前所有的Target状态：\",\"Target\",\"当能够正常采集到cAdvisor的样本数据后，可以通过以下表达式计算容器的CPU使用率：\",\"sum(irate(container_cpu_usage_seconds_total{image!=\\\"\\\"}[1m])) without (cpu) \",\"容器CPU使用率\",\"查询容器内存使用量（单位：字节）:\",\"container_memory_usage_bytes{image!=\\\"\\\"} \",\"查询容器网络接收量速率（单位：字节/秒）：\",\"sum(rate(container_network_receive_bytes_total{image!=\\\"\\\"}[1m])) without (interface) \",\"容器网络接收量 字节/秒\",\"查询容器网络传输量速率（单位：字节/秒）：\",\"sum(rate(container_network_transmit_bytes_total{image!=\\\"\\\"}[1m])) without (interface) \",\"容器网络传输量 字节/秒\",\"查询容器文件系统读取速率（单位：字节/秒）：\",\"sum(rate(container_fs_reads_bytes_total{image!=\\\"\\\"}[1m])) without (device) \",\"容器文件系统读取速率 字节/秒\",\"查询容器文件系统写入速率（单位：字节/秒）：\",\"sum(rate(container_fs_writes_bytes_total{image!=\\\"\\\"}[1m])) without (device) \",\"容器文件系统写入速率 字节/秒\"]},\"107\":{\"h\":\"监控MySQL运行状态：MySQLD Exporter\",\"t\":[\"MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle旗下的产品。 MySQL是最流行的关系型数据库管理系统之一。数据库的稳定运行是保证业务可用性的关键因素之一。这一小节当中将介绍如何使用Prometheus提供的MySQLD Exporter实现对MySQL数据库性能以及资源利用率的监控和度量。\"]},\"108\":{\"h\":\"部署MySQLD Exporter\",\"t\":[\"为了简化测试环境复杂度，这里使用Docker Compose定义并启动MySQL以及MySQLD Exporter：\",\"version: '3' services: mysql: image: mysql:5.7 ports: - \\\"3306:3306\\\" environment: - MYSQL_ROOT_PASSWORD=password - MYSQL_DATABASE=database mysqlexporter: image: prom/mysqld-exporter ports: - \\\"9104:9104\\\" environment: - DATA_SOURCE_NAME=root:password@(mysql:3306)/database \",\"这里通过环境变量DATA_SOURCE_NAME方式定义监控目标。使用Docker Compose启动测试用的MySQL实例以及MySQLD Exporter:\",\"$ docker-compose up -d \",\"启动完成后，可以通过以下命令登录到MySQL容器当中，并执行MySQL相关的指令：\",\"$ docker exec -it <mysql_container_id> mysql -uroot -ppassword mysql> \",\"可以通过http://localhost:9104访问MySQLD Exporter暴露的服务：\",\"可以通过/metrics查看mysql_up指标判断当前MySQLD Exporter是否正常连接到了MySQL实例，当指标值为1时表示能够正常获取监控数据：\",\"# HELP mysql_up Whether the MySQL server is up. # TYPE mysql_up gauge mysql_up 1 \",\"修改Prometheus配置文件/etc/prometheus/prometheus.yml，增加对MySQLD Exporter实例的采集任务配置:\",\"- job_name: mysqld static_configs: - targets: - localhost:9104 \",\"启动Prometheus:\",\"prometheus --config.file=/etc/prometheus/prometheus.yml --storage.tsdb.path=/data/prometheus \",\"通过Prometheus的状态页，可以查看当前Target的状态：\",\"MySQLD Exporter实例状态\",\"为了确保数据库的稳定运行，通常会关注一下四个与性能和资源利用率相关的指标：查询吞吐量、连接情况、缓冲池使用情况以及查询执行性能等。\"]},\"109\":{\"h\":\"监控数据库吞吐量\",\"t\":[\"对于数据库而言，最重要的工作就是实现对数据的增、删、改、查。为了衡量数据库服务器当前的吞吐量变化情况。在MySQL内部通过一个名为Questions的计数器，当客户端发送一个查询语句后，其值就会+1。可以通过以下MySQL指令查询Questions等服务器状态变量的值：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Questions\\\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Questions | 1326 | +---------------+-------+ 1 row in set (0.00 sec) \",\"MySQLD Exporter中返回的样本数据中通过mysql_global_status_questions反映当前Questions计数器的大小：\",\"# HELP mysql_global_status_questions Generic metric from SHOW GLOBAL STATUS. # TYPE mysql_global_status_questions untyped mysql_global_status_questions 1016 \",\"通过以下PromQL可以查看当前MySQL实例查询速率的变化情况，查询数量的突变往往暗示着可能发生了某些严重的问题，因此用于用户应该关注并且设置响应的告警规则，以及时获取该指标的变化情况：\",\"rate(mysql_global_status_questions[2m]) \",\"一般还可以从监控读操作和写操作的执行情况进行判断。通过MySQL全局状态中的Com_select可以查询到当前服务器执行查询语句的总次数：相应的，也可以通过Com_insert、Com_update以及Com_delete的总量衡量当前服务器写操作的总次数，例如，可以通过以下指令查询当前MySQL实例insert语句的执行次数总量：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Com_insert\\\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Com_insert | 0 | +---------------+-------+ 1 row in set (0.00 sec) \",\"从MySQLD Exporter的/metrics返回的监控样本中，可以通过global_status_commands_total获取当前实例各类指令执行的次数：\",\"# HELP mysql_global_status_commands_total Total number of executed MySQL commands. # TYPE mysql_global_status_commands_total counter mysql_global_status_commands_total{command=\\\"admin_commands\\\"} 0 mysql_global_status_commands_total{command=\\\"alter_db\\\"} 0 mysql_global_status_commands_total{command=\\\"alter_db_upgrade\\\"} 0 mysql_global_status_commands_total{command=\\\"select\\\"} 10 mysql_global_status_commands_total{command=\\\"insert\\\"} 2 mysql_global_status_commands_total{command=\\\"update\\\"} 2 mysql_global_status_commands_total{command=\\\"delete\\\"} 1 \",\"用户可以通过以下PromQL查看当前MySQL实例写操作速率的变化情况：\",\"sum(rate(mysql_global_status_commands_total{command=~\\\"insert|update|delete\\\"}[2m])) without (command) \"]},\"110\":{\"h\":\"连接情况\",\"t\":[\"在MySQL中通过全局设置max_connections限制了当前服务器允许的最大客户端连接数量。一旦可用连接数被用尽，新的客户端连接都会被直接拒绝。 因此当监控MySQL运行状态时，需要时刻关注MySQL服务器的连接情况。用户可以通过以下指令查看当前MySQL服务的max_connections配置：\",\"mysql> SHOW VARIABLES LIKE 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 151 | +-----------------+-------+ 1 row in set (0.01 sec) \",\"MySQL默认的最大链接数为151。临时调整最大连接数，可以通过以下指令进行设置：\",\"SET GLOBAL max_connections = 200; \",\"如果想永久化设置，则需要通过修改MySQL配置文件my.cnf，添加以下内容：\",\"max_connections = 200 \",\"通过Global Status中的Threads_connected、Aborted_connects、Connection_errors_max_connections以及Threads_running可以查看当前MySQL实例的连接情况。\",\"例如，通过以下指令可以直接当前MySQL实例的连接数：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Threads_connected\\\"; +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | Threads_connected | 1 | +-------------------+-------+ 1 row in set (0.00 sec) \",\"当所有可用连接都被占用时，如果一个客户端尝试连接至MySQL，会出现“Too many connections(连接数过多)”错误，同时Connection_errors_max_connections的值也会增加。为了防止出现此类情况，你应该监控可用连接的数量，并确保其值保持在max_connections限制以内。同时如果Aborted_connects的数量不断增加时，说明客户端尝试连接到MySQL都失败了。此时可以通过Connection_errors_max_connections以及Connection_errors_internal分析连接失败的问题原因。\",\"下面列举了与MySQL连接相关的监控指标：\",\"mysql_global_variables_max_connections： 允许的最大连接数；\",\"mysql_global_status_threads_connected： 当前开放的连接；\",\"mysql_global_status_threads_running：当前开放的连接；\",\"mysql_global_status_aborted_connects：当前开放的连接；\",\"mysql_global_status_connection_errors_total{error=\\\"max_connections\\\"}：由于超出最大连接数导致的错误；\",\"mysql_global_status_connection_errors_total{error=\\\"internal\\\"}：由于系统内部导致的错误；\",\"通过PromQL查询当前剩余的可用连接数：\",\"mysql_global_variables_max_connections - mysql_global_status_threads_connected \",\"使用PromQL查询当前MySQL实例连接拒绝数：\",\"mysql_global_status_aborted_connects \"]},\"111\":{\"h\":\"监控缓冲池使用情况\",\"t\":[\"MySQL默认的存储引擎InnoDB使用了一片称为缓冲池的内存区域，用于缓存数据表以及索引的数据。 当缓冲池的资源使用超出限制后，可能会导致数据库性能的下降，同时很多查询命令会直接在磁盘中执行，导致磁盘I/O不断攀升。 因此，应该关注MySQL缓冲池的资源使用情况，并且在合理的时间扩大缓冲池的大小可以优化数据库的性能。\",\"Innodb_buffer_pool_pages_total反映了当前缓冲池中的内存页的总页数。可以通过以下指令查看：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Innodb_buffer_pool_pages_total\\\"; +--------------------------------+-------+ | Variable_name | Value | +--------------------------------+-------+ | Innodb_buffer_pool_pages_total | 8191 | +--------------------------------+-------+ 1 row in set (0.02 sec) \",\"MySQLD Exporter通过以下指标返回缓冲池中各类内存页的数量：\",\"# HELP mysql_global_status_buffer_pool_pages Innodb buffer pool pages by state. # TYPE mysql_global_status_buffer_pool_pages gauge mysql_global_status_buffer_pool_pages{state=\\\"data\\\"} 516 mysql_global_status_buffer_pool_pages{state=\\\"dirty\\\"} 0 mysql_global_status_buffer_pool_pages{state=\\\"free\\\"} 7675 mysql_global_status_buffer_pool_pages{state=\\\"misc\\\"} 0 \",\"Innodb_buffer_pool_read_requests记录了正常从缓冲池读取数据的请求数量。可以通过以下指令查看：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Innodb_buffer_pool_read_requests\\\"; +----------------------------------+--------+ | Variable_name | Value | +----------------------------------+--------+ | Innodb_buffer_pool_read_requests | 797023 | +----------------------------------+--------+ 1 row in set (0.00 sec) \",\"MySQLD Exporter通过以下指标返回缓冲池中Innodb_buffer_pool_read_requests的值：\",\"# HELP mysql_global_status_innodb_buffer_pool_read_requests Generic metric from SHOW GLOBAL STATUS. # TYPE mysql_global_status_innodb_buffer_pool_read_requests untyped mysql_global_status_innodb_buffer_pool_read_requests 736711 \",\"当缓冲池无法满足时，MySQL只能从磁盘中读取数据。Innodb_buffer_pool_reads即记录了从磁盘读取数据的请求数量。通常来说从内存中读取数据的速度要比从磁盘中读取快很多，因此，如果Innodb_buffer_pool_reads的值开始增加，可能意味着数据库的性能有问题。 可以通过以下只能查看Innodb_buffer_pool_reads的数量\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Innodb_buffer_pool_reads\\\"; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | Innodb_buffer_pool_reads | 443 | +--------------------------+-------+ 1 row in set (0.00 sec) \",\"在MySQLD Exporter中可以通过以下指标查看Innodb_buffer_pool_reads的数量。\",\"# HELP mysql_global_status_innodb_buffer_pool_reads Generic metric from SHOW GLOBAL STATUS. # TYPE mysql_global_status_innodb_buffer_pool_reads untyped mysql_global_status_innodb_buffer_pool_reads 443 \",\"通过以上监控指标，以及实际监控的场景，我们可以利用PromQL快速建立多个监控项。\",\"通过以下PromQL可以得到各个MySQL实例的缓冲池利用率。一般来说还需要结合Innodb_buffer_pool_reads的增长率情况来判断缓冲池大小是否合理：\",\"(sum(mysql_global_status_buffer_pool_pages) by (instance) - sum(mysql_global_status_buffer_pool_pages{state=\\\"free\\\"}) by (instance)) / sum(mysql_global_status_buffer_pool_pages) by (instance) \",\"也可以通过以下PromQL计算2分钟内磁盘读取请求次数的增长率的变化情况：\",\"rate(mysql_global_status_innodb_buffer_pool_reads[2m]) \"]},\"112\":{\"h\":\"查询性能\",\"t\":[\"MySQL还提供了一个Slow_queries的计数器，当查询的执行时间超过long_query_time的值后，计数器就会+1，其默认值为10秒，可以通过以下指令在MySQL中查询当前long_query_time的设置：\",\"mysql> SHOW VARIABLES LIKE 'long_query_time'; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set (0.00 sec) \",\"通过以下指令可以查看当前MySQL实例中Slow_queries的数量：\",\"mysql> SHOW GLOBAL STATUS LIKE \\\"Slow_queries\\\"; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Slow_queries | 0 | +---------------+-------+ 1 row in set (0.00 sec) \",\"MySQLD Exporter返回的样本数据中，通过以下指标展示当前的Slow_queries的值：\",\"# HELP mysql_global_status_slow_queries Generic metric from SHOW GLOBAL STATUS. # TYPE mysql_global_status_slow_queries untyped mysql_global_status_slow_queries 0 \",\"通过监控Slow_queries的增长率，可以反映出当前MySQL服务器的性能状态，可以通过以下PromQL查询Slow_queries的增长情况：\",\"rate(mysql_global_status_slow_queries[2m]) \",\"在MySQL中还可以通过安装response time插件，从而支持记录查询时间区间的统计信息。启动该功能后MySQLD Exporter也会自动获取到相关数据，从而可以细化MySQL查询响应时间的分布情况。 感兴趣的读者可以自行尝试。\"]},\"113\":{\"h\":\"Exporter是什么\",\"t\":[\"广义上讲，所有可以向Prometheus提供监控样本数据的程序都可以被称为一个Exporter。而Exporter的一个实例称为target，如下所示，Prometheus通过轮询的方式定期从这些target中获取样本数据:\",\"Exporter\"]},\"114\":{\"h\":\"Exporter的来源\",\"t\":[\"从Exporter的来源上来讲，主要分为两类：\",\"社区提供的\",\"Prometheus社区提供了丰富的Exporter实现，涵盖了从基础设施，中间件以及网络等各个方面的监控功能。这些Exporter可以实现大部分通用的监控需求。下表列举一些社区中常用的Exporter：\",\"范围\",\"常用Exporter\",\"数据库\",\"MySQL Exporter, Redis Exporter, MongoDB Exporter, MSSQL Exporter等\",\"硬件\",\"Apcupsd Exporter，IoT Edison Exporter， IPMI Exporter, Node Exporter等\",\"消息队列\",\"Beanstalkd Exporter, Kafka Exporter, NSQ Exporter, RabbitMQ Exporter等\",\"存储\",\"Ceph Exporter, Gluster Exporter, HDFS Exporter, ScaleIO Exporter等\",\"HTTP服务\",\"Apache Exporter, HAProxy Exporter, Nginx Exporter等\",\"API服务\",\"AWS ECS Exporter， Docker Cloud Exporter, Docker Hub Exporter, GitHub Exporter等\",\"日志\",\"Fluentd Exporter, Grok Exporter等\",\"监控系统\",\"Collectd Exporter, Graphite Exporter, InfluxDB Exporter, Nagios Exporter, SNMP Exporter等\",\"其它\",\"Blockbox Exporter, JIRA Exporter, Jenkins Exporter， Confluence Exporter等\",\"用户自定义的\",\"除了直接使用社区提供的Exporter程序以外，用户还可以基于Prometheus提供的Client Library创建自己的Exporter程序，目前Prometheus社区官方提供了对以下编程语言的支持：Go、Java/Scala、Python、Ruby。同时还有第三方实现的如：Bash、C++、Common Lisp、Erlang,、Haskeel、Lua、Node.js、PHP、Rust等。\"]},\"115\":{\"h\":\"Exporter的运行方式\",\"t\":[\"从Exporter的运行方式上来讲，又可以分为：\",\"独立使用的\",\"以我们已经使用过的Node Exporter为例，由于操作系统本身并不直接支持Prometheus，同时用户也无法通过直接从操作系统层面上提供对Prometheus的支持。因此，用户只能通过独立运行一个程序的方式，通过操作系统提供的相关接口，将系统的运行状态数据转换为可供Prometheus读取的监控数据。 除了Node Exporter以外，比如MySQL Exporter、Redis Exporter等都是通过这种方式实现的。 这些Exporter程序扮演了一个中间代理人的角色。\",\"集成到应用中的\",\"为了能够更好的监控系统的内部运行状态，有些开源项目如Kubernetes，ETCD等直接在代码中使用了Prometheus的Client Library，提供了对Prometheus的直接支持。这种方式打破的监控的界限，让应用程序可以直接将内部的运行状态暴露给Prometheus，适合于一些需要更多自定义监控指标需求的项目。\"]},\"116\":{\"h\":\"Exporter规范\",\"t\":[\"所有的Exporter程序都需要按照Prometheus的规范，返回监控的样本数据。以Node Exporter为例，当访问/metrics地址时会返回以下内容：\",\"# HELP node_cpu Seconds the cpus spent in each mode. # TYPE node_cpu counter node_cpu{cpu=\\\"cpu0\\\",mode=\\\"idle\\\"} 362812.7890625 # HELP node_load1 1m load average. # TYPE node_load1 gauge node_load1 3.0703125 \",\"这是一种基于文本的格式规范，在Prometheus 2.0之前的版本还支持Protocol buffer规范。相比于Protocol buffer文本具有更好的可读性，以及跨平台性。Prometheus 2.0的版本也已经不再支持Protocol buffer，这里就不对Protocol buffer规范做详细的阐述。\",\"Exporter返回的样本数据，主要由三个部分组成：样本的一般注释信息（HELP），样本的类型注释信息（TYPE）和样本。Prometheus会对Exporter响应的内容逐行解析：\",\"如果当前行以# HELP开始，Prometheus将会按照以下规则对内容进行解析，得到当前的指标名称以及相应的说明信息：\",\"# HELP <metrics_name> <doc_string> \",\"如果当前行以# TYPE开始，Prometheus会按照以下规则对内容进行解析，得到当前的指标名称以及指标类型:\",\"# TYPE <metrics_name> <metrics_type> \",\"TYPE注释行必须出现在指标的第一个样本之前。如果没有明确的指标类型需要返回为untyped。 除了# 开头的所有行都会被视为是监控样本数据。 每一行样本需要满足以下格式规范:\",\"metric_name [ \\\"{\\\" label_name \\\"=\\\" `\\\"` label_value `\\\"` { \\\",\\\" label_name \\\"=\\\" `\\\"` label_value `\\\"` } [ \\\",\\\" ] \\\"}\\\" ] value [ timestamp ] \",\"其中metric_name和label_name必须遵循PromQL的格式规范要求。value是一个float格式的数据，timestamp的类型为int64（从1970-01-01 00:00:00以来的毫秒数），timestamp为可选默认为当前时间。具有相同metric_name的样本必须按照一个组的形式排列，并且每一行必须是唯一的指标名称和标签键值对组合。\",\"需要特别注意的是对于histogram和summary类型的样本。需要按照以下约定返回样本数据：\",\"类型为summary或者histogram的指标x，该指标所有样本的值的总和需要使用一个单独的x_sum指标表示。\",\"类型为summary或者histogram的指标x，该指标所有样本的总数需要使用一个单独的x_count指标表示。\",\"对于类型为summary的指标x，其不同分位数quantile所代表的样本，需要使用单独的x{quantile=\\\"y\\\"}表示。\",\"对于类型histogram的指标x为了表示其样本的分布情况，每一个分布需要使用x_bucket{le=\\\"y\\\"}表示，其中y为当前分布的上位数。同时必须包含一个样本x_bucket{le=\\\"+Inf\\\"}，并且其样本值必须和x_count相同。\",\"对于histogram和summary的样本，必须按照分位数quantile和分布le的值的递增顺序排序。\",\"以下是类型为histogram和summary的样本输出示例：\",\"# A histogram, which has a pretty complex representation in the text format: # HELP http_request_duration_seconds A histogram of the request duration. # TYPE http_request_duration_seconds histogram http_request_duration_seconds_bucket{le=\\\"0.05\\\"} 24054 http_request_duration_seconds_bucket{le=\\\"0.1\\\"} 33444 http_request_duration_seconds_bucket{le=\\\"0.2\\\"} 100392 http_request_duration_seconds_bucket{le=\\\"+Inf\\\"} 144320 http_request_duration_seconds_sum 53423 http_request_duration_seconds_count 144320 # Finaly a summary, which has a complex representation, too: # HELP rpc_duration_seconds A summary of the RPC duration in seconds. # TYPE rpc_duration_seconds summary rpc_duration_seconds{quantile=\\\"0.01\\\"} 3102 rpc_duration_seconds{quantile=\\\"0.05\\\"} 3272 rpc_duration_seconds{quantile=\\\"0.5\\\"} 4773 rpc_duration_seconds_sum 1.7560473e+07 rpc_duration_seconds_count 2693 \",\"对于某些Prometheus还没有提供支持的编程语言，用户只需要按照以上规范返回响应的文本数据即可。\"]},\"117\":{\"h\":\"指定样本格式的版本\",\"t\":[\"在Exporter响应的HTTP头信息中，可以通过Content-Type指定特定的规范版本，例如：\",\"HTTP/1.1 200 OK Content-Encoding: gzip Content-Length: 2906 Content-Type: text/plain; version=0.0.4 Date: Sat, 17 Mar 2018 08:47:06 GMT \",\"其中version用于指定Text-based的格式版本，当没有指定版本的时候，默认使用最新格式规范的版本。同时HTTP响应头还需要指定压缩格式为gzip。\"]},\"118\":{\"h\":\"第5章 可视化一切\",\"t\":[\"\\\"You can't fix what you can't see\\\"。可视化是监控的核心目标之一，在本章中我们将介绍Prometheus下的可视化技术。例如，Prometheus自身提供的Console Template能力以及Grafana这一可视化工具实现监控数据可视化。Prometheus UI提供了基本的数据可视化能力，可以帮助用户直接使用PromQL查询数据，并将数据通过可视化图表的方式进行展示，而实际的应用场景中往往不同的人对于可视化的需求不一样，关注的指标也不一样，因此我们需要能够有能力，构建出不同的可视化报表页面。 本章学习的内容就主要解决以上问题。\",\"本章的主要内容：\",\"使用Console Template创建可视化页面\",\"使用Grafana创建更精美的数据仪表盘\"]},\"119\":{\"h\":\"小结\",\"t\":[\"\\\"You can't fix what you can't see\\\"。可视化是监控的核心目标之一，在本章中我们学习了如何通过Prometheus内置的Console Template实现基本的可视化能力，以及通过更专业的开源工具Grafana实现Prometheus的数据可视化。\"]},\"120\":{\"h\":\"Grafana简介\",\"t\":[\"Console Template虽然能满足一定的可视化需求，但是也仅仅是对Prometheus的基本能力的补充。同时使用也会有许多问题，首先用户需要学习和了解Go Template模板语言，并且其支持的可视化图表类型也非常有限，最后其管理也有一定的成本。在第1章的“初识Prometheus”中我们已经尝试通过Grafana快速搭建过一个主机监控的Dashboard，在本章中将会带来读者学习如何使用Grafana创建更加精美的可视化报表。\"]},\"121\":{\"h\":\"Grafana基本概念\",\"t\":[\"首先Grafana是一个通用的可视化工具。‘通用’意味着Grafana不仅仅适用于展示Prometheus下的监控数据，也同样适用于一些其他的数据可视化需求。在开始使用Grafana之前，我们首先需要明确一些Grafana下的基本概念，以帮助用户能够快速理解Grafana。\"]},\"122\":{\"h\":\"数据源（Data Source）\",\"t\":[\"\\b对于Grafana而言，Prometheus这类为其提供\\b数据的对象均称为数据源（Data Source）。目前，Grafana官方提供了对：Graphite, InfluxDB, OpenTSDB, Prometheus, Elasticsearch, CloudWatch的支持。对于Grafana管理员而言，只需要将这些对象以数据源的形式添加到Grafana中，Grafana便可以轻松的实现对这些\\b数据的可视化工作。\"]},\"123\":{\"h\":\"仪表盘（Dashboard）\",\"t\":[\"通过数据源定义好可视化的数据来源之后，对于用户而言最重要的事情就是实现数据的可视化。在Grafana中，我们通过Dashboard来组织和管理我们的数据可视化图表：\",\"Grafana Dashboard\",\"如上所示，在一个Dashboard中一个最基本的可视化单元为一个Panel（面板），Panel通过如趋势图，热力图的形式展示可视化数据。 并且在Dashboard中每一个Panel是一个完全独立的部分，通过Panel的**Query Editor（查询编辑器）**我们可以为每一个Panel设置查询的数据源以及数据查询方式，例如，如果以Prometheus作为数据源，那在Query Editor中，我们实际上使用的是PromQL，而Panel则会负责从特定的Prometheus中查询出\\b相应的数据，并且将其可视化。由于每个Panel是完全独立的，因此在一个Dashboard中，往往可能会包含来自多个Data Source的数据。\",\"Grafana通过插件的形式提供了多种\\b\\bPanel的实现，常用的如：Graph Panel，Heatmap Panel，SingleStat Panel以及Table Panel等。用户还可通过插件安装更多类型的Panel面板。\",\"除了Panel以外，在Dashboard页面中，我们还可以定义一个Row（行），来组织和管理一组相关的Panel。\",\"除了Panel, Row这些对象以外，Grafana还允许用户为Dashboard定义Templating variables（模板参数），从而实现可以与用户动态交互的Dashboard页面。同时Grafana通过JSON\\b数据结构管理了整个Dasboard的定义，因此这些Dashboard也是非常方便进行共享的。Grafana还专门为Dashboard提供了一个共享服务：https://grafana.com/dashboards，通过该服务用户可以轻松实现Dashboard的共享，同时我们也能快速的从中找到我们希望的Dashboard实现，并\\b导入到自己的Grafana中。\"]},\"124\":{\"h\":\"组织和用户\",\"t\":[\"作为一个通用可视化工具，Grafana除了提供灵活的可视化定制能力以外，还提供了面向企业的组织级管理能力。在Grafana中Dashboard是属于一个Organization（组织），通过Organization，可以在更大规模上使用Grafana，例如对于一个企业而言，我们可以创建多个Organization，其中**User（用户）**可以属于一个或多个不同的Organization。 并且在不同的Organization下，可以为User赋予不同的权限。 从而可以有效的根据企业的组织架构定义整个管理模型。\"]},\"125\":{\"h\":\"Grafana与数据可视化\",\"t\":[\"在第1章的“初始Prometheus”部分，我们已经带领读者大致了解了Grafana的基本使用方式。对于Grafana而言，Prometheus就是一个用于存储监控样本数据的数据源（Data Source），通过使用PromQL查询特定Prometheus实例中的数据并且在Panel中实现可视化。\",\"接下来，我们将带领读者了解如何通过Panel创建精美的可视化图表。\"]},\"126\":{\"h\":\"认识面板（Panel）\",\"t\":[\"Panel是Grafana中最基本的可视化单元。每一种类型的面板都提供了相应的查询编辑器(Query Editor)，让用户可以从不同的数据源（如Prometheus）中查询出相应的监控数据，并且以可视化的方式展现。\",\"Grafana中所有的面板均以插件的形式进行使用，当前内置了5种类型的面板，分别是：Graph，Singlestat，Heatmap, Dashlist，Table以及Text。\",\"其中像Graph这样的面板允许用户可视化任意多个监控指标以及多条时间序列。而Siglestat则必须要求查询结果为单个样本。Dashlist和Text相对比较特殊，它们与特定的数据源无关。\",\"通过Grafana UI用户可以在一个Dashboard下添加Panel，点击Dashboard右上角的“Add Panel”按钮，如下所示，将会显示当前系统中所有可使用的Panel类型：\",\"添加Panel\",\"选择想要创建的面板类型即可。这里以Graph面板为例，创建Panel之后，并切换到编辑模式，就可以进入Panel的配置页面。对于一个Panel而言，一般来说会包含2个主要的配置选项：General（通用设置）、Metrics（度量指标）。其余的配置则根据Panel类型的不同而不同。\",\"在通用设置中，除了一些Panel的基本信息以外，最主要的能力就是定义动态Panel的能力，这部分内容会在本章的“模板化Dashboard”小结中详细介绍。\",\"对于使用Prometheus作为数据源的用户，最主要的需要了解的就是Metrics设置的使用。在Metric选项中可以定义了Grafana从哪些数据源中查询样本数据。Data Source中指定当前查询的数据源，Grafana会加载当前组织中添加的所有数据源。其中还会包含两个特殊的数据源：Mixed和Grafana。 Mixed用于需要从多个数据源中查询和渲染数据的场景，Grafana则用于需要查询Grafana自身状态时使用。\",\"当选中数据源时，Panel会根据当前数据源类型加载不同的Query Editor界面。这里我们主要介绍Prometheus Query Editor，如下所示，当选中的数据源类型为Prometheus时，会显示如下界面：\",\"Query Editor\",\"Grafana提供了对PromQL的完整支持，在Query Editor中，可以添加任意个Query，并且使用PromQL表达式从Prometheus中查询相应的样本数据。\",\"avg (irate(node_cpu{mode!='idle'}[2m])) without (cpu) \",\"每个PromQL表达式都可能返回多条时间序列。Legend format用于控制如何格式化每条时间序列的图例信息。Grafana支持通过模板的方式，根据时间序列的标签动态生成图例名称，例如：使用{{instance}}表示使用当前时间序列中的instance标签的值作为图例名称：\",\"{{instance}}-{{mode}} \",\"当查询到的样本数据量非常大时可以导致Grafana渲染图标时出现一些性能问题，通过Min Step可以控制Prometheus查询数据时的最小步长（Step），从而减少从Prometheus返回的数据量。\",\"Resolution选项，则可以控制Grafana自身渲染的数据量。例如，如果Resolution的值为1/10，Grafana会将Prometeus返回的10个样本数据合并成一个点。因此Resolution越小可视化的精确性越高，反之，可视化的精度越低。\",\"Format as选项定义如何格式化Prometheus返回的样本数据。这里提供了3个选项：Table,Time Series和Heatmap，分别用于Table面板，Graph面板和Heatmap面板的数据可视化。\",\"除此以外，Query Editor还提供了调试相关的功能，点击Query Inspector可以展开相关的调试面板：\",\"调试面板\",\"在面板中，可以查看当前Prometheus返回的样本数据，用户也可以提供Mock数据\\b渲染图像。\"]},\"127\":{\"h\":\"模板化Dashboard\",\"t\":[\"在前面的小节中介绍了Grafana中4中常用的可视化面板的使用，通过在面板中使用PromQL表达式，Grafana能够方便的将Prometheus返回的数据进行可视化展示。例如，在展示主机CPU使用率时，我们使用了如下表达式：\",\"1 - (avg(irate(node_cpu{mode='idle'}[5m])) without (cpu)) \",\"该表达式会返回当前Prometheus中存储的所有时间序列，每一台主机都会有一条单独的曲线用于体现其CPU使用率的变化情况：\",\"主机CPU使用率\",\"而当用户只想关注其中某些主机时，基于当前我们已经学习到的知识只有两种方式，要么每次手动修改Panel中的PromQL表达式，要么直接为这些主机创建单独的Panel。但是无论如何，这些硬编码方式都会直接导致Dashboard配置的频繁修改。在这一小节中我们将学习使用Dashboard变量的方式解决以上问题。\"]},\"128\":{\"h\":\"变量\",\"t\":[\"在Grafana中用户可以为Dashboard定义一组变量（Variables），变量一般包含一个到多个可选值。如下所示，Grafana通过将变量渲染为一个下拉框选项，从而使用户可以动态的改变变量的值：\",\"Dashboard变量\",\"例如，这里定义了一个名为node的变量，用户可以通过在PromQL表达式或者Panel的标题中通过以下形式使用该变量：\",\"1 - (avg(irate(node_cpu{mode='idle', instance=~\\\"$node\\\"}[5m])) without (cpu)) \",\"变量的值可以支持单选或者多选，当对接Prometheus时，Grafana会自动将$node的值格式化为如“host1|host2|host3”的形式。配合使用PromQL的标签正则匹配“=~”，通过动态改变PromQL从而实现基于标签快速对时间序列进行过滤。\"]},\"129\":{\"h\":\"变量定义\",\"t\":[\"通过Dashboard页面的Settings选项，可以进入Dashboard的配置页面并且选择Variables子菜单:\",\"为Dashboard添加变量\",\"用户需要指定变量的名称，后续用户就可以通过$variable_name的形式引用该变量。Grafana目前支持6种不同的变量类型，而能和Prometheus一起工作的主要包含以下5种类型：\",\"类型\",\"工作方式\",\"Query\",\"允许用户通过Datasource查询表达式的返回值动态生成变量的可选值\",\"Interval\",\"该变量代表时间跨度，通过Interval类型的变量，可以动态改变PromQL区间向量表达式中的时间范围。如rate(node_cpu[2m])\",\"Datasource\",\"允许用户动态切换当前Dashboard的数据源，特别适用于同一个Dashboard展示多个数据源数据的情况\",\"Custom\",\"用户直接通过手动的方式，定义变量的可选值\",\"Constant\",\"常量，在导入Dashboard时，会要求用户设置该常量的值\",\"Label属性用于指定界面中变量的显示名称，Hide属性则用于指定在渲染界面时是否隐藏该变量的下拉框。\"]},\"130\":{\"h\":\"使用变量过滤时间序列\",\"t\":[\"当Prometheus同时采集了多个主机节点的监控样本数据时，用户希望能够手动选择并查看其中特定主机的监控数据。这时我们需要使用Query类型的变量。\",\"新建Query类型的变量\",\"如上所示，这里我们为Dashboard创建了一个名为node的变量，并且指定其类型为Query。Query类型的变量，允许用户指定数据源以及查询表达式，并通过正则\\b匹配（Regex）的方式对查询结果进行处理，从而动态生成变量的可选值。在这里指定了数据源为Prometheus，通过使用node_load1我们得到了两条时间序列：\",\"node_load1{instance=\\\"foo:9100\\\",job=\\\"node\\\"} node_load1{instance=\\\"localhost:9100\\\",job=\\\"node\\\"} \",\"通过指定正则匹配表达式为/.*instance=\\\"([^\\\"]*).*/从而匹配出标签instance的值作为node变量的所有可选项，即：\",\"foo:9100 localhost:9100 \",\"Selection Options选项中可以指定该变量的下拉框是否支持多选，以及是否包含全选（All）选项。\",\"保存变量后，用户可以在Panel的General或者Metrics中通过$node的方式使用该变量，如下所示：\",\"在Metrics中使用变量\",\"这里需要注意的是，如果允许用户多选在PromQL表达式中应该使用标签的正则匹配模式，因为Grafana会自动将多个选项格式化为如“foo:9100|localhost:9100”的形式。\",\"使用Query类型的变量能够根据允许用户能够根据时间序列的特征维度对数据进行过滤。在定义Query类型变量时，除了使用PromQL查询时间序列以过滤标签的方式以外，Grafana还提供了几个有用的函数：\",\"函数\",\"作用\",\"label_values(label)\",\"返回Prometheus所有监控指标中，标签名为label的所有可选值\",\"label_values(metric, label)\",\"返回Prometheus所有监控指标metric中，标签名为label的所有可选值\",\"metrics(metric)\",\"返回所有指标名称满足metric定义正则表达式的\\b指标名称\",\"query_result(query)\",\"返回prometheus查询语句的查询结果\",\"例如，当需要监控Prometheus所有采集任务的状态时，可以使用如下方式，获取当前所有采集任务的名称：\",\"label_values(up, job) \",\"例如，有时候我们想要动态修改变量查询结果。比如某一个节点绑定了多个ip，一个用于内网访问，一个用于外网访问，此时prometheus采集到的指标是内网的ip，但我们需要的是外网ip。这里我们想要能在Grafana中动态改变标签值，进行ip段的替换，而避免从prometheus或exporter中修改采集指标。\",\"这时需要使用grafana的query_result函数\",\"# 将10.10.15.xxx段的ip地址替换为10.20.15.xxx段 注：替换端口同理 query_result(label_replace(kube_pod_info{pod=~\\\"$pod\\\"}, \\\"node\\\", \\\"10.20.15.$1\\\", \\\"node\\\", \\\"10.10.15.(.*)\\\")) \",\"# 通过正则从返回结果中匹配出所需要的ip地址 regex：/.*node=\\\"(.*?)\\\".*/ \",\"在grafana中配置如图： \"]},\"131\":{\"h\":\"使用变量动态创建Panel和Row\",\"t\":[\"当在一个Panel中展示多条时间序列数据时，通过使用变量可以轻松实现对时间序列的过滤，提高用户交互性。除此以外，我们还可以使用变量自动生成Panel或者Row。 如下所示，当需要可视化当前系统中所有采集任务的监控任务运行状态时，由于Prometheus的采集任务配置可能随时发生变更，通过硬编码的形式实现，会导致Dashboard配置的频繁变更：\",\"Prometheus采集任务状态\",\"如下所示，这里为Dashboard定义了一遍名为job的变量：\",\"使用变量获取当前所有可选任务\",\"通过使用label_values函数，获取到当前Prometheus监控指标up中所有可选的job\\b标签的值：\",\"label_values(up, job) \",\"如果变量启用了Multi-value或者Include All Option选项的变量，那么在Panel的General选项的Repeat中可以选择自动迭代的变量，这里使用了Singlestat展示所有监控采集任务的状态：\",\"General中的Repeat选项\",\"Repeat选项设置完成后，Grafana会根据当前用户的选择，自动创建一个到多个Panel实例。 为了能够使Singlestat Panel能够展示正确的数据，如下所示，在Prometheus中，我们依然使用了job反应的是当前迭代的值：\",\"在Metric中使用变量\",\"而如果还希望能够自动生成Row，只需要在Row的设置中，选择需要Repeat的变量即可：\",\"Repeat Row\"]},\"132\":{\"h\":\"使用Console Template\",\"t\":[\"在第1章以及第2章的内容中，读者已经对Prometheus已经有了一个相对完成的认识，并且我们已经学习了如何通过PromQL对时间序列数据进行查询和分析，并且通过Prometheus中的Graph面板查询数据形成图表。但是缺点也很明显，这些查询结果都是临时的，无法持久化的，更别说我们想实时关注某些特定监控指标的变化趋势。\",\"为了简化这些问题Prometheus内置了一个简单的解决方案Console Template,它允许用户通过Go模板语言创建任意的控制台界面，并且通过Prometheus Server对外提供访问路径。\"]},\"133\":{\"h\":\"快速开始\",\"t\":[\"首先我们先从一个小例子开始，创建我们的第一个Console Template页面。与Console Template有关的两个启动参数为--web.console.libraries和--web.console.templates,其分别指定页面组件以及页面的存储路径。默认情况下其分别指向Prometheus当前安装路径的console_libraries和consoles目录。\",\"Prometheus在console_libraries目录中已经内置了一些基本的界面组件，用户可以直接使用。\",\"在consoles目录下创建index.html文件后，刷新Prometheus界面可以看到在顶部菜单中多了一个Consoles菜单项，如下所示。该选项默认指向consoles/index.html文件：\",\"Consoles菜单\",\"当然，这个时候点击该菜单，我们会看到一个空白页。因为目前index.html文件中还未填充任何内容：\"]},\"134\":{\"h\":\"定义页面菜单\",\"t\":[\"首先，我们先直接使用console_libraries中定义的head组件，并加入到index.html文件中：\",\"{{template \\\"head\\\" .}} \",\"此时，如果我们刷新浏览器可以看到以下内容：\",\"默认的Head组件\",\"head组件的定义，读者可以通过关键字define \\\"head\\\"在console_libraries目录中查找。默认其应该是定义在prom.lib文件中：\",\"{{ define \\\"head\\\" }} <html> <head> {{ template \\\"prom_console_head\\\" }} </head> <body> {{ template \\\"navbar\\\" . }} {{ end }} \",\"如果需要定制化菜单的内容，那一样的读者只需要找到navbar组件的定义即可。当然用户也可以创建自己的组件。 例如，如果我们希望Console Template页面的菜单与Prometheus UI一致，只需要修改navbar组件的定义即可，找到menu.lib并修改navbar组件:\",\"{{ define \\\"navbar\\\" }} <nav class=\\\"navbar navbar-inverse navbar-static-top\\\"> <div class=\\\"container-fluid\\\"> <!-- Brand and toggle get grouped for better mobile display --> <div class=\\\"navbar-header\\\"> <button type=\\\"button\\\" class=\\\"navbar-toggle collapsed\\\" data-toggle=\\\"collapse\\\" data-target=\\\"#bs-example-navbar-collapse-1\\\"> <span class=\\\"sr-only\\\">Toggle navigation</span> <span class=\\\"icon-bar\\\"></span> <span class=\\\"icon-bar\\\"></span> <span class=\\\"icon-bar\\\"></span> </button> <a class=\\\"navbar-brand\\\" href=\\\"{{ pathPrefix }}/\\\">Prometheus</a> </div> <div class=\\\"collapse navbar-collapse\\\" id=\\\"bs-example-navbar-collapse-1\\\"> <ul class=\\\"nav navbar-nav\\\"> <li><a href=\\\"{{ pathPrefix }}/alerts\\\">Alerts</a></li> <li><a href=\\\"{{ pathPrefix }}/graph\\\">Graph</a></li> </div> </ul> </div> </nav> {{ end }} \",\"如果不需要侧边菜单栏，直接在head组件中移除{{ template \\\"menu\\\" . }}部分即可，修改后刷新页面，如下所示：\",\"自定义菜单\",\"无论是.lib文件还是.html文件均使用了Go Template的语言，感兴趣的读者可以自行在Go语言官网了解更多内容https://golang.org/pkg/text/template/\"]},\"135\":{\"h\":\"定义图表\",\"t\":[\"在Console Template中我们可以在页面中使用内置的PromConsole.Graph()函数，该函数通过head加载相应的js源码，在该函数中，通过指定特定的DOM节点以及相应的PromQL表达式，即可在特定区域图形化显示相应的图表内容，如下所示：\",\"<h1>Prometheus HTTP Request Rate</h1> <h3>Queries</h3> <div id=\\\"queryGraph\\\"></div> <script> new PromConsole.Graph({ node: document.querySelector(\\\"#queryGraph\\\"), expr: \\\"sum(rate(prometheus_http_request_duration_seconds_count{job='prometheus'}[5m]))\\\", name: \\\"Queries\\\", yAxisFormatter: PromConsole.NumberFormatter.humanizeNoSmallPrefix, yHoverFormatter: PromConsole.NumberFormatter.humanizeNoSmallPrefix, yUnits: \\\"/s\\\", yTitle: \\\"Queries\\\" }) </script> \",\"这里创建了一个id为queryGraph的div节点，通过在页面中使用PromConsole.Graph函数，我们可以绘制出表达式sum(rate(prometheus_http_request_duration_seconds_count{job='prometheus'}[5m]))的可视化图表如下所示：\",\"除了最基本的node以及expr参数以外，该函数还支持的完整参数如下：\",\"参数名称\",\"作用\",\"expr\",\"Required. Expression to graph. Can be a list.\",\"node\",\"Required. DOM node to render into.\",\"duration\",\"Optional. Duration of the graph. Defaults to 1 hour.\",\"endTime\",\"Optional. Unixtime the graph ends at. Defaults to now.\",\"width\",\"Optional. Width of the graph, excluding titles. Defaults to auto-detection.\",\"height\",\"Optional. Height of the graph, excluding titles and legends. Defaults to 200 pixels.\",\"min\",\"Optional. Minimum x-axis value. Defaults to lowest data value.\",\"max\",\"Optional. Maximum y-axis value. Defaults to highest data value.\",\"renderer\",\"Optional. Type of graph. Options are line and area (stacked graph). Defaults to line.\",\"name\",\"Optional. Title of plots in legend and hover detail. If passed a string, [[ label ]] will be substituted with the label value. If passed a function, it will be passed a map of labels and should return the name as a string. Can be a list.\",\"xTitle\",\"Optional. Title of the x-axis. Defaults to Time.\",\"yUnits\",\"Optional. Units of the y-axis. Defaults to empty.\",\"yTitle\",\"Optional. Title of the y-axis. Defaults to empty.\",\"yAxisFormatter\",\"Optional. Number formatter for the y-axis. Defaults to PromConsole.NumberFormatter.humanize.\",\"yHoverFormatter\",\"Optional. Number formatter for the hover detail. Defaults to PromConsole.NumberFormatter.humanizeExact.\",\"colorScheme\",\"Optional. Color scheme to be used by the plots. Can be either a list of hex color codes or one of the color scheme names supported by Rickshaw. Defaults to 'colorwheel'.\",\"需要注意的是，如果参数expr和name均是list类型，其必须是一一对应的。\",\"除了直接使用PromConsole.Graph函数显示可视化图表以外，在Console Template中还可以使用模板组件prom_query_drilldown定义一个连接直接跳转到Graph页面，并显示相应表达式的查询结果， 如下所示：\",\"<h3>Links</h3> {{ template \\\"prom_query_drilldown\\\" (args \\\"prometheus_http_response_size_bytes_bucket\\\") }} \",\"除了以上部分以外，我们也可以和原生Prometheus UI一样定义一个时间轴控制器，方便用户按需查询数据：\",\"加入这个时间轴控制器的方式也很简单，直接引用以下模板即可：\",\"{{ template \\\"prom_graph_timecontrol\\\" . }} \"]},\"136\":{\"h\":\"变化趋势：Graph面板\",\"t\":[\"Graph面板是最常用的一种可视化面板，其通过折线图或者柱状图的形式显示监控样本随时间而变化的趋势。Graph面板天生适用于Prometheus中Gauge和Counter类型监控指标的监控数据可视化。例如，当需要查看主机CPU、内存使用率的随时间变化的情况时，可以使用Graph面板。同时，Graph还可以非常方便的支持多个数据之间的对比。\",\"Graph面板\"]},\"137\":{\"h\":\"Graph面板与Prometheus\",\"t\":[\"Graph面板通过折线图或者柱状图的形式，能够展示监控样本数据在一段时间内的变化趋势，因此其天生适合Prometheus中的Counter和Gauge类型的监控指标的可视化，对于Histogram类型的指标也可以支持，不过可视化效果不如Heatmap Panel来的直观。\"]},\"138\":{\"h\":\"使用Graph面板可视化Counter/Gauge\",\"t\":[\"以主机为例，\\bCPU使用率的变化趋势天然适用于使用Grapn面板来进行展示：\",\"Prometheus Counter可视化\",\"在Metrics选项中，我们使用以下PromQL定义\\b如何从Prometheus中读取数据：\",\"1 - (avg(irate(node_cpu{mode='idle'}[5m])) without (cpu)) \",\"如下所示：\",\"Metrics选项\",\"根据当前Prometheus的数据采集情况，该PromQL会返回多条时间序列（在示例中会返回3条）。Graph面板会从时间序列中获取样本数据，并绘制到图表中。 为了让折线图有更好的可读性，我们可以通过定义Legend format为{{ instance }}控制每条线的图例名称：\",\"使用Legend format模板化图例\",\"由于当前使用的PromQL的数据范围为0~1表示CPU的使用率，为了能够更有效的表达出度量单位的概念，我们需要对Graph图表的坐标轴显示进行优化。如下所示，在Axes选项中可以控制图标的X轴和Y轴相关的行为：\",\"Axes选项\",\"默认情况下，Y轴会直接显示当前样本的值，通过Left Y的Unit可以让Graph面板自动格式化样本值。当前表达式返回的当前主机CPU使用率的小数表示，因此，这里选择单位为percent(0.0.-1.0)。除了百分比以外，Graph面板支持如日期、货币、重量、面积等各种类型单位的自动换算，用户根据自己当前样本的值含义选择即可。\",\"除了在Metrics设置图例的显示名称以外，在Graph面板的Legend选项可以进一步控制图例的显示方式，如下所示：\",\"Legend选项\",\"Options中可以设置图例的显示方式以及展示位置，Values中可以设置是否显示当前时间序列的最小值，平均值等。 Decimals用于配置这些值显示时保留的小数位，如下所示：\",\"Legend控制图例的显示示例\",\"除了以上设置以外，我们可能还需要对图表进行一些更高级的定制化，以便能够更直观的从可视化图表中获取信息。在Graph面板中Display选项可以帮助我们实现更多的可视化定制的能力，其中包含三个部分：Draw options、Series overrides和Thresholds。\",\"Display选项\",\"Draw Options用于设置当前图标的展示形式、样式以及交互提示行为。其中，Draw Modes用于控制图形展示形式：Bar（柱状）、Lines（线条）、Points（点），用户可以根据自己的需求同时启用多种模式。Mode Options则设置各个展示模式下的相关样式。Hover tooltip用于控制当鼠标移动到图形时，显示提示框中的内容。\",\"如果希望当前图表中的时间序列以不同的形式展示，则可以通过Series overrides控制，顾名思义，可以为指定的时间序列指定自定义的Draw Options配置，从而让其以不同的样式展示。例如：\",\"Series overrides\",\"这里定义了一条自定义规则，其匹配图例名称满足**/localhost/**的时间序列，并定义其以点的形式显示在图表中，修改后的图标显示效果如下：\",\"Series overrides效果\",\"Display选项中的最后一个是Thresholds，Threshold主要用于一些自定义一些样本的阈值，例如，定义一个Threshold规则，如果CPU超过50%的区域显示为warning状态，可以添加如下配置：\",\"Threshold设置\",\"Graph面板则会在\\b图表中显示一条阈值，并且将所有高于该阈值的区域显示为warining状态，通过可视化的方式直观的在图表中显示一些可能出现异常的区域。\",\"需要注意的是，如果用户为该图表自定义了Alert（告警）配置，Thresholds将会被警用，并且根据Alert中定义的Threshold在图形中显示阈值内容。关于Alert的使用会在后续部分，详细介绍。\"]},\"139\":{\"h\":\"使用Graph面板可视化Histogram\",\"t\":[\"以Prometheus自身的监控指标prometheus_tsdb_compaction_duration为例，该监控指标记录了Prometheus进行数据压缩任务的运行耗时的分布统计情况。如下所示，是Prometheus返回的样本数据：\",\"# HELP prometheus_tsdb_compaction_duration Duration of compaction runs. # TYPE prometheus_tsdb_compaction_duration histogram prometheus_tsdb_compaction_duration_bucket{le=\\\"1\\\"} 2 prometheus_tsdb_compaction_duration_bucket{le=\\\"2\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"4\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"8\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"16\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"32\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"64\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"128\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"256\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"512\\\"} 36 prometheus_tsdb_compaction_duration_bucket{le=\\\"+Inf\\\"} 36 prometheus_tsdb_compaction_duration_sum 51.31017077500001 prometheus_tsdb_compaction_duration_count 36 \",\"在第2章的“Metric类型”小节中，我们已经介绍过Histogram的指标，Histogram用于统计样本数据的分布情况，其中标签le定义了分布桶Bucket的边界，如上所示，表示当前Prometheus共进行了36次数据压缩，总耗时为51.31017077500001ms。其中任务耗时在01ms区间内的为2次、在02ms区间范围内为36次，以此类推。\",\"如下所示，如果需要在Graph中显示Histogram类型的监控指标，需要在Query Editor中定义查询结果的Format as为Heatmap。通过该设置Grafana会自动计算Histogram中的Bucket边界范围以及该范围内的值：\",\"Metrics设置\",\"Graph面板重新计算了Bucket边界，如下所示，在01ms范围内的任务次数为2，在12ms范围内的运行任务次数为34。通过图形的面积，可以反映出各个Bucket下的大致数据分布情况：\",\"Histogram数据可视化\",\"不过通过Graph面板展示Histogram也并不太直观，其并不能直接反映出Bucket的\\b大小以及分布情况，因此在Grafana V5版本以后更推荐使用Heatmap面板的方式展示Histogram样本数据。关于Heatmap面板的使用将会在接下来的部分介绍。\"]},\"140\":{\"h\":\"分布统计：Heatmap面板\",\"t\":[\"Heatmap是Grafana v4.3版本以后新添加的可视化面板，通过热图可以直观的查看样本的分布情况。在Grafana v5.1版本中Heatmap完善了对Prometheus的支持。这部分，将介绍如何使用Heatmap Panel实现对Prometheus监控指标的可视化。\"]},\"141\":{\"h\":\"使用Heatmap可视化Histogram样本分布情况\",\"t\":[\"在上一小节中，我们尝试了使用Graph面板来可视化Histogram类型的监控指标prometheus_tsdb_compaction_duration_bucket。虽然能展示各个Bucket区间内的样本分布，但是无论是以线图还是柱状图的形式展示，都不够直观。对于Histogram类型的监控指标来说，更好的选择是采用Heatmap Panel，如下所示，Heatmap Panel可以自动对Histogram类型的监控指标分布情况进行计划，获取到每个区间范围内的样本个数，并且以\\b颜色的深浅来表示当前区间内样本个数的大小。而图形的高度，则反映出当前时间点，样本分布的离散程度。\",\"Heatmap示例\",\"在Grafana中使用Heatmap Panel也非常简单，在Dashboard页面右上角菜单中点击“add panel”按钮，并选择Heatmap Panel即可。\",\"如下所示，Heapmap Panel的编辑页面中，主要包含5类配置选项，分别是：General、Metrics、Axes、Display、Time range。\",\"Heapmap Panel编辑页面\",\"其中大部分的配置选项与Graph面板基本保持一致，这里就不重复介绍了。\",\"当使用Heatmap可视化Histogram类型的监控指标时，\\b需要设置Format as选项为Heatmap。当使用Heatmap格式化数据后，Grafana会自动根据样本的\\b中的le标签，计算各个Bucket桶内的分布，并且按照Bucket对数据进行重新排序。Legend format模板则将会控制Y轴中的显示内容。如下所示：\",\"Mteircs设置\",\"默认情况下，Heatmap Panel会自行对PromQL查询出的数据进行分布情况统计，而在Prometheus中Histogram类型的监控指标其实是已经自带了分布的Bucket信息的，因此为了直接使用这些Bucket信息，我们需要在Axes选项中定义数据的Date format需要定义为Time series buckets。该选项表示Heatmap Panel不需要自身对数据\\b的分布情况进行计算，直接使用时间序列中返回的Bucket即可。如下所示：\",\"Axes设置\\b\",\"通过以上设置，即可实现对Histogram类型监控指标的可视化。\"]},\"142\":{\"h\":\"使用Heatmap可视化其它类型样本分布情况\",\"t\":[\"对于非Histogram类型，由于其监控样本中并不包含Bucket相关信息，因此在Metrics选项中需要定义Format as为Time series，如下所示：\",\"Metrics设置\",\"并且通过\\b\\bAxes选项\\b中选择Data format方式为Time series。设置该选项后Heatmap Panel会要求用户提供Bucket分布范围的设置，如下所示：\",\"Axes\\b设置\\b\",\"在Y轴（Y Axis）中需要通过Scale定义Bucket桶的分布范围，\\b默认的Bucket范围支持包括：liner（线性分布）、log(base 10)（10的对数）、log(base 32)（32的对数）、log(base 1024)（1024的对数）等。\",\"例如，\\b上图中设置的Scale为log(base 2)，那么在Bucket范围将2的对数的形式进行分布，即[1,2,4,8,....]，如下所示：\",\"Bucket分布情况\",\"通过以上设置，Heatmap会\\b自动根据用户定义的Bucket范围对Prometheus中查询到的样本数据进行分布统计。\"]},\"143\":{\"h\":\"当前状态：SingleStat面板\",\"t\":[\"SingleStat Panel侧重于展示系统的当前状态而非变化趋势。如下所示，在以下场景中特别适用于使用SingleStat：\",\"当前系统中所有服务的运行状态；\",\"当前基础设施资源的使用量；\",\"当前系统中某些事件发生的次数或者资源数量等。\",\"如下所示，是使用SingleStat进行数据可视化的显示效果：\",\"SingleStat Panel示例\"]},\"144\":{\"h\":\"使用SingleStat Panel\",\"t\":[\"从Dashboardc创建Singlestat Panel，并进入编辑页面， 如下所示：\",\"SingleStat 编辑页面\",\"对于SingleStat Panel而言，其只能处理一条时间序列，否则页面中会提示“Multiple Series Error”错误信息。这里使用如下PromQL查询当前主机负载：\",\"node_load1{instance=\\\"localhost:9100\\\"} \",\"默认情况下，当前面板中会显示当前时间序列中所有样本的平均值，而实际情况下，我们\\b需要显示的是当前主机当前的负载情况，因此需要通过SingleStat Panel的Options选项控制当前面板的显示模式：\",\"SingleStat Option选项\",\"如上所示，通过Value配置项组可以控制当前面板中显示的值，以及字体大小等。对于主机负载而言，我们希望能够显示当前的最新值，因此修改Stat为Current即可。\",\"如果希望面板能够根据不同的值显示不同的颜色的话，则可以定义Thresholds与Colors的映射\\b关系，例如，定义Thresholds的分割区间值为“0,1”，则当Value的值落到不同的范围内时，将显示不同的颜色。\",\"如果希望能够显示当前时间序列的样本值变化情况，则可以启用Spark lines配置。启用之后，Singlestat面板中除了会显示当前的最新样本值以外，也会同时将时间序列中的数据以趋势图的形式进行展示。\",\"除了通过数字大小反应当前状态以外，在某些场景下我们可能\\b\\b更关心的是\\b这些数字表示的意义。例如，在Prometheus监控服务的健康状态时，在样本数据中会通过0表示不健康，1表示健康。 但是如果直接将0或1显示在面板中，那么可视化效果将缺乏一定的可读性。\",\"为了提升数字的可读性，可以在Singlestat Panel中可以通过Value Mappings定义值的映射关系。Siglesta支持值映射（value to text）和区间映射（range to text）两种方式。 如下所示：\",\"Singlestat value mappings配置\",\"当面板中Value的值在0~0.99范围内则显示为Health，否则显示为Unhealth。这种模式特别适合于展示服务的健康状态。 当然你也可以将Value映射为任意的字符，甚至是直接使用Emoji(http://www.iemoji.com/)表情：\",\"在Singlestat中使用Emoji表情字符\"]},\"145\":{\"h\":\"第6章 集群与高可用\",\"t\":[\"Prometheus内置了一个基于本地存储的时间序列数据库。在Prometheus设计上，使用本地存储可以降低Prometheus部署和管理的复杂度，同时减少高可用（HA）带来的复杂性。 在默认情况下，用户只需要部署多套Prometheus，采集相同的Targets即可实现基本的HA。同时由于Promethus高效的数据处理能力，单个Prometheus Server基本上能够应对大部分用户监控规模的需求。\",\"当然本地存储也带来了一些不好的地方，首先就是数据持久化的问题，特别是在像Kubernetes这样的动态集群环境下，如果Prometheus的实例被重新调度，那所有历史监控数据都会丢失。 其次本地存储也意味着Prometheus不适合保存大量历史数据(一般Prometheus推荐只保留几周或者几个月的数据)。最后本地存储也导致Prometheus无法进行弹性扩展。为了适应这方面的需求，Prometheus提供了remote_write和remote_read的特性，支持将数据存储到远端和从远端读取数据。通过将监控与数据分离，Prometheus能够更好地进行弹性扩展。\",\"除了本地存储方面的问题，由于Prometheus基于Pull模型，当有大量的Target需要采样本时，单一Prometheus实例在数据抓取时可能会出现一些性能问题，联邦集群的特性可以让Prometheus将样本采集任务划分到不同的Prometheus实例中，并且通过一个统一的中心节点进行聚合，从而可以使Prometheuse可以根据规模进行扩展。\",\"除了讨论Prometheus自身的高可用，Alertmanager作为Prometheus体系中的告警处理中心，本章的最后部分会讨论如何实现Alertmanager的高可用部署。\",\"本章的主要内容：\",\"Prometheus本地存储机制\",\"Prometheus的远程存储机制\",\"Prometheus联邦集群\",\"Prometheus高可用部署架构\",\"Alertmanager高可用部署架构\"]},\"146\":{\"h\":\"小结\",\"t\":[\"Prometheus的简单性贯穿于整个Prometheus的使用过程中，无论是单机部署还是集群化部署，简单性一致是Prometheus设计的基本原则。这本章中，我们系统学习了如果实现Prometheus下各个中间的高可用部署方式，同时给出了集中常用的高可用方案，读者可以根据自己的实际需求来选择如何部署自己的Promethues集群。\"]},\"147\":{\"h\":\"Alertmanager高可用\",\"t\":[\"在上一小节中我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。\",\"Alertmanager成为单点\",\"为了提升Prometheus的服务可用性，通常用户会部署两个或者两个以上的Promthus Server，它们具有完全相同的配置包括Job配置，以及告警配置等。当某一个Prometheus Server发生故障后可以确保Prometheus持续可用。\",\"同时基于Alertmanager的告警分组机制即使不同的Prometheus Sever分别发送相同的告警给Alertmanager，Alertmanager也可以自动将这些告警合并为一个通知向receiver发送。\",\"Alertmanager特性\",\"但不幸的是，虽然Alertmanager能够同时处理多个相同的Prometheus Server所产生的告警。但是由于单个Alertmanager的存在，当前的部署结构存在明显的单点故障风险，当Alertmanager单点失效后，告警的后续所有业务全部失效。\",\"如下所示，最直接的方式，就是尝试部署多套Alertmanager。但是由于Alertmanager之间不存在并不了解彼此的存在，因此则会出现告警通知被不同的Alertmanager重复发送多次的问题。\",\"为了解决这一问题，如下所示。Alertmanager引入了Gossip机制。Gossip机制为多个Alertmanager之间提供了信息传递的机制。确保及时在多个Alertmanager分别接收到相同告警信息的情况下，也只有一个告警通知被发送给Receiver。\",\"Alertmanager Gossip\"]},\"148\":{\"h\":\"Gossip协议\",\"t\":[\"Gossip是分布式系统中被广泛使用的协议，用于实现分布式节点之间的信息交换和状态同步。Gossip协议同步状态类似于流言或者病毒的传播，如下所示：\",\"Gossip分布式协议\",\"一般来说Gossip有两种实现方式分别为Push-based和Pull-based。在Push-based当集群中某一节点A完成一个工作后，随机的从其它节点B并向其发送相应的消息，节点B接收到消息后在重复完成相同的工作，直到传播到集群中的所有节点。而Pull-based的实现中节点A会随机的向节点B发起询问是否有新的状态需要同步，如果有则返回。\",\"在简单了解了Gossip协议之后，我们来看Alertmanager是如何基于Gossip协议实现集群高可用的。如下所示，当Alertmanager接收到来自Prometheus的告警消息后，会按照以下流程对告警进行处理：\",\"通知流水线\",\"在第一个阶段Silence中，Alertmanager会判断当前通知是否匹配到任何的静默规则，如果没有则进入下一个阶段，否则中断流水线不发送通知。\",\"在第二个阶段Wait中，Alertmanager会根据当前Alertmanager在集群中所在的顺序(index)等待index * 5s的时间。\",\"当前Alertmanager等待阶段结束后，Dedup阶段则会判断当前Alertmanager数据库中该通知是否已经发送，如果已经发送则中断流水线，不发送告警，否则进入下一阶段Send对外发送告警通知。\",\"告警发送完成后该Alertmanager进入最后一个阶段Gossip，Gossip会通知其他Alertmanager实例当前告警已经发送。其他实例接收到Gossip消息后，则会在自己的数据库中保存该通知已发送的记录。\",\"因此如下所示，Gossip机制的关键在于两点：\",\"Gossip机制\",\"Silence设置同步：Alertmanager启动阶段基于Pull-based从集群其它节点同步Silence状态，当有新的Silence产生时使用Push-based方式在集群中传播Gossip信息。\",\"通知发送状态同步：告警通知发送完成后，基于Push-based同步告警发送状态。Wait阶段可以确保集群状态一致。\",\"Alertmanager基于Gossip实现的集群机制虽然不能保证所有实例上的数据时刻保持一致，但是实现了CAP理论中的AP系统，即可用性和分区容错性。同时对于Prometheus Server而言保持了配置了简单性，Prometheus Server之间不需要任何的状态同步。\"]},\"149\":{\"h\":\"搭建本地集群环境\",\"t\":[\"为了能够让Alertmanager节点之间进行通讯，需要在Alertmanager启动时设置相应的参数。其中主要的参数包括：\",\"--cluster.listen-address string: 当前实例集群服务监听地址\",\"--cluster.peer value: 初始化时关联的其它实例的集群服务地址\",\"例如：\",\"定义Alertmanager实例a1，其中Alertmanager的服务运行在9093端口，集群服务地址运行在8001端口。\",\"alertmanager --web.listen-address=\\\":9093\\\" --cluster.listen-address=\\\"127.0.0.1:8001\\\" --config.file=/etc/prometheus/alertmanager.yml --storage.path=/data/alertmanager/ \",\"定义Alertmanager实例a2，其中主服务运行在9094端口，集群服务运行在8002端口。为了将a1，a2组成集群。 a2启动时需要定义--cluster.peer参数并且指向a1实例的集群服务地址:8001。\",\"alertmanager --web.listen-address=\\\":9094\\\" --cluster.listen-address=\\\"127.0.0.1:8002\\\" --cluster.peer=127.0.0.1:8001 --config.file=/etc/prometheus/alertmanager.yml --storage.path=/data/alertmanager2/ \",\"为了能够在本地模拟集群环境，这里使用了一个轻量级的多线程管理工具goreman。使用以下命令可以在本地安装goreman命令行工具。\",\"go get github.com/mattn/goreman \"]},\"150\":{\"h\":\"创建Alertmanager集群\",\"t\":[\"创建Alertmanager配置文件/etc/prometheus/alertmanager-ha.yml, 为了验证Alertmanager的集群行为，这里在本地启动一个webhook服务用于打印Alertmanager发送的告警通知信息。\",\"route: receiver: 'default-receiver' receivers: - name: default-receiver webhook_configs: - url: 'http://127.0.0.1:5001/' \",\"本地webhook服务可以直接从Github获取。\",\"# 获取alertmanager提供的webhook示例，如果该目录下定义了main函数，go get会自动将其编译成可执行文件 go get github.com/prometheus/alertmanager/examples/webhook # 设置环境变量指向GOPATH的bin目录 export PATH=$GOPATH/bin:$PATH # 启动服务 webhook \",\"示例结构如下所示：\",\"Alertmanager HA部署结构\",\"创建alertmanager.procfile文件，并且定义了三个Alertmanager节点（a1，a2，a3）以及用于接收告警通知的webhook服务:\",\"a1: alertmanager --web.listen-address=\\\":9093\\\" --cluster.listen-address=\\\"127.0.0.1:8001\\\" --config.file=/etc/prometheus/alertmanager-ha.yml --storage.path=/data/alertmanager/ --log.level=debug a2: alertmanager --web.listen-address=\\\":9094\\\" --cluster.listen-address=\\\"127.0.0.1:8002\\\" --cluster.peer=127.0.0.1:8001 --config.file=/etc/prometheus/alertmanager-ha.yml --storage.path=/data/alertmanager2/ --log.level=debug a3: alertmanager --web.listen-address=\\\":9095\\\" --cluster.listen-address=\\\"127.0.0.1:8003\\\" --cluster.peer=127.0.0.1:8001 --config.file=/etc/prometheus/alertmanager-ha.yml --storage.path=/data/alertmanager2/ --log.level=debug webhook: webhook \",\"在Procfile文件所在目录，执行goreman start命令，启动所有进程:\",\"$ goreman -f alertmanager.procfile start 10:27:57 a1 | level=debug ts=2018-03-12T02:27:57.399166371Z caller=cluster.go:125 component=cluster msg=\\\"joined cluster\\\" peers=0 10:27:57 a3 | level=info ts=2018-03-12T02:27:57.40004678Z caller=main.go:346 msg=Listening address=:9095 10:27:57 a1 | level=info ts=2018-03-12T02:27:57.400212246Z caller=main.go:271 msg=\\\"Loading configuration file\\\" file=/etc/prometheus/alertmanager.yml 10:27:57 a1 | level=info ts=2018-03-12T02:27:57.405638714Z caller=main.go:346 msg=Listening address=:9093 \",\"启动完成后访问任意Alertmanager节点http://localhost:9093/#/status,可以查看当前Alertmanager集群的状态。\",\"Alertmanager集群状态\",\"当集群中的Alertmanager节点不在一台主机时，通常需要使用--cluster.advertise-address参数指定当前节点所在网络地址。\",\"注意：由于goreman不保证进程之间的启动顺序，如果集群状态未达到预期，可以使用goreman -f alertmanager.procfile run restart a2重启a2，a3服务。\",\"当Alertmanager集群启动完成后，可以使用send-alerts.sh脚本对集群进行简单测试，这里利用curl分别向3个Alertmanager实例发送告警信息。\",\"alerts1='[ { \\\"labels\\\": { \\\"alertname\\\": \\\"DiskRunningFull\\\", \\\"dev\\\": \\\"sda1\\\", \\\"instance\\\": \\\"example1\\\" }, \\\"annotations\\\": { \\\"info\\\": \\\"The disk sda1 is running full\\\", \\\"summary\\\": \\\"please check the instance example1\\\" } }, { \\\"labels\\\": { \\\"alertname\\\": \\\"DiskRunningFull\\\", \\\"dev\\\": \\\"sdb2\\\", \\\"instance\\\": \\\"example2\\\" }, \\\"annotations\\\": { \\\"info\\\": \\\"The disk sdb2 is running full\\\", \\\"summary\\\": \\\"please check the instance example2\\\" } }, { \\\"labels\\\": { \\\"alertname\\\": \\\"DiskRunningFull\\\", \\\"dev\\\": \\\"sda1\\\", \\\"instance\\\": \\\"example3\\\", \\\"severity\\\": \\\"critical\\\" } }, { \\\"labels\\\": { \\\"alertname\\\": \\\"DiskRunningFull\\\", \\\"dev\\\": \\\"sda1\\\", \\\"instance\\\": \\\"example3\\\", \\\"severity\\\": \\\"warning\\\" } } ]' curl -XPOST -d\\\"$alerts1\\\" http://localhost:9093/api/v1/alerts curl -XPOST -d\\\"$alerts1\\\" http://localhost:9094/api/v1/alerts curl -XPOST -d\\\"$alerts1\\\" http://localhost:9095/api/v1/alerts \",\"运行send-alerts.sh后，查看alertmanager日志，可以看到以下输出，3个Alertmanager实例分别接收到模拟的告警信息：\",\"10:43:36 a1 | level=debug ts=2018-03-12T02:43:36.853370185Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=DiskRunningFull[6543bc1][active] 10:43:36 a2 | level=debug ts=2018-03-12T02:43:36.871180749Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=DiskRunningFull[8320f0a][active] 10:43:36 a3 | level=debug ts=2018-03-12T02:43:36.894923811Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=DiskRunningFull[8320f0a][active] \",\"查看webhook日志只接收到一个告警通知：\",\"10:44:06 webhook | 2018/03/12 10:44:06 { 10:44:06 webhook | > \\\"receiver\\\": \\\"default-receiver\\\", 10:44:06 webhook | > \\\"status\\\": \\\"firing\\\", 10:44:06 webhook | > \\\"alerts\\\": [ 10:44:06 webhook | > { 10:44:06 webhook | > \\\"status\\\": \\\"firing\\\", 10:44:06 webhook | > \\\"labels\\\": { 10:44:06 webhook | > \\\"alertname\\\": \\\"DiskRunningFull\\\", \"]},\"151\":{\"h\":\"多实例Prometheus与Alertmanager集群\",\"t\":[\"由于Gossip机制的实现，在Prometheus和Alertmanager实例之间不要使用任何的负载均衡，需要确保Prometheus将告警发送到所有的Alertmanager实例中：\",\"alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:9093 - 127.0.0.1:9094 - 127.0.0.1:9095 \",\"创建Prometheus集群配置文件/etc/prometheus/prometheus-ha.yml，完整内容如下：\",\"global: scrape_interval: 15s scrape_timeout: 10s evaluation_interval: 15s rule_files: - /etc/prometheus/rules/*.rules alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:9093 - 127.0.0.1:9094 - 127.0.0.1:9095 scrape_configs: - job_name: prometheus static_configs: - targets: - localhost:9090 - job_name: 'node' static_configs: - targets: ['localhost:9100'] \",\"同时定义告警规则文件/etc/prometheus/rules/hoststats-alert.rules，如下所示：\",\"groups: - name: hostStatsAlert rules: - alert: hostCpuUsageAlert expr: sum(avg without (cpu)(irate(node_cpu{mode!='idle'}[5m]))) by (instance) * 100 > 50 for: 1m labels: severity: page annotations: summary: \\\"Instance {{ $labels.instance }} CPU usgae high\\\" description: \\\"{{ $labels.instance }} CPU usage above 50% (current value: {{ $value }})\\\" - alert: hostMemUsageAlert expr: (node_memory_MemTotal - node_memory_MemAvailable)/node_memory_MemTotal * 100 > 85 for: 1m labels: severity: page annotations: summary: \\\"Instance {{ $labels.instance }} MEM usgae high\\\" description: \\\"{{ $labels.instance }} MEM usage above 85% (current value: {{ $value }})\\\" \",\"本示例部署结构如下所示：\",\"Prometheus与Alertmanager HA部署结构\",\"创建prometheus.procfile文件，创建两个Prometheus节点，分别监听9090和9091端口:\",\"p1: prometheus --config.file=/etc/prometheus/prometheus-ha.yml --storage.tsdb.path=/data/prometheus/ --web.listen-address=\\\"127.0.0.1:9090\\\" p2: prometheus --config.file=/etc/prometheus/prometheus-ha.yml --storage.tsdb.path=/data/prometheus2/ --web.listen-address=\\\"127.0.0.1:9091\\\" node_exporter: node_exporter -web.listen-address=\\\"0.0.0.0:9100\\\" \",\"使用goreman启动多节点Prometheus：\",\"goreman -f prometheus.procfile -p 8556 start \",\"Prometheus启动完成后，手动拉高系统CPU使用率：\",\"cat /dev/zero>/dev/null \",\"注意，对于多核主机，如果CPU达不到预期，运行多个命令。\",\"当CPU利用率达到告警规则触发条件，两个Prometheus实例告警分别被触发。查看Alertmanager输出日志：\",\"11:14:41 a3 | level=debug ts=2018-03-12T03:14:41.945493505Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=hostCpuUsageAlert[7d698ac][active] 11:14:41 a1 | level=debug ts=2018-03-12T03:14:41.945534548Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=hostCpuUsageAlert[7d698ac][active] 11:14:41 a2 | level=debug ts=2018-03-12T03:14:41.945687812Z caller=dispatch.go:188 component=dispatcher msg=\\\"Received alert\\\" alert=hostCpuUsageAlert[7d698ac][active] \",\"3个Alertmanager实例分别接收到来自不同Prometheus实例的告警信息。而Webhook服务只接收到来自Alertmanager集群的一条告警通知：\",\"11:15:11 webhook | 2018/03/12 11:15:11 { 11:15:11 webhook | > \\\"receiver\\\": \\\"default-receiver\\\", 11:15:11 webhook | > \\\"status\\\": \\\"firing\\\", 11:15:11 webhook | > \\\"alerts\\\": [ 11:15:11 webhook | > { 11:15:11 webhook | > \\\"status\\\": \\\"firing\\\", 11:15:11 webhook | > \\\"labels\\\": { 11:15:11 webhook | > \\\"alertname\\\": \\\"hostCpuUsageAlert\\\", \"]},\"152\":{\"h\":\"Prometheus高可用部署\",\"t\":[\"Prometheus的本地存储给Prometheus带来了简单高效的使用体验，可以让Prometheus在单节点的情况下满足大部分用户的监控需求。但是本地存储也同时限制了Prometheus的可扩展性，带来了数据持久化等一系列的问题。通过Prometheus的Remote Storage特性可以解决这一系列问题，包括Prometheus的动态扩展，以及历史数据的存储。\",\"而除了数据持久化问题以外，影响Prometheus性能表现的另外一个重要因素就是数据采集任务量，以及单台Prometheus能够处理的时间序列数。因此当监控规模大到Prometheus单台无法有效处理的情况下，可以选择利用Prometheus的联邦集群的特性，将Prometheus的监控任务划分到不同的实例当中。\",\"这一部分将重点讨论Prometheus的高可用架构，并且根据不同的使用场景介绍了一种常见的高可用方案。\"]},\"153\":{\"h\":\"基本HA：服务可用性\",\"t\":[\"由于Prometheus的Pull机制的设计，为了确保Prometheus服务的可用性，用户只需要部署多套Prometheus Server实例，并且采集相同的Exporter目标即可。\",\"基本HA\",\"基本的HA模式只能确保Prometheus服务的可用性问题，但是不解决Prometheus Server之间的数据一致性问题以及持久化问题(数据丢失后无法恢复)，也无法进行动态的扩展。因此这种部署方式适合监控规模不大，Prometheus Server也不会频繁发生迁移的情况，并且只需要保存短周期监控数据的场景。\"]},\"154\":{\"h\":\"基本HA + 远程存储\",\"t\":[\"在基本HA模式的基础上通过添加Remote Storage存储支持，将监控数据保存在第三方存储服务上。\",\"HA + Remote Storage\",\"在解决了Prometheus服务可用性的基础上，同时确保了数据的持久化，当Prometheus Server发生宕机或者数据丢失的情况下，可以快速的恢复。 同时Prometheus Server可能很好的进行迁移。因此，该方案适用于用户监控规模不大，但是希望能够\\b将监控数据持久化，同时能够确保Prometheus Server的可迁移性的场景。\"]},\"155\":{\"h\":\"基本HA + 远程存储 + 联邦集群\",\"t\":[\"当单台Prometheus Server无法处理大量的采集任务时，用户可以考虑基于Prometheus联邦集群的方式将监控采集任务划分到不同的Prometheus实例当中即在任务级别功能分区。\",\"基本HA + 远程存储 + 联邦集群\",\"这种部署方式一般适用于两种场景：\",\"场景一：单数据中心 + 大量的采集任务\",\"这种场景下Prometheus的性能瓶颈主要在于大量的采集任务，因此用户需要利用Prometheus联邦集群的特性，将不同类型的采集任务划分到不同的Prometheus子服务中，从而实现功能分区。例如一个Prometheus Server负责采集基础设施相关的监控指标，另外一个Prometheus Server负责采集应用监控指标。再有上层Prometheus Server实现对数据的汇聚。\",\"场景二：多数据中心\",\"这种模式也适合与多数据中心的情况，当Prometheus Server无法直接与数据中心中的Exporter进行通讯时，在每一个数据中部署一个单独的Prometheus Server负责当前数据中心的采集任务是一个不错的方式。这样可以避免用户进行大量的网络配置，只需要确保主Prometheus Server实例能够与当前数据中心的Prometheus Server通讯即可。 中心Prometheus Server负责实现对多数据中心数据的聚合。\"]},\"156\":{\"h\":\"按照实例进行功能分区\",\"t\":[\"这时在考虑另外一种极端情况，即单个采集任务的Target数也变得非常巨大。这时简单通过联邦集群进行功能分区，Prometheus Server也无法有效处理时。这种情况只能考虑继续在实例级别进行功能划分。\",\"实例级别功能分区\",\"如上图所示，将统一任务的不同实例的监控数据采集任务划分到不同的Prometheus实例。通过relabel设置，我们可以确保当前Prometheus Server只收集当前采集任务的一部分实例的监控指标。\",\"global: external_labels: slave: 1 # This is the 2nd slave. This prevents clashes between slaves. scrape_configs: - job_name: some_job relabel_configs: - source_labels: [__address__] modulus: 4 target_label: __tmp_hash action: hashmod - source_labels: [__tmp_hash] regex: ^1$ action: keep \",\"并且通过当前数据中心的一个中心Prometheus Server将监控数据进行聚合到任务级别。\",\"- scrape_config: - job_name: slaves honor_labels: true metrics_path: /federate params: match[]: - '{__name__=~\\\"^slave:.*\\\"}' # Request all slave-level time series static_configs: - targets: - slave0:9090 - slave1:9090 - slave3:9090 - slave4:9090 \"]},\"157\":{\"h\":\"高可用方案选择\",\"t\":[\"上面的部分，根据不同的场景演示了3种不同的高可用部署方案。当然对于Prometheus部署方案需要用户根据监控规模以及自身的需求进行动态调整，下表展示了Prometheus和高可用有关3个选项各自解决的问题，用户可以根据自己的需求灵活选择。\",\"选项\\\\需求\",\"服务可用性\",\"数据持久化\",\"水平扩展\",\"主备HA\",\"v\",\"x\",\"x\",\"远程存储\",\"x\",\"v\",\"x\",\"联邦集群\",\"x\",\"x\",\"v\"]},\"158\":{\"h\":\"Prometheus数据存储\"},\"159\":{\"h\":\"本地存储\",\"t\":[\"Prometheus 2.x 采用自定义的存储格式将样本数据保存在本地磁盘当中。如下所示，按照两个小时为一个时间窗口，将两小时内产生的数据存储在一个块(Block)中，每一个块中包含该时间窗口内的所有样本数据(chunks)，元数据文件(meta.json)以及索引文件(index)。\",\"t0 t1 t2 now ┌───────────┐ ┌───────────┐ ┌───────────┐ │ │ │ │ │ │ ┌────────────┐ │ │ │ │ │ mutable │ <─── write ──── ┤ Prometheus │ │ │ │ │ │ │ └────────────┘ └───────────┘ └───────────┘ └───────────┘ ^ └──────────────┴───────┬──────┘ │ │ query │ │ merge ──────────────────────────────────┘ \",\"当前时间窗口内正在收集的样本数据，Prometheus则会直接将数据保存在内存当中。为了确保此期间如果Prometheus发生崩溃或者重启时能够恢复数据，Prometheus启动时会从写入日志(WAL)进行重播，从而恢复数据。此期间如果通过API删除时间序列，删除记录也会保存在单独的逻辑文件当中(tombstone)。\",\"在文件系统中这些块保存在单独的目录当中，Prometheus保存块数据的目录结构如下所示：\",\"./data |- 01BKGV7JBM69T2G1BGBGM6KB12 # 块 |- meta.json # 元数据 |- wal # 写入日志 |- 000002 |- 000001 |- 01BKGTZQ1SYQJTR4PB43C8PD98 # 块 |- meta.json #元数据 |- index # 索引文件 |- chunks # 样本数据 |- 000001 |- tombstones # 逻辑数据 |- 01BKGTZQ1HHWHV8FBJXW1Y3W0K |- meta.json |- wal |-000001 \",\"通过时间窗口的形式保存所有的样本数据，可以明显提高Prometheus的查询效率，当查询一段时间范围内的所有样本数据时，只需要简单的从落在该范围内的块中查询数据即可。\",\"同时该存储方式可以简化历史数据的删除逻辑。只要一个块的时间范围落在了配置的保留范围之外，直接丢弃该块即可。\",\" | ┌────────────┐ ┌────┼─────┐ ┌───────────┐ ┌───────────┐ │ 1 │ │ 2 | │ │ 3 │ │ 4 │ . . . └────────────┘ └────┼─────┘ └───────────┘ └───────────┘ | | retention boundary \"]},\"160\":{\"h\":\"本地存储配置\",\"t\":[\"用户可以通过命令行启动参数的方式修改本地存储的配置。\",\"启动参数\",\"默认值\",\"含义\",\"--storage.tsdb.path\",\"data/\",\"Base path for metrics storage\",\"--storage.tsdb.retention\",\"15d\",\"How long to retain samples in the storage\",\"--storage.tsdb.min-block-duration\",\"2h\",\"The timestamp range of head blocks after which they get persisted\",\"--storage.tsdb.max-block-duration\",\"36h\",\"The maximum timestamp range of compacted blocks,It's the minimum duration of any persisted block.\",\"--storage.tsdb.no-lockfile\",\"false\",\"Do not create lockfile in data directory\",\"在一般情况下，Prometheus中存储的每一个样本大概占用1-2字节大小。如果需要对Prometheus Server的本地磁盘空间做容量规划时，可以通过以下公式计算：\",\"needed_disk_space = retention_time_seconds * ingested_samples_per_second * bytes_per_sample \",\"从上面公式中可以看出在保留时间(retention_time_seconds)和样本大小(bytes_per_sample)不变的情况下，如果想减少本地磁盘的容量需求，只能通过减少每秒获取样本数(ingested_samples_per_second)的方式。因此有两种手段，一是减少时间序列的数量，二是增加采集样本的时间间隔。考虑到Prometheus会对时间序列进行压缩效率，减少时间序列的数量效果更明显。\"]},\"161\":{\"h\":\"从失败中恢复\",\"t\":[\"如果本地存储由于某些原因出现了错误，最直接的方式就是停止Prometheus并且删除data目录中的所有记录。当然也可以尝试删除那些发生错误的块目录，不过相应的用户会丢失该块中保存的大概两个小时的监控记录。\"]},\"162\":{\"h\":\"远程存储\",\"t\":[\"Prometheus的本地存储设计可以减少其自身运维和管理的复杂度，同时能够满足大部分用户监控规模的需求。但是本地存储也意味着Prometheus无法持久化数据，无法存储大量历史数据，同时也无法灵活扩展和迁移。\",\"为了保持Prometheus的简单性，Prometheus并没有尝试在自身中解决以上问题，而是通过定义两个标准接口(remote_write/remote_read)，让用户可以基于这两个接口对接将数据保存到任意第三方的存储服务中，这种方式在Prometheus中称为Remote Storage。\"]},\"163\":{\"h\":\"Remote Write\",\"t\":[\"用户可以在Prometheus配置文件中指定Remote Write(远程写)的URL地址，一旦设置了该配置项，Prometheus将采集到的样本数据通过HTTP的形式发送给适配器(Adaptor)。而用户则可以在适配器中对接外部任意的服务。外部服务可以是真正的存储系统，公有云的存储服务，也可以是消息队列等任意形式。\",\"Remote Write\"]},\"164\":{\"h\":\"Remote Read\",\"t\":[\"如下图所示，Prometheus的Remote Read(远程读)也通过了一个适配器实现。在远程读的流程当中，当用户发起查询请求后，Prometheus将向remote_read中配置的URL发起查询请求(matchers,ranges)，Adaptor根据请求条件从第三方存储服务中获取响应的数据。同时将数据转换为Prometheus的原始样本数据返回给Prometheus Server。\",\"当获取到样本数据后，Prometheus在本地使用PromQL对样本数据进行二次处理。\",\"注意：启用远程读设置后，只在数据查询时有效，对于规则文件的处理，以及Metadata API的处理都只基于Prometheus本地存储完成。\",\"Remote Read\"]},\"165\":{\"h\":\"配置文件\",\"t\":[\"Prometheus配置文件中添加remote_write和remote_read配置，其中url用于指定远程读/写的HTTP服务地址。如果该URL启动了认证则可以通过basic_auth进行安全认证配置。对于https的支持需要设定tls_concig。proxy_url主要用于Prometheus无法直接访问适配器服务的情况下。\",\"remote_write和remote_read具体配置如下所示：\",\"remote_write: url: <string> [ remote_timeout: <duration> | default = 30s ] write_relabel_configs: [ - <relabel_config> ... ] basic_auth: [ username: <string> ] [ password: <string> ] [ bearer_token: <string> ] [ bearer_token_file: /path/to/bearer/token/file ] tls_config: [ <tls_config> ] [ proxy_url: <string> ] remote_read: url: <string> required_matchers: [ <labelname>: <labelvalue> ... ] [ remote_timeout: <duration> | default = 30s ] [ read_recent: <boolean> | default = false ] basic_auth: [ username: <string> ] [ password: <string> ] [ bearer_token: <string> ] [ bearer_token_file: /path/to/bearer/token/file ] [ <tls_config> ] [ proxy_url: <string> ] \"]},\"166\":{\"h\":\"自定义Remote Storage Adaptor\",\"t\":[\"实现自定义Remote Storage需要用户分别创建用于支持remote_read和remote_write的HTTP服务。\",\"Remote Storage\",\"当前Prometheus中Remote Storage相关的协议主要通过以下proto文件进行定义：\",\"syntax = \\\"proto3\\\"; package prometheus; option go_package = \\\"prompb\\\"; import \\\"types.proto\\\"; message WriteRequest { repeated prometheus.TimeSeries timeseries = 1; } message ReadRequest { repeated Query queries = 1; } message ReadResponse { // In same order as the request's queries. repeated QueryResult results = 1; } message Query { int64 start_timestamp_ms = 1; int64 end_timestamp_ms = 2; repeated prometheus.LabelMatcher matchers = 3; } message QueryResult { // Samples within a time series must be ordered by time. repeated prometheus.TimeSeries timeseries = 1; } \",\"以下代码展示了一个简单的remote_write服务，创建用于接收remote_write的HTTP服务，将请求内容转换成WriteRequest后，用户就可以按照自己的需求进行后续的逻辑处理。\",\"package main import ( \\\"fmt\\\" \\\"io/ioutil\\\" \\\"net/http\\\" \\\"github.com/gogo/protobuf/proto\\\" \\\"github.com/golang/snappy\\\" \\\"github.com/prometheus/common/model\\\" \\\"github.com/prometheus/prometheus/prompb\\\" ) func main() { http.HandleFunc(\\\"/receive\\\", func(w http.ResponseWriter, r *http.Request) { compressed, err := ioutil.ReadAll(r.Body) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } reqBuf, err := snappy.Decode(nil, compressed) if err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } var req prompb.WriteRequest if err := proto.Unmarshal(reqBuf, &req); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } for _, ts := range req.Timeseries { m := make(model.Metric, len(ts.Labels)) for _, l := range ts.Labels { m[model.LabelName(l.Name)] = model.LabelValue(l.Value) } fmt.Println(m) for _, s := range ts.Samples { fmt.Printf(\\\" %f %d\\\\n\\\", s.Value, s.Timestamp) } } }) http.ListenAndServe(\\\":1234\\\", nil) } \"]},\"167\":{\"h\":\"使用Influxdb作为Remote Storage\",\"t\":[\"目前Prometheus社区也提供了部分对于第三方数据库的Remote Storage支持：\",\"| 存储服务 | 支持模式 | |---------------- ---------|-------| | AppOptics | write | | Chronix | write | | Cortex: | read/write | | CrateDB | read/write| | Gnocchi | write| | Graphite | write| | InfluxDB | read/write| | OpenTSDB | write| | PostgreSQL/TimescaleDB: | read/write| | SignalFx | write|\",\"这里将介绍如何使用Influxdb作为Prometheus的Remote Storage，从而确保当Prometheus发生宕机或者重启之后能够从Influxdb中恢复和获取历史数据。\",\"这里使用docker-compose定义并启动Influxdb数据库服务，docker-compose.yml定义如下：\",\"version: '2' services: influxdb: image: influxdb:1.3.5 command: -config /etc/influxdb/influxdb.conf ports: - \\\"8086:8086\\\" environment: - INFLUXDB_DB=prometheus - INFLUXDB_ADMIN_ENABLED=true - INFLUXDB_ADMIN_USER=admin - INFLUXDB_ADMIN_PASSWORD=admin - INFLUXDB_USER=prom - INFLUXDB_USER_PASSWORD=prom \",\"启动influxdb服务\",\"$ docker-compose up -d $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 795d0ead87a1 influxdb:1.3.5 \\\"/entrypoint.sh -c...\\\" 3 hours ago Up 3 hours 0.0.0.0:8086->8086/tcp localhost_influxdb_1 \",\"获取并启动Prometheus提供的Remote Storage Adapter：\",\"go get github.com/prometheus/prometheus/documentation/examples/remote_storage/remote_storage_adapter \",\"获取remote_storage_adapter源码后，go会自动把相关的源码编译成可执行文件，并且保存在$GOPATH/bin/目录下。\",\"启动remote_storage_adapter并且设置Influxdb相关的认证信息：\",\"INFLUXDB_PW=prom $GOPATH/bin/remote_storage_adapter -influxdb-url=http://localhost:8086 -influxdb.username=prom -influxdb.database=prometheus -influxdb.retention-policy=autogen \",\"修改prometheus.yml添加Remote Storage相关的配置内容：\",\"remote_write: - url: \\\"http://localhost:9201/write\\\" remote_read: - url: \\\"http://localhost:9201/read\\\" \",\"重新启动Prometheus能够获取数据后，登录到influxdb容器，并验证数据写入。如下所示，当数据能够正常写入Influxdb后可以看到Prometheus相关的指标。\",\"docker exec -it 795d0ead87a1 influx Connected to http://localhost:8086 version 1.3.5 InfluxDB shell version: 1.3.5 > auth username: prom password: > use prometheus > SHOW MEASUREMENTS name: measurements name ---- go_gc_duration_seconds go_gc_duration_seconds_count go_gc_duration_seconds_sum go_goroutines go_info go_memstats_alloc_bytes go_memstats_alloc_bytes_total go_memstats_buck_hash_sys_bytes go_memstats_frees_total go_memstats_gc_cpu_fraction go_memstats_gc_sys_bytes go_memstats_heap_alloc_bytes go_memstats_heap_idle_bytes \",\"当数据写入成功后，停止Prometheus服务。同时删除Prometheus的data目录，模拟Prometheus数据丢失的情况后重启Prometheus。打开Prometheus UI如果配置正常，Prometheus可以正常查询到本地存储以删除的历史数据记录。\",\"从Remote Storage获取历史数据\"]},\"168\":{\"h\":\"联邦集群\",\"t\":[\"通过Remote Storage可以分离监控样本采集和数据存储，解决Prometheus的持久化问题。这一部分会重点讨论如何利用联邦集群特性对Prometheus进行扩展，以适应不同监控规模的变化。\"]},\"169\":{\"h\":\"使用联邦集群\",\"t\":[\"对于大部分监控规模而言，我们只需要在每一个数据中心(例如：EC2可用区，Kubernetes集群)安装一个Prometheus Server实例，就可以在各个数据中心处理上千规模的集群。同时将Prometheus Server部署到不同的数据中心可以避免网络配置的复杂性。\",\"联邦集群\",\"如上图所示，在每个数据中心部署单独的Prometheus Server，用于采集当前数据中心监控数据。并由一个中心的Prometheus Server负责聚合多个数据中心的监控数据。这一特性在Prometheus中称为联邦集群。\",\"联邦集群的核心在于每一个Prometheus Server都包含一个用于获取当前实例中监控样本的接口/federate。对于中心Prometheus Server而言，无论是从其他的Prometheus实例还是Exporter实例中获取数据实际上并没有任何差异。\",\"scrape_configs: - job_name: 'federate' scrape_interval: 15s honor_labels: true metrics_path: '/federate' params: 'match[]': - '{job=\\\"prometheus\\\"}' - '{__name__=~\\\"job:.*\\\"}' - '{__name__=~\\\"node.*\\\"}' static_configs: - targets: - '192.168.77.11:9090' - '192.168.77.12:9090' \",\"为了有效的减少不必要的时间序列，通过params参数可以用于指定只获取某些时间序列的样本数据，例如\",\"\\\"http://192.168.77.11:9090/federate?match[]={job%3D\\\"prometheus\\\"}&match[]={__name__%3D~\\\"job%3A.*\\\"}&match[]={__name__%3D~\\\"node.*\\\"}\\\" \",\"通过URL中的match[]参数指定我们可以指定需要获取的时间序列。match[]参数必须是一个瞬时向量选择器，例如up或者{job=\\\"api-server\\\"}。配置多个match[]参数，用于获取多组时间序列的监控数据。\",\"horbor_labels配置true可以确保当采集到的监控指标冲突时，能够自动忽略冲突的监控数据。如果为false时，prometheus会自动将冲突的标签替换为“exported_<original-label>”的形式。\"]},\"170\":{\"h\":\"功能分区\",\"t\":[\"联邦集群的特性可以帮助用户根据不同的监控规模对Prometheus部署架构进行调整。例如如下所示，可以在各个数据中心中部署多个Prometheus Server实例。每一个Prometheus Server实例只负责采集当前数据中心中的一部分任务(Job)，例如可以将不同的监控任务分离到不同的Prometheus实例当中，再有中心Prometheus实例进行聚合。\",\"功能分区\",\"功能分区，即通过联邦集群的特性在任务级别对Prometheus采集任务进行划分，以支持规模的扩展。\"]},\"171\":{\"h\":\"第8章 Kubernetes监控实战\",\"t\":[\"Kubenetes是一款由Google开发的开源的容器编排工具，在Google已经使用超过15年。作为容器领域事实的标准，Kubernetes可以极大的简化应用的管理和部署复杂度。本章中，我们将介绍Kubernetes的一些基本概念，并且从0开始利用Prometheus构建一个完整的Kubernetes集群监控系统。同时我们还将学习如何通过Prometheus Operator简化在Kubernetes下部署和管理Promethues的过程。\",\"本章的主要内容：\",\"理解Kubernetes的工作机制\",\"Prometheus在Kubernetes下的服务发现机制\",\"监控Kubernetes集群状态\",\"监控集群基础设施\",\"监控集群应用容器资源使用情况\",\"监控用户部署的应用程序\",\"对Service和Ingress进行网络探测\",\"通过Operator高效管理和部署在Kubernetes集群中的Prometheus\"]},\"172\":{\"h\":\"小结\",\"t\":[\"Kubernetes与Promethues有着十分相似的历程，均是源自Google内部多年的运维经验。并且相继从CNCF基金会正式毕业。它们分别代表了云原生模式下容器编排以及监控的事实标准。\"]},\"173\":{\"h\":\"在Kubernetes下部署Prometheus\",\"t\":[\"在上一小节中我们介绍了与Kubernetes的应用管理模型，并且利用MiniKube在本地搭建了一个单节点的Kubernetes。这一部分我们将带领读者通过Kubernetes部署Prometheus实例。\"]},\"174\":{\"h\":\"使用ConfigMaps管理应用配置\",\"t\":[\"当使用Deployment管理和部署应用程序时，用户可以方便了对应用进行扩容或者缩容，从而产生多个Pod实例。为了能够统一管理这些Pod的配置信息，在Kubernetes中可以使用ConfigMaps资源定义和管理这些配置，并且通过环境变量或者文件系统挂载的方式让容器使用这些配置。\",\"这里将使用ConfigMaps管理Prometheus的配置文件，创建prometheus-config.yml文件，并写入以下内容：\",\"apiVersion: v1 kind: ConfigMap metadata: name: prometheus-config data: prometheus.yml: | global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: 'prometheus' static_configs: - targets: ['localhost:9090'] \",\"使用kubectl命令行工具，在命名空间default创建ConfigMap资源：\",\"kubectl create -f prometheus-config.yml configmap \\\"prometheus-config\\\" created \"]},\"175\":{\"h\":\"使用Deployment部署Prometheus\",\"t\":[\"当ConfigMap资源创建成功后，我们就可以通过Volume挂载的方式，将Prometheus的配置文件挂载到容器中。 这里我们通过Deployment部署Prometheus Server实例，创建prometheus-deployment.yml文件，并写入以下内容:\",\"apiVersion: v1 kind: \\\"Service\\\" metadata: name: prometheus labels: name: prometheus spec: ports: - name: prometheus protocol: TCP port: 9090 targetPort: 9090 selector: app: prometheus type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: name: prometheus name: prometheus spec: replicas: 1 template: metadata: labels: app: prometheus spec: containers: - name: prometheus image: prom/prometheus:v2.2.1 command: - \\\"/bin/prometheus\\\" args: - \\\"--config.file=/etc/prometheus/prometheus.yml\\\" ports: - containerPort: 9090 protocol: TCP volumeMounts: - mountPath: \\\"/etc/prometheus\\\" name: prometheus-config volumes: - name: prometheus-config configMap: name: prometheus-config \",\"该文件中分别定义了Service和Deployment，Service类型为NodePort，这样我们可以通过虚拟机IP和端口访问到Prometheus实例。为了能够让Prometheus实例使用ConfigMap中管理的配置文件，这里通过volumes声明了一个磁盘卷。并且通过volumeMounts将该磁盘卷挂载到了Prometheus实例的/etc/prometheus目录下。\",\"使用以下命令创建资源，并查看资源的创建情况：\",\"$ kubectl create -f prometheus-deployment.yml service \\\"prometheus\\\" created deployment \\\"prometheus\\\" created $ kubectl get pods NAME READY STATUS RESTARTS AGE prometheus-55f655696d-wjqcl 1/1 Running 0 5s $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 131d prometheus NodePort 10.101.255.236 <none> 9090:32584/TCP 42s \",\"至此，我们可以通过MiniKube虚拟机的IP地址和端口32584访问到Prometheus的服务。\",\"Prometheus UI\"]},\"176\":{\"h\":\"基于Prometheus的弹性伸缩\",\"t\":[\"弹性伸缩（AutoScaling）是指应用可以根据当前的资源使用情况自动水平扩容或者缩容的能力。\"]},\"177\":{\"h\":\"初识Kubernetes\",\"t\":[\"Kubenetes是一款由Google开发的开源的容器编排工具（GitHub源码），在Google已经使用超过15年（Kubernetest前身是Google的内部工具Borg）。Kubernetes将一系列的主机看做是一个受管理的海量资源，这些海量资源组成了一个能够方便进行扩展的操作系统。而在Kubernetes中运行着的容器则可以视为是这个操作系统中运行的“进程”，通过Kubernetes这一中央协调器，解决了基于容器应用程序的调度、伸缩、访问负载均衡以及整个系统的管理和监控的问题。\"]},\"178\":{\"h\":\"Kubernetes应用管理模型\",\"t\":[\"下图展示了Kubernetes的应用管理模型：\",\"Kubernetes应用管理模型\",\"Pod是Kubernetes中的最小调度资源。Pod中会包含一组容器，它们一起工作，并且对外提供一个（或者一组）功能。对于这组容器而言它们共享相同的网络和存储资源，因此它们之间可以直接通过本地网络（127.0.0.1）进行访问。当Pod被创建时，调度器（kube-schedule）会从集群中找到满足条件的节点运行它。\",\"如果部署应用程序时，需要启动多个实例（副本），则需要使用到控制器（Controller）。用户可以在Controller定义Pod的调度规则、运行的副本数量以及升级策略等等信息，当某些Pod发生故障之后，Controller会尝试自动修复，直到Pod的运行状态满足Controller中定义的预期状态为止。Kubernetes中提供了多种Controller的实现，包括：Deployment（无状态应用）、StatefulSet（有状态应用）、Daemonset（守护模式）等，以支持不同类型应用的部署和调度模式。\",\"通过Controller和Pod我们定义了应用程序是如何运行的，接下来需要解决如何使用这些部署在Kubernetes集群中的应用。Kubernetes将这一问题划分为两个问题域，第一，集群内的应用如何通信。第二，外部的用户如何访问部署在集群内的应用？\",\"对于第一个问题，在Kubernetes中通过定义Service（服务）来解决。Service在Kubernetes集群内扮演了服务发现和负载均衡的作用。在Kubernetes下部署的Pod实例都会包含一组描述自身信息的label，而创建Service，可以声明一个Selector（标签选择器）。Service通过Selector，找到匹配标签规则的Pod实例，并将对Service的请求转发到代理的Pod中。Service创建完成后，集群内的应用就可以通过使用Service的名称作为DNS域名进行相互访问。\",\"而对于第二个问题，Kubernetes中定义了单独的资源Ingress（入口）。Ingress是一个工作在7层的负载均衡器，其负责代理外部进入集群内的请求，并将流量转发到对应的服务中。\",\"最后，对于同一个Kubernetes集群其可能被多个组织使用，为了隔离这些不同组织创建的应用程序，Kubernetes定义了Namespace（命名空间）对资源进行隔离。\"]},\"179\":{\"h\":\"Kubernetes架构模型\",\"t\":[\"为了能够更好的理解Kubernetes下的监控体系，我们需要了解Kubernetes的基本架构，如下所示，是Kubernetes的架构示意图：\",\"Kubernetes架构\",\"Kubernetes的核心组件主要由两部分组成：Master组件和Node组件，其中Matser组件提供了集群层面的管理功能，它们负责响应用户请求并且对集群资源进行统一的调度和管理。Node组件会运行在集群的所有节点上，它们负责管理和维护节点中运行的Pod，为Kubernetes集群提供运行时环境。\",\"Master组件主要包括：\",\"kube-apiserver：负责对外暴露Kubernetes API；\",\"etcd：用于存储Kubernetes集群的所有数据；\",\"kube-scheduler: 负责为新创建的Pod选择可供其运行的节点；\",\"kube-controller-manager： 包含Node Controller，Deployment Controller，Endpoint Controller等等，通过与apiserver交互使相应的资源达到预期状态。\",\"Node组件主要包括：\",\"kubelet：负责维护和管理节点上Pod的运行状态；\",\"kube-proxy：负责维护主机上的网络规则以及转发。\",\"Container Runtime：如Docker,rkt,runc等提供容器运行时环境。\"]},\"180\":{\"h\":\"Kubernetes监控策略\",\"t\":[\"Kubernetes作为开源的容器编排工具，为用户提供了一个可以统一调度，统一管理的云操作系统。其解决如用户应用程序如何运行的问题。而一旦在生产环境中大量基于Kubernetes部署和管理应用程序后，作为系统管理员，还需要充分了解应用程序以及Kubernetes集群服务运行质量如何，通过对应用以及集群运行状态数据的收集和分析，持续优化和改进，从而提供一个安全可靠的生产运行环境。 这一小节中我们将讨论当使用Kubernetes时的监控策略该如何设计。\",\"从物理结构上讲Kubernetes主要用于整合和管理底层的基础设施资源，对外提供应用容器的自动化部署和管理能力，这些基础设施可能是物理机、虚拟机、云主机等等。因此，基础资源的使用直接影响当前集群的容量和应用的状态。在这部分，我们需要关注集群中各个节点的主机负载，CPU使用率、内存使用率、存储空间以及网络吞吐等监控指标。\",\"从自身架构上讲，kube-apiserver是Kubernetes提供所有服务的入口，无论是外部的客户端还是集群内部的组件都直接与kube-apiserver进行通讯。因此，kube-apiserver的并发和吞吐量直接决定了集群性能的好坏。其次，对于外部用户而言，Kubernetes是否能够快速的完成pod的调度以及启动，是影响其使用体验的关键因素。而这个过程主要由kube-scheduler负责完成调度工作，而kubelet完成pod的创建和启动工作。因此在Kubernetes集群本身我们需要评价其自身的服务质量，主要关注在Kubernetes的API响应时间，以及Pod的启动时间等指标上。\",\"Kubernetes的最终目标还是需要为业务服务，因此我们还需要能够监控应用容器的资源使用情况。对于内置了对Prometheus支持的应用程序，也要支持从这些应用程序中采集内部的监控指标。最后，结合黑盒监控模式，对集群中部署的服务进行探测，从而当应用发生故障后，能够快速处理和恢复。\",\"综上所述，我们需要综合使用白盒监控和黑盒监控模式，建立从基础设施，Kubernetes核心组件，应用容器等全面的监控体系。\",\"在白盒监控层面我们需要关注：\",\"基础设施层（Node）：为整个集群和应用提供运行时资源，需要通过各节点的kubelet获取节点的基本状态，同时通过在节点上部署Node Exporter获取节点的资源使用情况；\",\"容器基础设施（Container）：为应用提供运行时环境，Kubelet内置了对cAdvisor的支持，用户可以直接通过Kubelet组件获取给节点上容器相关监控指标；\",\"用户应用（Pod）：Pod中会包含一组容器，它们一起工作，并且对外提供一个（或者一组）功能。如果用户部署的应用程序内置了对Prometheus的支持，那么我们还应该采集这些Pod暴露的监控指标；\",\"Kubernetes组件：获取并监控Kubernetes核心组件的运行状态，确保平台自身的稳定运行。\",\"而在黑盒监控层面，则主要需要关注以下：\",\"内部服务负载均衡（Service）：在集群内，通过Service在集群暴露应用功能，集群内应用和应用之间访问时提供内部的负载均衡。通过Blackbox Exporter探测Service的可用性，确保当Service不可用时能够快速得到告警通知；\",\"外部访问入口（Ingress）：通过Ingress提供集群外的访问入口，从而可以使外部客户端能够访问到部署在Kubernetes集群内的服务。因此也需要通过Blackbox Exporter对Ingress的可用性进行探测，确保外部用户能够正常访问集群内的功能；\"]},\"181\":{\"h\":\"搭建本地Kubernetes集群\",\"t\":[\"为了能够更直观的了解和使用Kubernetes，我们将在本地通过工具Minikube(https://github.com/kubernetes/minikube)搭建一个本地的Kubernetes测试环境。Minikube会在本地通过虚拟机运行一个单节点的Kubernetes集群，可以方便用户或者开发人员在本地进行与Kubernetes相关的开发和测试工作。\",\"安装MiniKube的方式很简单，对于Mac用户可以直接使用Brew进行安装:\",\"brew cask install minikube \",\"其它操作系统用户，可以查看Minikube项目的官方说明文档进行安装即可。安装完成后，在本机通过命令行启动Kubernetes集群:\",\"$ minikube start Starting local Kubernetes v1.7.5 cluster... Starting VM... SSH-ing files into VM... Setting up certs... Starting cluster components... Connecting to cluster... Setting up kubeconfig... Kubectl is now configured to use the cluster. \",\"MiniKube会自动配置本机的kubelet命令行工具，用于与对集群资源进行管理。同时Kubernetes也提供了一个Dashboard管理界面，在MiniKube下可以通过以下命令打开：\",\"$ minikube dashboard Opening kubernetes dashboard in default browser... \",\"Kubernetes中的Dashboard本身也是通过Deployment进行部署的，因此可以通过MiniKube找到当前集群虚拟机的IP地址：\",\"$ minikube ip 192.168.99.100 \",\"通过kubectl命令行工具，找到Dashboard对应的Service对外暴露的端口，如下所示，kubernetes-dashboard是一个NodePort类型的Service，并对外暴露了30000端口：\",\"$ kubectl get service --namespace=kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kube-dns ClusterIP 10.96.0.10 <none> 53/UDP,53/TCP 131d kubernetes-dashboard NodePort 10.105.168.160 <none> 80:30000/TCP 131d \",\"在Dashbord中，用户可以可视化的管理当前集群中运行的所有资源，以及监视其资源运行状态。\",\"Kubernetes Dashboard\",\"Kubernetes环境准备完成后，就可以开始尝试在Kubernetes下尝试部署一个应用程序。Kubernetes中管理的所有资源都可以通过YAML文件进行描述。如下所示，创建了一个名为nginx-deploymeht.yml文件：\",\"apiVersion: extensions/v1beta1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 \",\"在该YAML文件中，我们定义了需要创建的资源类型为Deployment，在metadata中声明了该Deployment的名称以及标签。spec中则定义了该Deployment的具体设置，通过replicas定义了该Deployment创建后将会自动创建3个Pod实例。运行的Pod以及进行则通过template进行定义。\",\"在命令行中使用，如下命令：\",\"$ kubectl create -f nginx-deployment.yml deployment \\\"nginx-deployment\\\" created \",\"在未指定命名空间的情况下，kubectl默认关联default命名空间。由于这里没有指定Namespace，该Deployment将会在默认的命令空间default中创建。 通过kubectl get命令查看当前Deployment的部署进度：\",\"# 查看Deployment的运行状态 $ kubectl get deployments NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE nginx-deployment 3 3 3 3 1m # 查看运行的Pod实例 $ kubectl get pods NAME READY STATUS RESTARTS AGE nginx-deployment-6d8f46cfb7-5f9qm 1/1 Running 0 1m nginx-deployment-6d8f46cfb7-9ppb8 1/1 Running 0 1m nginx-deployment-6d8f46cfb7-nfmsw 1/1 Running 0 1m \",\"为了能够让用户或者其它服务能够访问到Nginx实例，这里通过一个名为nginx-service.yml的文件定义Service资源：\",\"kind: Service apiVersion: v1 metadata: name: nginx-service spec: selector: app: nginx ports: - protocol: TCP port: 80 targetPort: 80 type: NodePort \",\"默认情况下，Service资源只能通过集群网络进行访问(type=ClusterIP)。这里为了能够直接访问该Service，需要将容器端口映射到主机上，因此定义该Service类型为NodePort。\",\"创建并查看Service资源：\",\"$ kubectl create -f nginx-service.yml service \\\"nginx-service\\\" created $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 131d nginx-service NodePort 10.104.103.112 <none> 80:32022/TCP 10s \",\"通过nginx-server映射到虚拟机的32022端口，就可以直接访问到Nginx实例的80端口：\",\"Nginx主页\",\"部署完成后，如果需要对Nginx实例进行扩展，可以使用：\",\"$ kubectl scale deployments/nginx-deployment --replicas=4 deployment \\\"nginx-deployment\\\" scaled \",\"通过kubectl命令还可以对镜像进行滚动升级：\",\"$ kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 deployment \\\"nginx-deployment\\\" image updated $ kubectl get pods NAME READY STATUS RESTARTS AGE nginx-deployment-58b94fcb9-8fjm6 0/1 ContainerCreating 0 52s nginx-deployment-58b94fcb9-qzlwx 0/1 ContainerCreating 0 51s nginx-deployment-6d8f46cfb7-5f9qm 1/1 Running 0 45m nginx-deployment-6d8f46cfb7-7xs6z 0/1 Terminating 0 2m nginx-deployment-6d8f46cfb7-9ppb8 1/1 Running 0 45m nginx-deployment-6d8f46cfb7-nfmsw 1/1 Running 0 45m \",\"如果升级后服务出现异常，那么可以通过以下命令对应用进行回滚：\",\"$ kubectl rollout undo deployment/nginx-deployment deployment \\\"nginx-deployment\\\" \",\"Kubernetes依托于Google丰富的大规模应用管理经验。通过将集群环境抽象为一个统一调度和管理的云\\\"操作系统，视容器为这个操作中独自运行的“进程”，进程间的隔离通过命名空间（Namespace）完成，实现了对应用生命周期管理从自动化到自主化的跨越。\"]},\"182\":{\"h\":\"Prometheus与Kubernetes\",\"t\":[\"Kubernetes作为开源的容器编排工具，为用户提供了一个可以统一调度，统一管理的云操作系统。其解决如用户应用程序如何运行的问题。而一旦在生产环境中大量基于Kubernetes部署和管理应用程序后，作为系统管理员，还需要充分了解应用程序以及Kubernetes集群服务运行质量如何，通过对应用以及集群运行状态数据的收集和分析，持续优化和改进，从而提供一个安全可靠的生产运行环境。 这一小节中我们将讨论当使用Kubernetes时的监控策略该如何设计。\"]},\"183\":{\"h\":\"Kubernetes架构\",\"t\":[\"为了能够更好的理解Kubernetes下的监控体系，我们需要了解Kubernetes的基本架构，如下所示，是Kubernetes的架构示意图：\",\"Kubernetes架构\",\"Kubernetes的核心组件主要由两部分组成：Master组件和Node\\b组件，\\b其中Matser组件提供了集群层面的管理功能，它们负责响应用户请求，处理集群实际，并且对集群资源进行统一的调度和管理。Node组件会运行在集群的所有节点上，它们负责管理和维护节点中运行的Pod，为Kubernetes集群提供运行时环境。\",\"Master组件主要包括：\",\"kube-apiserver：负责对外暴露Kubernetes API；\",\"etcd：用于存储Kubernetes集群的所有数据；\",\"kube-scheduler: 负责为新创建的Pod选择可供其运行的节点；\",\"kube-controller-manager： 包含Node Controller，Deployment Controller，Endpoint Controller等等，通过与apiserver交互使相应的资源达到预期状态。\",\"Node组件主要包括：\",\"kubelet：负责维护和管理节点上Pod的运行状态；\",\"kube-proxy：负责维护主机上的网络规则以及转发。\",\"Container Runtime：如Docker,rkt,runc等提供容器运行时环境。\"]},\"184\":{\"h\":\"监控Kubernetes\",\"t\":[\"从物理结构上讲Kubernetes主要用于整合和管理底层的基础设施资源，对外提供应用容器的自动化部署和管理能力，这些基础设施可能是物理机、虚拟机、云主机等等。因此，基础资源的使用直接影响当前集群的容量和应用的状态。在这部分，我们需要关注集群中各个节点的主机负载，CPU使用率、内存使用率、存储空间以及网络吞吐等监控指标。\",\"从自身架构上讲，kube-apiserver是Kubernetes提供所有服务的入口，无论是外部的客户端还是集群内部的组件都直接与kube-apiserver进行通讯。因此，kube-apiserver的并发和吞吐量直接决定了集群性能的好坏。其次，对于外部用户而言，Kubernetes是否能够快速的完成pod的调度以及启动，是影响其使用体验的关键因素。而这个过程主要由kube-scheduler负责完成调度工作，而kubelet完成pod的创建和启动工作。因此在Kubernetes集群本身我们需要评价其自身的服务质量，主要关注在Kubernetes的API响应时间，以及Pod的启动时间等指标上。\",\"Kubernetes的最终目标还是需要为业务服务，因此我们还需要能够监控应用容器的资源使用情况。对于内置了对Prometheus支持的应用程序，也要支持从这些应用程序中采集内部的监控指标。最后，结合黑盒监控模式，对集群中部署的服务进行探测，从而当应用发生故障后，能够快速处理和恢复。\",\"因此，在不考虑Kubernetes自身组件的情况下，如果要构建一个完整的监控体系，我们应该考虑，以下5个方面：\",\"集群节点状态监控：从集群中各节点的kubelet服务获取节点的基本运行状态；\",\"集群节点资源用量监控：通过Daemonset的形式在集群中各个节点部署Node Exporter采集节点的资源使用情况；\",\"节点中运行的容器监控：通过各个节点中kubelet内置的cAdvisor中获取个节点中所有容器的运行状态和资源使用情况；\",\"从黑盒监控的角度在集群中部署Blackbox Exporter探针服务，检测Service和Ingress的可用性；\",\"如果在集群中部署的应用程序本身内置了对Prometheus的监控支持，那么我们还应该找到相应的Pod实例，并从该Pod实例中获取其内部运行状态的监控指标。\"]},\"185\":{\"h\":\"Kubernetes下的服务发现\",\"t\":[\"目前为止，我们已经能够在Kubernetes下部署一个简单的Prometheus实例，不过当前来说它并不能发挥其监控系统的作用，除了Prometheus，暂时没有任何的监控采集目标。在第7章中，我们介绍了Prometheus的服务发现能力，它能够与通过与“中间代理人“的交互，从而动态的获取需要监控的目标实例。而在Kubernetes下Prometheus就是需要与Kubernetes的API进行交互，从而能够动态的发现Kubernetes中部署的所有可监控的目标资源。\"]},\"186\":{\"h\":\"Kubernetes的访问授权\",\"t\":[\"为了能够让Prometheus能够访问收到认证保护的Kubernetes API，我们首先需要做的是，对Prometheus进行访问授权。在Kubernetes中主要使用基于角色的访问控制模型(Role-Based Access Control)，用于管理Kubernetes下资源访问权限。首先我们需要在Kubernetes下定义角色（ClusterRole），并且为该角色赋予相应的访问权限。同时创建Prometheus所使用的账号（ServiceAccount），最后则是将该账号与角色进行绑定（ClusterRoleBinding）。这些所有的操作在Kubernetes同样被视为是一系列的资源，可以通过YAML文件进行描述并创建，这里创建prometheus-rbac-setup.yml文件，并写入以下内容：\",\"apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: prometheus rules: - apiGroups: [\\\"\\\"] resources: - nodes - nodes/proxy - services - endpoints - pods verbs: [\\\"get\\\", \\\"list\\\", \\\"watch\\\"] - apiGroups: - extensions resources: - ingresses verbs: [\\\"get\\\", \\\"list\\\", \\\"watch\\\"] - nonResourceURLs: [\\\"/metrics\\\"] verbs: [\\\"get\\\"] --- apiVersion: v1 kind: ServiceAccount metadata: name: prometheus namespace: default --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: prometheus roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: prometheus subjects: - kind: ServiceAccount name: prometheus namespace: default \",\"其中需要注意的是ClusterRole是全局的，不需要指定命名空间。而ServiceAccount是属于特定命名空间的资源。通过kubectl命令创建RBAC对应的各个资源：\",\"$ kubectl create -f prometheus-rbac-setup.yml clusterrole \\\"prometheus\\\" created serviceaccount \\\"prometheus\\\" created clusterrolebinding \\\"prometheus\\\" created \",\"在完成角色权限以及用户的绑定之后，就可以指定Prometheus使用特定的ServiceAccount创建Pod实例。修改prometheus-deployment.yml文件，并添加serviceAccountName和serviceAccount定义：\",\"spec: replicas: 1 template: metadata: labels: app: prometheus spec: serviceAccountName: prometheus serviceAccount: prometheus \",\"通过kubectl apply对Deployment进行变更升级：\",\"$ kubectl apply -f prometheus-deployment.yml service \\\"prometheus\\\" configured deployment \\\"prometheus\\\" configured $ kubectl get pods NAME READY STATUS RESTARTS AGE prometheus-55f655696d-wjqcl 0/1 Terminating 0 38m prometheus-69f9ddb588-czn2c 1/1 Running 0 6s \",\"指定ServiceAccount创建的Pod实例中，会自动将用于访问Kubernetes API的CA证书以及当前账户对应的访问令牌文件挂载到Pod实例的/var/run/secrets/kubernetes.io/serviceaccount/目录下，可以通过以下命令进行查看：\",\"kubectl exec -it prometheus-69f9ddb588-czn2c ls /var/run/secrets/kubernetes.io/serviceaccount/ ca.crt namespace token \"]},\"187\":{\"h\":\"服务发现\",\"t\":[\"在Kubernetes下，Promethues通过与Kubernetes API集成目前主要支持5种服务发现模式，分别是：Node、Service、Pod、Endpoints、Ingress。\",\"通过kubectl命令行，可以方便的获取到当前集群中的所有节点信息：\",\"$ kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME minikube Ready <none> 164d v1.8.0 <none> Buildroot 2017.02 4.9.13 docker://Unknown \",\"为了能够让Prometheus能够获取到当前集群中所有节点的信息，在Prometheus的配置文件中，我们添加如下Job配置：\",\"- job_name: 'kubernetes-nodes' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node \",\"通过指定kubernetes_sd_config的模式为node，Prometheus会自动从Kubernetes中发现到所有的node节点并作为当前Job监控的Target实例。如下所示，这里需要指定用于访问Kubernetes API的ca以及token文件路径。\",\"对于Ingress，Service，Endpoints, Pod的使用方式也是类似的，下面给出了一个完整Prometheus配置的示例：\",\"apiVersion: v1 data: prometheus.yml: |- global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: 'kubernetes-nodes' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node - job_name: 'kubernetes-service' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: service - job_name: 'kubernetes-endpoints' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: endpoints - job_name: 'kubernetes-ingress' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: ingress - job_name: 'kubernetes-pods' tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: pod kind: ConfigMap metadata: name: prometheus-config \",\"更新Prometheus配置文件，并重建Prometheus实例：\",\"$ kubectl apply -f prometheus-config.yml configmap \\\"prometheus-config\\\" configured $ kubectl get pods prometheus-69f9ddb588-rbrs2 1/1 Running 0 4m $ kubectl delete pods prometheus-69f9ddb588-rbrs2 pod \\\"prometheus-69f9ddb588-rbrs2\\\" deleted $ kubectl get pods prometheus-69f9ddb588-rbrs2 0/1 Terminating 0 4m prometheus-69f9ddb588-wtlsn 1/1 Running 0 14s \",\"Prometheus使用新的配置文件重建之后，打开Prometheus UI，通过Service Discovery页面可以查看到当前Prometheus通过Kubernetes发现的所有资源对象了：\",\"Service Discovery发现的实例\",\"同时Prometheus会自动将该资源的所有信息，并通过标签的形式体现在Target对象上。如下所示，是Prometheus获取到的Node节点的标签信息：\",\"__address__=\\\"192.168.99.100:10250\\\" __meta_kubernetes_node_address_Hostname=\\\"minikube\\\" __meta_kubernetes_node_address_InternalIP=\\\"192.168.99.100\\\" __meta_kubernetes_node_annotation_alpha_kubernetes_io_provided_node_ip=\\\"192.168.99.100\\\" __meta_kubernetes_node_annotation_node_alpha_kubernetes_io_ttl=\\\"0\\\" __meta_kubernetes_node_annotation_volumes_kubernetes_io_controller_managed_attach_detach=\\\"true\\\" __meta_kubernetes_node_label_beta_kubernetes_io_arch=\\\"amd64\\\" __meta_kubernetes_node_label_beta_kubernetes_io_os=\\\"linux\\\" __meta_kubernetes_node_label_kubernetes_io_hostname=\\\"minikube\\\" __meta_kubernetes_node_name=\\\"minikube\\\" __metrics_path__=\\\"/metrics\\\" __scheme__=\\\"https\\\" instance=\\\"minikube\\\" job=\\\"kubernetes-nodes\\\" \",\"目前为止，我们已经能够通过Prometheus自动发现Kubernetes集群中的各类资源以及其基本信息。不过，如果现在查看Prometheus的Target状态页面，结果可能会让人不太满意：\",\"Target页面状态\",\"虽然Prometheus能够自动发现所有的资源对象，并且将其作为Target对象进行数据采集。 但并不是所有的资源对象都是支持Promethues的，并且不同类型资源对象的采集方式可能是不同的。因此，在实际的操作中，我们需要有明确的监控目标，并且针对不同类型的监控目标设置不同的数据采集方式。\",\"接下来，我们将利用Prometheus的服务发现能力，实现对Kubernetes集群的全面监控。\"]},\"188\":{\"h\":\"应用容器监控\",\"t\":[\"在第4章的“监控容器运行状态”小节中，我们介绍了如何使用cAdvisor监控主机中容器的运行状态。而Kubernetes直接在Kubelet组件中集成了cAdvisor，cAdvisor会自动采集当前节点上容器CPU，内存，文件系统，网络等资源的使用情况，其默认运行端口为4194。\",\"登录到MiniKube主机，并且访问本机的4194端口，可以获取到当前节点上cAdvisor的监控样本数据：\",\"$ minikube ssh $ curl 127.0.0.1:4194/metrics ... # HELP process_start_time_seconds Start time of the process since unix epoch in seconds. # TYPE process_start_time_seconds gauge process_start_time_seconds 1.52506226634e+09 # HELP process_virtual_memory_bytes Virtual memory size in bytes. # TYPE process_virtual_memory_bytes gauge process_virtual_memory_bytes 1.1649622016e+10 \",\"在本节中，我们将利用Prometheus的服务发现能力，自动的找到这些\\bcAdvisor的采集目标。\"]},\"189\":{\"h\":\"基于Node的服务发现模式\",\"t\":[\"在上一小节中，我们已经能够通过Kubernetes自动的发现当前集群中的所有Node节点。\",\" kubernetes_sd_configs: - role: node \",\"如上所示，当role的配置为node时，Prometheus会通过Kubernetes API找到集群中的所有Node对象，并且将其转换为Prometheus的Target对象，从Prometheus UI中可以查看该Target实例包含的所有Metadata标签信息，如下所示，在从MiniKube集群中获取到的一个节点Metadata标签信息：\",\"__address__=\\\"192.168.99.100:10250\\\" __meta_kubernetes_node_address_Hostname=\\\"minikube\\\" __meta_kubernetes_node_address_InternalIP=\\\"192.168.99.100\\\" __meta_kubernetes_node_annotation_alpha_kubernetes_io_provided_node_ip=\\\"192.168.99.100\\\" __meta_kubernetes_node_annotation_node_alpha_kubernetes_io_ttl=\\\"0\\\" __meta_kubernetes_node_annotation_volumes_kubernetes_io_controller_managed_attach_detach=\\\"true\\\" __meta_kubernetes_node_label_beta_kubernetes_io_arch=\\\"amd64\\\" __meta_kubernetes_node_label_beta_kubernetes_io_os=\\\"linux\\\" __meta_kubernetes_node_label_kubernetes_io_hostname=\\\"minikube\\\" __meta_kubernetes_node_name=\\\"minikube\\\" __metrics_path__=\\\"/metrics\\\" __scheme__=\\\"https\\\" instance=\\\"minikube\\\" job=\\\"kubernetes-nodes\\\" \",\"其中__address__默认为当前节点上运行的kubelet的访问地址。从上面的结果可以看出，通过node动态发现的Target会包含如下几类标签：\",\"__meta_kubernetes_node_name：该节点在集群中的名称；\",\"__meta_kubernetes_node_label_<labelname>：该节点中包含的用户自定义标签以及Kubernetes自动生成的标签；\",\"__meta_kubernetes_node_annotation_<annotationname>：该节点中包含的Kubernetes自动生成的注解信息；\",\"__meta_kubernetes_node_address_<address_type>：该节点各种类型（NodeInternalIP，NodeExternalIP，NodeLegacyHostIP，NodeHostName）的访问地址。\",\"用户也可以通过以下命令查看节点的详细信息：\",\"$ kubectl get nodes/minikube -o yaml \"]},\"190\":{\"h\":\"使用Relabeling修改采集任务\",\"t\":[\"为了能够通过Prometheus采集到cAdvisor的metrics服务，我们为cAdvisor定义了单独采集任务。该任务将基于Node模式发现集群中所有的节点，并通过Relabel修改Target的数据采集配置，从而获取到cAdvisor的监控数据，修改prometheus-config.yml如下：\",\"apiVersion: v1 kind: ConfigMap metadata: name: prometheus-config data: prometheus.yml: |- global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: 'kubernetes-cadvisor' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - source_labels: [__address__] regex: (.+):(.+) action: replace target_label: __address__ replacement: $1:4194 - action: replace target_label: __scheme__ replacement: http - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"这里定义了三个relabel步骤：\",\"默认获取到的target地址为，当前节点中kubelet的访问地址。因此通过正则表达式(.+)😦.+)匹配出IP地址和端口，并将将匹配到的内容按照$1:4194的形式覆盖__address__的值。 从而获得cAdvisor访问地址；\",\"默认返回的__scheme__为https，通过直接修改其值为http，从而可以让Prometheus通过访问http://IP:4193/metrics作为采集目标地址；\",\"最后通过labelmap将该节点上的自定义标签，写入到样本中，从而可以方便用户通过这些标签对数据进行聚合。\",\"cAdvisor数据采集状态\",\"如上所示，Prometheus通过自动发现Node节点，并通过Relabel自定义采集方式后的结果。\",\"需要注意的是，通过集群中主机的4194端口获取cAdvisor数据，并不适用于Kubernetes集群，这种方式限制了cAdvisor服务的运行端口。除了直接访问各个节点的cAdvisor服务以外，我们还可以通过Kubernetes的API Server作为代理获取节点上的cAdvisor监控数据。\",\"除了直接访问cAdvisor监听的端口以外，更通用的方式是通过apiserver访问kubelet提供的/metrics/cadvisor接口获取cAdvisor的样本数据。例如，想要获取节点minikube上cAdvisor的监控数据可以使用ca证书和令牌在Kubernetes集群内访问以下地址获取：\",\"https://kubernetes.default.svc:443/api/v1/nodes/minikube/proxy/metrics/cadvisor \",\"因此，修改kubernetes-cadvisor的relabel配置，通过获取节点的__meta_kubernetes_node_name并重写__metrics_path__将采集任务地址重定向到apiserver的API地址：\",\" - job_name: 'kubernetes-cadvisor' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - target_label: __address__ replacement: kubernetes.default.svc:443 - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"如下图所示，Prometheus使用了访问地址后的任务采集状态：\",\"基于API Server获取cAdvisor监控数据状态\"]},\"191\":{\"h\":\"监控集群状态\",\"t\":[\"当使用Kubernetes管理一个多节点的集群中，除了需要关注集群中部署应用的运行状态和节点的资源使用情况以外，我们还应该关注Kubernetes本身的状态。Kubernetes作为一个中央化的任务调度系统，我们希望它能够相对较快的完成对用户操作的响应。在这一小节中，我们将利用Prometheus监控Kubernetes API的响应时间，从而评估当前集群的运行状态以及性能。\"]},\"192\":{\"h\":\"使用Prometheus采集API Server监控数据\",\"t\":[\"在Kubernetes集群中命名空间default中会包含一个名为kubernetes的默认Service:\",\"$ kubectl get svc kubernetes NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 133d \",\"该Service实际指向的是Kubernetes组件apiserver提供的服务：\",\"$ kubectl get endpoints kubernetes NAME ENDPOINTS AGE kubernetes 10.0.2.15:8443 133d \",\"Apiserver组件内置了对Prometheus的支持，因此只要通过CA证书和令牌访问https://kubernetes.default.svc:443/metrics即可获取apiserver组件中记录的所有监控样数据。\",\"了解以上基础知识以后，我们只需要对应修改Prometheus的配置文件即可。修改prometheus-config.yml文件，为Pometheus配置文件添加以下内容：\",\" - job_name: 'kubernetes-apiservers' kubernetes_sd_configs: - role: endpoints scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token relabel_configs: - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name] action: keep regex: default;kubernetes;https - target_label: __address__ replacement: kubernetes.default.svc:443 \",\"这里我们添加了一个新的监控采集任务kubernetes-apiservers，该任务基于endpoints模式获取当前集群中的所有endpoints，并且只保留default命名空间下的服务名称为kubernetes的实例作为监控对象。 由于基于ServiceAccount提供的CA证书中，并不包含Endpoint的地址，因此这里还需要将默认的__address__替换为集群内的DNS地址kubernetes.default.svc。\",\"基于以上服务发现以及relabel的过程后，Prometheus就能够正常的从apiserver中过去监控样本数据：\",\"Kubernetes APIServer任务采集状态\"]},\"193\":{\"h\":\"评估Kubernetes性能\",\"t\":[\"当Prometheus能够从Kubernetes的APIServer中获取监控样本数据后，就可以对当前Kubernetes集群的性能做出评估。无论是Kubernetes的自身组件还是客户端请求都需要经过Kubernetes的apiserver，因此在评估Kubernetes性能时，我们首先需要关注Kubernetes的API响应时间。对于Pod启动时间可以通过指标kubelet_pod_start_latency_microseconds获取。\",\"例如，通过以下PromQL获取当前集群99%的Pod启动时间大致在18.40s以内：\",\"kubelet_pod_start_latency_microseconds{quantile=\\\"0.99\\\"} \",\"99%的Pod启动时间\",\"Pod平均启动时间大致为42s左右（包含镜像下载时间）：\",\"kubelet_pod_start_latency_microseconds_sum / kubelet_pod_start_latency_microseconds_count \",\"Pod平均启动时间\",\"其次，对于用户而言，他们更关注通过容器启动服务所需的时间，因此，第二个关键指标即Pod的启动时间。指标apiserver_request_latencies_summary和apiserver_request_latencies_bucket均可用于统计以下各种类型API响应时间的分布情况：\",\"Action\",\"Resources\",\"PUT\",\"Pods, Nodes, Deployments, DaemonSets等\",\"POST\",\"Pods, Nodes, Deployments, DaemonSets等\",\"LIST\",\"Pods, Nodes, Deployments, DaemonSets等\",\"GET\",\"Pods, Nodes, Deployments, DaemonSets等\"]},\"194\":{\"h\":\"监控Service和Ingress可用性\",\"t\":[\"在第4章中我们介绍了如何基于Blackbox Exporter进行黑盒监控，黑盒监控侧重于从用户角度来测试服务的可用性。当用户在Kubernetes中部署应用程序时，为了能让程序之间能够相互访问，需要使用到Service。而如果，需要让Kubernetes集群外的用户能够访问访问集群内的应用，则需要使用到Ingress。\",\"Ingress和Service均扮演了负载均衡的角色，通过网络探针对Ingress和Service对应的服务进行监控，能够快速判断当前服务的可用性，并且在发生故障时能够即使的做出响应。\"]},\"195\":{\"h\":\"在Kubernetes下部署Blackbox Exporter\",\"t\":[\"如下所示，通过Deployment定义了一个单实例的Blackbox-exporter实例，并且为其定义了相应的Service。通过Service暴露的DNS地址，集群内的Prometheus能够非常简单的通过域名：blackbox-exporter.default.svc.cluster.local访问到Blackbox的实例：\",\" apiVersion: v1 kind: Service metadata: labels: app: blackbox-exporter name: blackbox-exporter spec: ports: - name: blackbox port: 9115 protocol: TCP selector: app: blackbox-exporter type: ClusterIP --- apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: app: blackbox-exporter name: blackbox-exporter spec: replicas: 1 selector: matchLabels: app: blackbox-exporter template: metadata: labels: app: blackbox-exporter spec: containers: - image: prom/blackbox-exporter name: blackbox-exporter \",\"通过kubectl命令，可以在Kubernetes集群中部署Blackbox Exporter实例:\",\"kubectl create -f blackbox-exporter-deployment.yml \",\"如下所示，在镜像prom/blackbox-exporter中包含了默认配置文件中定义了几个常用的探针配置：\",\"modules: http_2xx: prober: http http: http_post_2xx: prober: http http: method: POST tcp_connect: prober: tcp pop3s_banner: prober: tcp tcp: query_response: - expect: \\\"^+OK\\\" tls: true tls_config: insecure_skip_verify: false ssh_banner: prober: tcp tcp: query_response: - expect: \\\"^SSH-2.0-\\\" irc_banner: prober: tcp tcp: query_response: - send: \\\"NICK prober\\\" - send: \\\"USER prober prober prober :prober\\\" - expect: \\\"PING :([^ ]+)\\\" send: \\\"PONG ${1}\\\" - expect: \\\"^:[^ ]+ 001\\\" icmp: prober: icmp \"]},\"196\":{\"h\":\"探测Service可用性\",\"t\":[\" - job_name: 'kubernetes-services' metrics_path: /probe params: module: [http_2xx] kubernetes_sd_configs: - role: service relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__address__] target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.default.svc.cluster.local:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] target_label: kubernetes_name \"]},\"197\":{\"h\":\"探测Ingress可用性\",\"t\":[\" - job_name: 'kubernetes-ingresses' metrics_path: /probe params: module: [http_2xx] kubernetes_sd_configs: - role: ingress relabel_configs: - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path] regex: (.+);(.+);(.+) replacement: ${1}://${2}${3} target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.default.svc.cluster.local:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_ingress_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_ingress_name] target_label: kubernetes_name \"]},\"198\":{\"h\":\"使用Prometheus监控Kubernetes集群\",\"t\":[\"上一小节中，我们介绍了Prometheus在Kubernetes下的服务发现能力，并且通过kubernetes_sd_config实现了对Kubernetes下各类资源的自动发现。在本小节中，我们将带领读者利用Promethues提供的服务发现能力，实现对Kubernetes集群以及其中部署的各类资源的自动化监控。\",\"下表中，梳理了监控Kubernetes集群监控的各个维度以及策略：\",\"目标\",\"服务发现模式\",\"监控方法\",\"数据源\",\"从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标\",\"node\",\"白盒监控\",\"kubelet\",\"从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标\",\"node\",\"白盒监控\",\"kubelet\",\"从部署到各个节点的Node Exporter中采集主机资源相关的运行资源\",\"node\",\"白盒监控\",\"node exporter\",\"对于内置了Prometheus支持的应用，需要从Pod实例中采集其自定义监控指标\",\"pod\",\"白盒监控\",\"custom pod\",\"获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标\",\"endpoints\",\"白盒监控\",\"api server\",\"获取集群中Service的访问地址，并通过Blackbox Exporter获取网络探测指标\",\"service\",\"黑盒监控\",\"blackbox exporter\",\"获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标\",\"ingress\",\"黑盒监控\",\"blackbox exporter\"]},\"199\":{\"h\":\"从Kubelet获取节点运行状态\",\"t\":[\"Kubelet组件运行在Kubernetes集群的各个节点中，其负责维护和管理节点上Pod的运行状态。kubelet组件的正常运行直接关系到该节点是否能够正常的被Kubernetes集群正常使用。\",\"基于Node模式，Prometheus会自动发现Kubernetes中所有Node节点的信息并作为监控的目标Target。 而这些Target的访问地址实际上就是Kubelet的访问地址，并且Kubelet实际上直接内置了对Prometheus的支持。\",\"修改prometheus.yml配置文件，并添加以下采集任务配置：\",\" - job_name: 'kubernetes-kubelet' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"这里使用Node模式自动发现集群中所有Kubelet作为监控的数据采集目标，同时通过labelmap步骤，将Node节点上的标签，作为样本的标签保存到时间序列当中。\",\"重新加载promethues配置文件，并重建Prometheus的Pod实例后，查看kubernetes-kubelet任务采集状态，我们会看到以下错误提示信息：\",\"Get https://192.168.99.100:10250/metrics: x509: cannot validate certificate for 192.168.99.100 because it doesn't contain any IP SANs \",\"这是由于当前使用的ca证书中，并不包含192.168.99.100的地址信息。为了解决该问题，第一种方法是直接跳过ca证书校验过程，通过在tls_config中设置 insecure_skip_verify为true即可。 这样Prometheus在采集样本数据时，将会自动跳过ca证书的校验过程，从而从kubelet采集到监控数据：\",\" - job_name: 'kubernetes-kubelet' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt insecure_skip_verify: true bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"直接采集kubelet监控指标\",\"第二种方式，不直接通过kubelet的metrics服务采集监控数据，而通过Kubernetes的api-server提供的代理API访问各个节点中kubelet的metrics服务，如下所示：\",\" - job_name: 'kubernetes-kubelet' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) - target_label: __address__ replacement: kubernetes.default.svc:443 - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: /api/v1/nodes/${1}/proxy/metrics \",\"通过relabeling，将从Kubernetes获取到的默认地址__address__替换为kubernetes.default.svc:443。同时将__metrics_path__替换为api-server的代理地址/api/v1/nodes/${1}/proxy/metrics。\",\"通过api-server代理获取kubelet监控指标\",\"通过获取各个节点中kubelet的监控指标，用户可以评估集群中各节点的性能表现。例如,通过指标kubelet_pod_start_latency_microseconds可以获得当前节点中Pod启动时间相关的统计数据。\",\"kubelet_pod_start_latency_microseconds{quantile=\\\"0.99\\\"} \",\"99%的Pod启动时间\",\"Pod平均启动时间大致为42s左右（包含镜像下载时间）：\",\"kubelet_pod_start_latency_microseconds_sum / kubelet_pod_start_latency_microseconds_count \",\"Pod平均启动时间\",\"除此以外，监控指标kubelet_docker_*还可以体现出kubelet与当前节点的docker服务的调用情况，从而可以反映出docker本身是否会影响kubelet的性能表现等问题。\"]},\"200\":{\"h\":\"从Kubelet获取节点容器资源使用情况\",\"t\":[\"各节点的kubelet组件中除了包含自身的监控指标信息以外，kubelet组件还内置了对cAdvisor的支持。cAdvisor能够获取当前节点上运行的所有容器的资源使用情况，通过访问kubelet的/metrics/cadvisor地址可以获取到cadvisor的监控指标，因此和获取kubelet监控指标类似，这里同样通过node模式自动发现所有的kubelet信息，并通过适当的relabel过程，修改监控采集任务的配置。 与采集kubelet自身监控指标相似，这里也有两种方式采集cadvisor中的监控指标：\",\"方式一：直接访问kubelet的/metrics/cadvisor地址，需要跳过ca证书认证：\",\" - job_name: 'kubernetes-cadvisor' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt insecure_skip_verify: true bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: metrics/cadvisor - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"直接访问kubelet\",\"方式二：通过api-server提供的代理地址访问kubelet的/metrics/cadvisor地址：\",\" - job_name: 'kubernetes-cadvisor' scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token kubernetes_sd_configs: - role: node relabel_configs: - target_label: __address__ replacement: kubernetes.default.svc:443 - source_labels: [__meta_kubernetes_node_name] regex: (.+) target_label: __metrics_path__ replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"使用api-server代理\"]},\"201\":{\"h\":\"使用NodeExporter监控集群资源使用情况\",\"t\":[\"为了能够采集集群中各个节点的资源使用情况，我们需要在各节点中部署一个Node Exporter实例。在本章的“部署Prometheus”小节，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。而与Prometheus的部署不同的是，对于Node Exporter而言每个节点只需要运行一个唯一的实例，此时，就需要使用Kubernetes的另外一种控制器Daemonset。顾名思义，Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。\",\"创建node-exporter-daemonset.yml文件，并写入以下内容：\",\"apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: node-exporter spec: template: metadata: annotations: prometheus.io/scrape: 'true' prometheus.io/port: '9100' prometheus.io/path: 'metrics' labels: app: node-exporter name: node-exporter spec: containers: - image: prom/node-exporter imagePullPolicy: IfNotPresent name: node-exporter ports: - containerPort: 9100 hostPort: 9100 name: scrape hostNetwork: true hostPID: true \",\"由于Node Exporter需要能够访问宿主机，因此这里指定了hostNetwork和hostPID，让Pod实例能够以主机网络以及系统进程的形式运行。同时YAML文件中也创建了NodeExporter相应的Service。这样通过Service就可以访问到对应的NodeExporter实例。\",\"$ kubectl create -f node-exporter-daemonset.yml service \\\"node-exporter\\\" created daemonset \\\"node-exporter\\\" created \",\"查看Daemonset以及Pod的运行状态\",\"$ kubectl get daemonsets NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE node-exporter 1 1 1 1 1 <none> 15s $ kubectl get pods NAME READY STATUS RESTARTS AGE ... node-exporter-9h56z 1/1 Running 0 51s \",\"由于Node Exporter是以主机网络的形式运行，因此直接访问MiniKube的虚拟机IP加上Pod的端口即可访问当前节点上运行的Node Exporter实例:\",\"$ minikube ip 192.168.99.100 $ curl http://192.168.99.100:9100/metrics ... process_start_time_seconds 1.5251401593e+09 # HELP process_virtual_memory_bytes Virtual memory size in bytes. # TYPE process_virtual_memory_bytes gauge process_virtual_memory_bytes 1.1984896e+08 \",\"目前为止，通过Daemonset的形式将Node Exporter部署到了集群中的各个节点中。接下来，我们只需要通过Prometheus的pod服务发现模式，找到当前集群中部署的Node Exporter实例即可。 需要注意的是，由于Kubernetes中并非所有的Pod都提供了对Prometheus的支持，有些可能只是一些简单的用户应用，为了区分哪些Pod实例是可以供Prometheus进行采集的，这里我们为Node Exporter添加了注解：\",\"prometheus.io/scrape: 'true' \",\"由于Kubernetes中Pod可能会包含多个容器，还需要用户通过注解指定用户提供监控指标的采集端口：\",\"prometheus.io/port: '9100' \",\"而有些情况下，Pod中的容器可能并没有使用默认的/metrics作为监控采集路径，因此还需要支持用户指定采集路径：\",\"prometheus.io/path: 'metrics' \",\"为Prometheus创建监控采集任务kubernetes-pods，如下所示：\",\" - job_name: 'kubernetes-pods' kubernetes_sd_configs: - role: pod relabel_configs: - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: true - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ regex: (.+) - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port] action: replace regex: ([^:]+)(?::\\\\d+)?;(\\\\d+) replacement: $1:$2 target_label: __address__ - action: labelmap regex: __meta_kubernetes_pod_label_(.+) - source_labels: [__meta_kubernetes_namespace] action: replace target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_pod_name] action: replace target_label: kubernetes_pod_name \",\"通过Pod模式自动发现Node Exporter实例\",\"通过以上relabel过程实现对Pod实例的过滤，以及采集任务地址替换，从而实现对特定Pod实例监控指标的采集。需要说明的是kubernetes-pods并不是只针对Node Exporter而言，对于用户任意部署的Pod实例，只要其提供了对Prometheus的支持，用户都可以通过为Pod添加注解的形式为其添加监控指标采集的支持。\"]},\"202\":{\"h\":\"从kube-apiserver获取集群运行监控指标\",\"t\":[\"在开始正式内容之前，我们需要先了解一下Kubernetes中Service是如何实现负载均衡的，如下图所示，一般来说Service有两个主要的使用场景：\",\"Service负载均衡\",\"代理对集群内部应用Pod实例的请求：当创建Service时如果指定了标签选择器，Kubernetes会监听集群中所有的Pod变化情况，通过Endpoints自动维护满足标签选择器的Pod实例的访问信息；\",\"代理对集群外部服务的请求：当创建Service时如果不指定任何的标签选择器，此时需要用户手动创建Service对应的Endpoint资源。例如，一般来说，为了确保数据的安全，我们通常讲数据库服务部署到集群外。 这是为了避免集群内的应用硬编码数据库的访问信息，这是就可以通过在集群内创建Service，并指向外部的数据库服务实例。\",\"kube-apiserver扮演了整个Kubernetes集群管理的入口的角色，负责对外暴露Kubernetes API。kube-apiserver组件一般是独立部署在集群外的，为了能够让部署在集群内的应用（kubernetes插件或者用户应用）能够与kube-apiserver交互，Kubernetes会默认在命名空间下创建一个名为kubernetes的服务，如下所示：\",\"$ kubectl get svc kubernetes -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 166d <none> \",\"而该kubernetes服务代理的后端实际地址通过endpoints进行维护，如下所示：\",\"$ kubectl get endpoints kubernetes NAME ENDPOINTS AGE kubernetes 10.0.2.15:8443 166d \",\"通过这种方式集群内的应用或者系统主机就可以通过集群内部的DNS域名kubernetes.default.svc访问到部署外部的kube-apiserver实例。\",\"因此，如果我们想要监控kube-apiserver相关的指标，只需要通过endpoints资源找到kubernetes对应的所有后端地址即可。\",\"如下所示，创建监控任务kubernetes-apiservers，这里指定了服务发现模式为endpoints。Prometheus会查找当前集群中所有的endpoints配置，并通过relabel进行判断是否为apiserver对应的访问地址：\",\" - job_name: 'kubernetes-apiservers' kubernetes_sd_configs: - role: endpoints scheme: https tls_config: ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token relabel_configs: - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name] action: keep regex: default;kubernetes;https - target_label: __address__ replacement: kubernetes.default.svc:443 \",\"在relabel_configs配置中第一步用于判断当前endpoints是否为kube-apiserver对用的地址。第二步，替换监控采集地址到kubernetes.default.svc:443即可。重新加载配置文件，重建Prometheus实例，得到以下结果。\",\"apiserver任务状态\"]},\"203\":{\"h\":\"对Ingress和Service进行网络探测\",\"t\":[\"为了能够对Ingress和Service进行探测，我们需要在集群部署Blackbox Exporter实例。 如下所示，创建blackbox-exporter.yaml用于描述部署相关的内容:\",\" apiVersion: v1 kind: Service metadata: labels: app: blackbox-exporter name: blackbox-exporter spec: ports: - name: blackbox port: 9115 protocol: TCP selector: app: blackbox-exporter type: ClusterIP --- apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: app: blackbox-exporter name: blackbox-exporter spec: replicas: 1 selector: matchLabels: app: blackbox-exporter template: metadata: labels: app: blackbox-exporter spec: containers: - image: prom/blackbox-exporter imagePullPolicy: IfNotPresent name: blackbox-exporter \",\"通过kubectl命令部署Blackbox Exporter实例，这里将部署一个Blackbox Exporter的Pod实例，同时通过服务blackbox-exporter在集群内暴露访问地址blackbox-exporter.default.svc.cluster.local，对于集群内的任意服务都可以通过该内部DNS域名访问Blackbox Exporter实例：\",\"$ kubectl get pods NAME READY STATUS RESTARTS AGE blackbox-exporter-f77fc78b6-72bl5 1/1 Running 0 4s $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE blackbox-exporter ClusterIP 10.109.144.192 <none> 9115/TCP 3m \",\"为了能够让Prometheus能够自动的对Service进行探测，我们需要通过服务发现自动找到所有的Service信息。 如下所示，在Prometheus的配置文件中添加名为kubernetes-services的监控采集任务：\",\" - job_name: 'kubernetes-services' metrics_path: /probe params: module: [http_2xx] kubernetes_sd_configs: - role: service relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__address__] target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.default.svc.cluster.local:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] target_label: kubernetes_name \",\"在该任务配置中，通过指定kubernetes_sd_config的role为service指定服务发现模式：\",\" kubernetes_sd_configs: - role: service \",\"为了区分集群中需要进行探测的Service实例，我们通过标签‘prometheus.io/probe: true’进行判断，从而过滤出需要探测的所有Service实例：\",\" - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe] action: keep regex: true \",\"并且将通过服务发现获取到的Service实例地址__address__转换为获取监控数据的请求参数。同时将__address执行Blackbox Exporter实例的访问地址，并且重写了标签instance的内容：\",\" - source_labels: [__address__] target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.default.svc.cluster.local:9115 - source_labels: [__param_target] target_label: instance \",\"最后，为监控样本添加了额外的标签信息：\",\" - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] target_label: kubernetes_name \",\"对于Ingress而言，也是一个相对类似的过程，这里给出对Ingress探测的Prometheus任务配置作为参考：\",\" - job_name: 'kubernetes-ingresses' metrics_path: /probe params: module: [http_2xx] kubernetes_sd_configs: - role: ingress relabel_configs: - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe] action: keep regex: true - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path] regex: (.+);(.+);(.+) replacement: ${1}://${2}${3} target_label: __param_target - target_label: __address__ replacement: blackbox-exporter.default.svc.cluster.local:9115 - source_labels: [__param_target] target_label: instance - action: labelmap regex: __meta_kubernetes_ingress_label_(.+) - source_labels: [__meta_kubernetes_namespace] target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_ingress_name] target_label: kubernetes_name \"]},\"204\":{\"h\":\"监控集群基础设施\",\"t\":[\"在第1章的“初始Prometheus”小节，我们已经基本了解和使用过Node Exporter。Node Exporter能够采集和获取当前所在主机的运行状态数据。本节将带领读者在Kubernetes中部署Node Exporter，并且通过Prometheus自动监控集群中所有节点资源使用情况。\"]},\"205\":{\"h\":\"使用Daemonset部署Node Exporter\",\"t\":[\"在本章的“部署Prometheus”小节，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。而与Prometheus的部署不同的是，对于Node Exporter而言每个节点只运行一个唯一的实例，此时，就需要使用Kubernetes的另外一种控制器Daemonset。顾名思义，Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。\",\"创建node-exporter-daemonset.yml文件，并写入以下内容：\",\"apiVersion: v1 kind: Service metadata: annotations: prometheus.io/scrape: 'true' labels: app: node-exporter name: node-exporter name: node-exporter spec: ports: - name: scrape port: 9100 protocol: TCP selector: app: node-exporter type: ClusterIP --- apiVersion: extensions/v1beta1 kind: DaemonSet metadata: annotations: prometheus.io/scrape: 'true' name: node-exporter spec: template: metadata: labels: app: node-exporter name: node-exporter spec: containers: - image: prom/node-exporter name: node-exporter ports: - containerPort: 9100 hostPort: 9100 name: scrape hostNetwork: true hostPID: true \",\"由于Node Exporter需要能够访问宿主机，因此这里指定了hostNetwork和hostPID，让Pod实例能够以主机网络以及系统进程的形式运行。同时YAML文件中也创建了NodeExporter相应的Service。这样通过Service就可以访问到对应的NodeExporter实例。\",\"$ kubectl create -f node-exporter-daemonset.yml service \\\"node-exporter\\\" created daemonset \\\"node-exporter\\\" created \",\"查看Daemonset以及Pod的运行状态\",\"$ kubectl get daemonsets NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE node-exporter 1 1 1 1 1 <none> 15s $ kubectl get pods NAME READY STATUS RESTARTS AGE ... node-exporter-9h56z 1/1 Running 0 51s \",\"由于Node Exporter是以主机网络的形式运行，因此直接访问MiniKube的虚拟机IP加上Pod的端口即可访问当前节点上运行的Node Exporter实例:\",\"$ minikube ip 192.168.99.100 $ curl http://192.168.99.100:9100/metrics ... process_start_time_seconds 1.5251401593e+09 # HELP process_virtual_memory_bytes Virtual memory size in bytes. # TYPE process_virtual_memory_bytes gauge process_virtual_memory_bytes 1.1984896e+08 \"]},\"206\":{\"h\":\"Kubernetes下Service负载均衡原理\",\"t\":[\"在Kubernetes下Service是作为一个内部负载均衡器的存在，它对外暴露一个唯一访问地址（ClusterIP），后端则通过Endpoint指向多个Pod实例。\",\"Service负载均衡原理\",\"在Kubernetes中Service和Endpoint是两个独立的资源。如果创建Service的时，指定了Selector选择器。那么Kubernetes会自动根据选择器的去匹配Pod实例，并根据这些Pod的访问信息，自动创建Endpoint资源。\",\"例如，通过以下命令可以查看Node Exporter实例对应的IP地址：\",\"$ kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE node-exporter-st4cd 1/1 Running 0 4m 192.168.99.100 minikube \",\"由于Service中指定了标签选择器（app: node-exporter），Kubernetes就会自动找到该选择器对应的Pod实例的访问信息（这里是192.168.99.100：9100），并创建Service对应的Endpoint，通过以下命令查看：\",\"$ kubectl get endpoints node-exporter NAME ENDPOINTS AGE node-exporter 192.168.99.100:9100 4m \",\"最后查看Service的详细信息：\",\"$ kubectl describe svc node-exporter Name: node-exporter Namespace: default Labels: app=node-exporter name=node-exporter Annotations: prometheus.io/scrape=true Selector: app=node-exporter Type: ClusterIP IP: 10.100.42.83 Port: scrape 9100/TCP TargetPort: 9100/TCP Endpoints: 192.168.99.100:9100 Session Affinity: None Events: <none> \",\"将Service与Endpoint分离还带来另外一个好处，如果我们希望集群内的应用程序，能够通过Service的形式访问到集群外的资源（如，外部部署的MySQL）。这是我们可以创建一个不包含Selector的Service即可，并且手段创建该Service需要代理的外部服务即可。\",\"例如，创建服务mysql-production，并且指向集群外运行的MySQL服务：\",\"apiVersion: v1 kind: Service metadata: name: mysql-production spec: ports: - port: 3306 --- kind: Endpoints apiVersion: v1 metadata: name: mysql-production subsets: - addresses: - ip: 192.168.1.25 ports: - port: 3306 \"]},\"207\":{\"h\":\"使用Endpoint发现Node Exporter实例\",\"t\":[\"在了解了Kubernetes下Service与Endpoint的关系以后，\\b我们就能大概理解，在Kubernetes下部署应用程序时，通过Endpoint\\b是能够找到特定服务的多个访问地址的。这样我们就可以通过这些地址获取到相应的监控指标。 而Service作为负载均衡器，则适用于作为服务可用性的探测标准，因此可以将Blackbox与Service相结合，监控服务的可用性。\",\"在Prometheus中，通过设置kubernetes_sd_config的role为endpoints指定当前的服务发现模式：\",\"kubernetes_sd_configs: - role: endpoints \",\"不过，为了区分集群中哪些Endpoint是可以采集的，而哪些是不可以采集的，我们可以通过为Service添加特定的标签进行标记。例如，Node Exporter的Service中包含了自定义的注解：\",\"metadata: annotations: prometheus.io/scrape: 'true' \",\"通过Kubernetes获取到的Endpoint对象，如下所示，是通过Kubernetes自动发现的Endpoint对象的所有metadata标签：\",\"__address__=\\\"192.168.99.100:9100\\\" __meta_kubernetes_endpoint_port_name=\\\"scrape\\\" __meta_kubernetes_endpoint_port_protocol=\\\"TCP\\\" __meta_kubernetes_endpoint_ready=\\\"true\\\" __meta_kubernetes_endpoints_name=\\\"node-exporter\\\" __meta_kubernetes_namespace=\\\"default\\\" __meta_kubernetes_pod_container_name=\\\"node-exporter\\\" __meta_kubernetes_pod_container_port_name=\\\"scrape\\\" __meta_kubernetes_pod_container_port_number=\\\"9100\\\" __meta_kubernetes_pod_container_port_protocol=\\\"TCP\\\" __meta_kubernetes_pod_host_ip=\\\"192.168.99.100\\\" __meta_kubernetes_pod_ip=\\\"192.168.99.100\\\" __meta_kubernetes_pod_label_app=\\\"node-exporter\\\" __meta_kubernetes_pod_label_controller_revision_hash=\\\"4286002507\\\" __meta_kubernetes_pod_label_pod_template_generation=\\\"1\\\" __meta_kubernetes_pod_name=\\\"node-exporter-st4cd\\\" __meta_kubernetes_pod_node_name=\\\"minikube\\\" __meta_kubernetes_pod_ready=\\\"true\\\" __meta_kubernetes_pod_uid=\\\"7fe1c063-4ce5-11e8-a82a-08002717c1c9\\\" __meta_kubernetes_service_annotation_prometheus_io_scrape=\\\"true\\\" __meta_kubernetes_service_label_app=\\\"node-exporter\\\" __meta_kubernetes_service_label_name=\\\"node-exporter\\\" __meta_kubernetes_service_name=\\\"node-exporter\\\" __metrics_path__=\\\"/metrics\\\" __scheme__=\\\"http\\\" job=\\\"kubernetes-service-endpoints\\\" \",\"由于该Endpoint属于特定的Servie，并且backend指向了具体的Pod实例，所以返回的metadata标签中包含了关联的Service的信息（以__meta_kubernetes_service作为前缀）以及后端Pod的相关信息（以__meta_kubernetes_pod作为浅醉）。\",\"通过relabeling的keep模式，选择只获取包含了标签__meta_kubernetes_service_annotation_prometheus_io_scrape并且其值为true的Endpoint作为监控目标：\",\" - job_name: 'kubernetes-service-endpoints' kubernetes_sd_configs: - role: endpoints relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape] action: keep regex: true - source_labels: [__meta_kubernetes_endpoints_name] target_label: job \",\"Relabeling保留符合规则的Endpoint\",\"这种基于Service的annotations来控制Prometheus的方式，还可以扩展出更多的玩法。例如，如果应用程序并没有通过/metrics暴露监控样本数据。 下面是一个更完整的采集任务配置如下所示：\",\" - job_name: 'kubernetes-service-endpoints' kubernetes_sd_configs: - role: endpoints relabel_configs: - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape] action: keep regex: true - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme] action: replace target_label: __scheme__ regex: (https?) - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path] action: replace target_label: __metrics_path__ regex: (.+) - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port] action: replace target_label: __address__ regex: ([^:]+)(?::\\\\d+)?;(\\\\d+) replacement: $1:$2 - action: labelmap regex: __meta_kubernetes_service_label_(.+) - source_labels: [__meta_kubernetes_namespace] action: replace target_label: kubernetes_namespace - source_labels: [__meta_kubernetes_service_name] action: replace target_label: kubernetes_name - source_labels: [__meta_kubernetes_endpoints_name] target_label: job \",\"通过以上步骤，用户可以通过在Service添加注解的形式，更灵活的控制Prometheus的任务采集信息，例如，通过添加注解自定义采集数据的相关配置：\",\"apiVersion: v1 kind: Service metadata: annotations: prometheus.io/scrape: 'true' prometheus.io/scheme: 'https' prometheus.io/path: '/custom_metrics' \",\"通过Endpoint发现的Node Exporter实例\"]},\"208\":{\"h\":\"第9章 Prometheus Operator\",\"t\":[\"本章，我们将介绍如何使用Prometheus Operator简化在Kubernetes下部署和管理Prmetheus的复杂度。\",\"本章的主要内容：\",\"为什么需要使用Prometheus Operator\",\"Prometheus Operator的主要概念\",\"如何利用Prometheus Operator自动化运维Prometheus\",\"如何使用Prometheus Operator自动化管理监控配置\"]},\"209\":{\"h\":\"小结\",\"t\":[\"在本章中，我们介绍了在Kubernetes下如何使用Operator来有状态的运维和管理Prometheus以及Alertmanager等组件。\"]},\"210\":{\"h\":\"在Prometheus Operator中使用自定义配置\",\"t\":[\"在Prometheus Operator我们通过声明式的创建如Prometheus, ServiceMonitor这些自定义的资源类型来自动化部署和管理Prometheus的相关组件以及配置。而在一些特殊的情况下，对于用户而言，可能还是希望能够手动管理Prometheus配置文件，而非通过Prometheus Operator自动完成。 为什么？ 实际上Prometheus Operator对于Job的配置只适用于在Kubernetes中部署和管理的应用程序。如果你希望使用Prometheus监控一些其他的资源，例如AWS或者其他平台中的基础设施或者应用，这些并不在Prometheus Operator的能力范围之内。\",\"为了能够在通过Prometheus Operator创建的Prometheus实例中使用自定义配置文件，我们只能创建一个不包含任何与配置文件内容相关的Prometheus实例\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst-cc namespace: monitoring spec: serviceAccountName: prometheus resources: requests: memory: 400Mi \",\"将以上内容保存到prometheus-inst-cc.yaml文件中，并且通过kubectl创建:\",\"$ kubectl -n monitoring create -f prometheus-inst-cc.yaml prometheus.monitoring.coreos.com/inst-cc created \",\"如果查看新建Prometheus的Pod实例YAML定义，我们可以看到Pod中会包含一个volume配置：\",\"volumes: - name: config secret: defaultMode: 420 secretName: prometheus-inst-cc \",\"Prometheus的配置文件实际上是保存在名为prometheus-<name-of-prometheus-object>的Secret中，当用户创建的Prometheus中关联ServiceMonitor这类会影响配置文件内容的定义时，Promethues Operator会自动管理。而如果Prometheus定义中不包含任何与配置相关的定义，那么Secret的管理权限就落到了用户自己手中。\",\"通过修改prometheus-inst-cc的内容，从而可以让用户可以使用自定义的Prometheus配置文件，作为示例，我们创建一个prometheus.yaml文件并添加以下内容：\",\"global: scrape_interval: 10s scrape_timeout: 10s evaluation_interval: 10s \",\"生成文件内容的base64编码后的内容：\",\"$ cat prometheus.yaml | base64 Z2xvYmFsOgogIHNjcmFwZV9pbnRlcnZhbDogMTBzCiAgc2NyYXBlX3RpbWVvdXQ6IDEwcwogIGV2YWx1YXRpb25faW50ZXJ2YWw6IDEwcw== \",\"修改名为prometheus-inst-cc的Secret内容，如下所示：\",\"$ kubectl -n monitoring edit secret prometheus-inst-cc # 省略其它内容 data: prometheus.yaml: \\\"Z2xvYmFsOgogIHNjcmFwZV9pbnRlcnZhbDogMTBzCiAgc2NyYXBlX3RpbWVvdXQ6IDEwcwogIGV2YWx1YXRpb25faW50ZXJ2YWw6IDEwcw==\\\" \",\"通过port-forward在本地访问新建的Prometheus实例，观察配置文件变化即可：\",\"kubectl -n monitoring port-forward statefulsets/prometheus-inst-cc 9091:9090 \"]},\"211\":{\"h\":\"\"},\"212\":{\"h\":\"使用Operator管理告警\"},\"213\":{\"h\":\"使用PrometheusRule定义告警规则\",\"t\":[\"对于Prometheus而言，在原生的管理方式上，我们需要手动创建Prometheus的告警文件，并且通过在Prometheus配置中声明式的加载。而在Prometheus Operator模式中，告警规则也编程一个通过Kubernetes API 声明式创建的一个资源，如下所示：\",\"apiVersion: monitoring.coreos.com/v1 kind: PrometheusRule metadata: labels: prometheus: example role: alert-rules name: prometheus-example-rules spec: groups: - name: ./example.rules rules: - alert: ExampleAlert expr: vector(1) \",\"将以上内容保存为example-rule.yaml文件，并且通过kubectl命令创建相应的资源：\",\"$ kubectl -n monitoring create -f example-rule.yaml prometheusrule \\\"prometheus-example-rules\\\" created \",\"告警规则创建成功后，通过在Prometheus中使用ruleSelector通过选择需要关联的PrometheusRule即可：\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst namespace: monitoring spec: serviceAccountName: prometheus serviceMonitorSelector: matchLabels: team: frontend ruleSelector: matchLabels: role: alert-rules prometheus: example resources: requests: memory: 400Mi \",\"Prometheus重新加载配置后，从UI中我们可以查看到通过PrometheusRule自动创建的告警规则配置：\",\"Prometheus告警规则\",\"如果查看Alerts页面，我们会看到告警已经处于触发状态。\"]},\"214\":{\"h\":\"使用Operator管理Alertmanager实例\",\"t\":[\"到目前为止，我们已经通过Prometheus Operator的自定义资源类型管理了Prometheus的实例，监控配置以及告警规则等资源。通过Prometheus Operator将原本手动管理的工作全部变成声明式的管理模式，大大简化了Kubernetes下的Prometheus运维管理的复杂度。 接下来，我们将继续使用Prometheus Operator定义和管理Alertmanager相关的内容。\",\"为了通过Prometheus Operator管理Alertmanager实例，用户可以通过自定义资源Alertmanager进行定义，如下所示，通过replicas可以控制Alertmanager的实例数：\",\"apiVersion: monitoring.coreos.com/v1 kind: Alertmanager metadata: name: inst namespace: monitoring spec: replicas: 3 \",\"当replicas大于1时，Prometheus Operator会自动通过集群的方式创建Alertmanager。将以上内容保存为文件alertmanager-inst.yaml，并通过以下命令创建：\",\"$ kubectl -n monitoring create -f alertmanager-inst.yaml alertmanager.monitoring.coreos.com/inst created \",\"查看Pod的情况如下所示，我们会发现Alertmanager的Pod实例一直处于ContainerCreating的状态中:\",\"$ kubectl -n monitoring get pods NAME READY STATUS RESTARTS AGE alertmanager-inst-0 0/2 ContainerCreating 0 32s \",\"通过kubectl describe命令查看该Alertmanager的Pod实例状态，可以看到类似于以下内容的告警信息：\",\"MountVolume.SetUp failed for volume \\\"config-volume\\\" : secrets \\\"alertmanager-inst\\\" not found \",\"这是由于Prometheus Operator通过Statefulset的方式创建的Alertmanager实例，在默认情况下，会通过alertmanager-{ALERTMANAGER_NAME}的命名规则去查找Secret配置并以文件挂载的方式，将Secret的内容作为配置文件挂载到Alertmanager实例当中。因此，这里还需要为Alertmanager创建相应的配置内容，如下所示，是Alertmanager的配置文件：\",\"global: resolve_timeout: 5m route: group_by: ['job'] group_wait: 30s group_interval: 5m repeat_interval: 12h receiver: 'webhook' receivers: - name: 'webhook' webhook_configs: - url: 'http://alertmanagerwh:30500/' \",\"将以上内容保存为文件alertmanager.yaml，并且通过以下命令创建名为alrtmanager-inst的Secret资源：\",\"$ kubectl -n monitoring create secret generic alertmanager-inst --from-file=alertmanager.yaml secret/alertmanager-inst created \",\"在Secret创建成功后，查看当前Alertmanager Pod实例状态。如下所示：\",\"$ kubectl -n monitoring get pods NAME READY STATUS RESTARTS AGE alertmanager-inst-0 2/2 Running 0 5m alertmanager-inst-1 2/2 Running 0 52s alertmanager-inst-2 2/2 Running 0 37s \",\"使用port-forward将Alertmanager映射到本地：\",\"$ kubectl -n monitoring port-forward statefulsets/alertmanager-inst 9093:9093 \",\"访问http://localhost:9093/#/status，并查看当前集群状态：\",\"Alertmanager集群状态\",\"接下来，我们只需要修改我们的Prometheus资源定义，通过alerting指定使用的Alertmanager资源即可：\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst namespace: monitoring spec: serviceAccountName: prometheus serviceMonitorSelector: matchLabels: team: frontend ruleSelector: matchLabels: role: alert-rules prometheus: example alerting: alertmanagers: - name: alertmanager-example namespace: monitoring port: web resources: requests: memory: 400Mi \",\"等待Prometheus重新加载后，我们可以看到Prometheus Operator在配置文件中添加了以下配置：\",\" alertmanagers: - kubernetes_sd_configs: - role: endpoints namespaces: names: - monitoring scheme: http path_prefix: / timeout: 10s relabel_configs: - source_labels: [__meta_kubernetes_service_name] separator: ; regex: alertmanager-example replacement: $1 action: keep - source_labels: [__meta_kubernetes_endpoint_port_name] separator: ; regex: web replacement: $1 action: keep \",\"通过服务发现规则将Prometheus与Alertmanager进行了自动关联。\"]},\"215\":{\"h\":\"使用Operator管理Prometheus\"},\"216\":{\"h\":\"创建Prometheus实例\",\"t\":[\"当集群中已经安装Prometheus Operator之后，对于部署Prometheus Server实例就变成了声明一个Prometheus资源，如下所示，我们在Monitoring命名空间下创建一个Prometheus实例：\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst namespace: monitoring spec: resources: requests: memory: 400Mi \",\"将以上内容保存到prometheus-inst.yaml文件，并通过kubectl进行创建：\",\"$ kubectl create -f prometheus-inst.yaml prometheus.monitoring.coreos.com/inst-1 created \",\"此时，查看monitoring命名空间下的statefulsets资源，可以看到Prometheus Operator自动通过Statefulset创建的Prometheus实例：\",\"$ kubectl -n monitoring get statefulsets NAME DESIRED CURRENT AGE prometheus-inst 1 1 1m \",\"查看Pod实例：\",\"$ kubectl -n monitoring get pods NAME READY STATUS RESTARTS AGE prometheus-inst-0 3/3 Running 1 1m prometheus-operator-6db8dbb7dd-2hz55 1/1 Running 0 45m \",\"通过port-forward访问Prometheus实例:\",\"$ kubectl -n monitoring port-forward statefulsets/prometheus-inst 9090:9090 \",\"通过http://localhost:9090可以在本地直接打开Prometheus Operator创建的Prometheus实例。查看配置信息，可以看到目前Operator创建了只包含基本配置的Prometheus实例：\"]},\"217\":{\"h\":\"使用ServiceMonitor管理监控配置\",\"t\":[\"修改监控配置项也是Prometheus下常用的运维操作之一，为了能够自动化的管理Prometheus的配置，Prometheus Operator使用了自定义资源类型ServiceMonitor来描述监控对象的信息。\",\"这里我们首先在集群中部署一个示例应用，将以下内容保存到example-app.yaml，并使用kubectl命令行工具创建：\",\"kind: Service apiVersion: v1 metadata: name: example-app labels: app: example-app spec: selector: app: example-app ports: - name: web port: 8080 --- apiVersion: apps/v1 kind: Deployment metadata: name: example-app spec: selector: matchLabels: app: example-app replicas: 3 template: metadata: labels: app: example-app spec: containers: - name: example-app image: fabxc/instrumented_app ports: - name: web containerPort: 8080 \",\"示例应用会通过Deployment创建3个Pod实例，并且通过Service暴露应用访问信息。\",\"$ kubectl get pods NAME READY STATUS RESTARTS AGE example-app-94c8bc8-l27vx 2/2 Running 0 1m example-app-94c8bc8-lcsrm 2/2 Running 0 1m example-app-94c8bc8-n6wp5 2/2 Running 0 1m \",\"在本地同样通过port-forward访问任意Pod实例\",\"$ kubectl port-forward deployments/example-app 8080:8080 \",\"访问本地的http://localhost:8080/metrics实例应用程序会返回以下样本数据：\",\"# TYPE codelab_api_http_requests_in_progress gauge codelab_api_http_requests_in_progress 3 # HELP codelab_api_request_duration_seconds A histogram of the API HTTP request durations in seconds. # TYPE codelab_api_request_duration_seconds histogram codelab_api_request_duration_seconds_bucket{method=\\\"GET\\\",path=\\\"/api/bar\\\",status=\\\"200\\\",le=\\\"0.0001\\\"} 0 \",\"为了能够让Prometheus能够采集部署在Kubernetes下应用的监控数据，在原生的Prometheus配置方式中，我们在Prometheus配置文件中定义单独的Job，同时使用kubernetes_sd定义整个服务发现过程。而在Prometheus Operator中，则可以直接声明一个ServiceMonitor对象，如下所示：\",\"apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: example-app namespace: monitoring labels: team: frontend spec: namespaceSelector: matchNames: - default selector: matchLabels: app: example-app endpoints: - port: web \",\"通过定义selector中的标签定义选择监控目标的Pod对象，同时在endpoints中指定port名称为web的端口。默认情况下ServiceMonitor和监控对象必须是在相同Namespace下的。在本示例中由于Prometheus是部署在Monitoring命名空间下，因此为了能够关联default命名空间下的example对象，需要使用namespaceSelector定义让其可以跨命名空间关联ServiceMonitor资源。保存以上内容到example-app-service-monitor.yaml文件中，并通过kubectl创建：\",\"$ kubectl create -f example-app-service-monitor.yaml servicemonitor.monitoring.coreos.com/example-app created \",\"如果希望ServiceMonitor可以关联任意命名空间下的标签，则通过以下方式定义：\",\"spec: namespaceSelector: any: true \",\"如果监控的Target对象启用了BasicAuth认证，那在定义ServiceMonitor对象时，可以使用endpoints配置中定义basicAuth如下所示：\",\"apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: example-app namespace: monitoring labels: team: frontend spec: namespaceSelector: matchNames: - default selector: matchLabels: app: example-app endpoints: - basicAuth: password: name: basic-auth key: password username: name: basic-auth key: user port: web \",\"其中basicAuth中关联了名为basic-auth的Secret对象，用户需要手动将认证信息保存到Secret中:\",\"apiVersion: v1 kind: Secret metadata: name: basic-auth data: password: dG9vcg== # base64编码后的密码 user: YWRtaW4= # base64编码后的用户名 type: Opaque \"]},\"218\":{\"h\":\"关联Promethues与ServiceMonitor\",\"t\":[\"Prometheus与ServiceMonitor之间的关联关系使用serviceMonitorSelector定义，在Prometheus中通过标签选择当前需要监控的ServiceMonitor对象。修改prometheus-inst.yaml中Prometheus的定义如下所示： 为了能够让Prometheus关联到ServiceMonitor，需要在Pormtheus定义中使用serviceMonitorSelector，我们可以通过标签选择当前Prometheus需要监控的ServiceMonitor对象。修改prometheus-inst.yaml中Prometheus的定义如下所示：\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst namespace: monitoring spec: serviceMonitorSelector: matchLabels: team: frontend resources: requests: memory: 400Mi \",\"将对Prometheus的变更应用到集群中：\",\"$ kubectl -n monitoring apply -f prometheus-inst.yaml \",\"此时，如果查看Prometheus配置信息，我们会惊喜的发现Prometheus中配置文件自动包含了一条名为monitoring/example-app/0的Job配置：\",\"global: scrape_interval: 30s scrape_timeout: 10s evaluation_interval: 30s external_labels: prometheus: monitoring/inst prometheus_replica: prometheus-inst-0 alerting: alert_relabel_configs: - separator: ; regex: prometheus_replica replacement: $1 action: labeldrop rule_files: - /etc/prometheus/rules/prometheus-inst-rulefiles-0/*.yaml scrape_configs: - job_name: monitoring/example-app/0 scrape_interval: 30s scrape_timeout: 10s metrics_path: /metrics scheme: http kubernetes_sd_configs: - role: endpoints namespaces: names: - default relabel_configs: - source_labels: [__meta_kubernetes_service_label_app] separator: ; regex: example-app replacement: $1 action: keep - source_labels: [__meta_kubernetes_endpoint_port_name] separator: ; regex: web replacement: $1 action: keep - source_labels: [__meta_kubernetes_endpoint_address_target_kind, __meta_kubernetes_endpoint_address_target_name] separator: ; regex: Node;(.*) target_label: node replacement: ${1} action: replace - source_labels: [__meta_kubernetes_endpoint_address_target_kind, __meta_kubernetes_endpoint_address_target_name] separator: ; regex: Pod;(.*) target_label: pod replacement: ${1} action: replace - source_labels: [__meta_kubernetes_namespace] separator: ; regex: (.*) target_label: namespace replacement: $1 action: replace - source_labels: [__meta_kubernetes_service_name] separator: ; regex: (.*) target_label: service replacement: $1 action: replace - source_labels: [__meta_kubernetes_pod_name] separator: ; regex: (.*) target_label: pod replacement: $1 action: replace - source_labels: [__meta_kubernetes_service_name] separator: ; regex: (.*) target_label: job replacement: ${1} action: replace - separator: ; regex: (.*) target_label: endpoint replacement: web action: replace \",\"不过，如果细心的读者可能会发现，虽然Job配置有了，但是Prometheus的Target中并没包含任何的监控对象。查看Prometheus的Pod实例日志，可以看到如下信息：\",\"level=error ts=2018-12-15T12:52:48.452108433Z caller=main.go:240 component=k8s_client_runtime err=\\\"github.com/prometheus/prometheus/discovery/kubernetes/kubernetes.go:300: Failed to list *v1.Endpoints: endpoints is forbidden: User \\\\\\\"system:serviceaccount:monitoring:default\\\\\\\" cannot list endpoints in the namespace \\\\\\\"default\\\\\\\"\\\" \"]},\"219\":{\"h\":\"自定义ServiceAccount\",\"t\":[\"由于默认创建的Prometheus实例使用的是monitoring命名空间下的default账号，该账号并没有权限能够获取default命名空间下的任何资源信息。\",\"为了修复这个问题，我们需要在Monitoring命名空间下为创建一个名为Prometheus的ServiceAccount，并且为该账号赋予相应的集群访问权限。\",\"apiVersion: v1 kind: ServiceAccount metadata: name: prometheus namespace: monitoring --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: prometheus rules: - apiGroups: [\\\"\\\"] resources: - nodes - services - endpoints - pods verbs: [\\\"get\\\", \\\"list\\\", \\\"watch\\\"] - apiGroups: [\\\"\\\"] resources: - configmaps verbs: [\\\"get\\\"] - nonResourceURLs: [\\\"/metrics\\\"] verbs: [\\\"get\\\"] --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: prometheus roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: prometheus subjects: - kind: ServiceAccount name: prometheus namespace: monitoring \",\"将以上内容保存到prometheus-rbac.yaml文件中，并且通过kubectl创建相应资源：\",\"$ kubectl -n monitoring create -f prometheus-rbac.yaml serviceaccount/prometheus created clusterrole.rbac.authorization.k8s.io/prometheus created clusterrolebinding.rbac.authorization.k8s.io/prometheus created \",\"在完成ServiceAccount创建后，修改prometheus-inst.yaml，并添加ServiceAccount如下所示：\",\"apiVersion: monitoring.coreos.com/v1 kind: Prometheus metadata: name: inst namespace: monitoring spec: serviceAccountName: prometheus serviceMonitorSelector: matchLabels: team: frontend resources: requests: memory: 400Mi \",\"保存Prometheus变更到集群中：\",\"$ kubectl -n monitoring apply -f prometheus-inst.yaml prometheus.monitoring.coreos.com/inst configured \",\"等待Prometheus Operator完成相关配置变更后，此时查看Prometheus，我们就能看到当前Prometheus已经能够正常的采集实例应用的相关监控数据了。\"]},\"220\":{\"h\":\"什么是Prometheus Operator\",\"t\":[\"在第8章中，为了在Kubernetes能够方便的管理和部署Prometheus，我们使用ConfigMap了管理Prometheus配置文件。每次对Prometheus配置文件进行升级时，，我们需要手动移除已经运行的Pod实例，从而让Kubernetes可以使用最新的配置文件创建Prometheus。 而如果应用实例的数量更多时，通过手动的方式部署和升级Prometheus过程繁琐并且效率低下。\",\"从本质上来讲Prometheus属于是典型的有状态应用，而其有包含了一些自身特有的运维管理和配置管理方式。而这些都无法通过Kubernetes原生提供的应用管理概念实现自动化。为了简化这类应用程序的管理复杂度，CoreOS率先引入了Operator的概念，并且首先推出了针对在Kubernetes下运行和管理Etcd的Etcd Operator。并随后推出了Prometheus Operator。\"]},\"221\":{\"h\":\"Prometheus Operator的工作原理\",\"t\":[\"从概念上来讲Operator就是针对管理特定应用程序的，在Kubernetes基本的Resource和Controller的概念上，以扩展Kubernetes api的形式。帮助用户创建，配置和管理复杂的有状态应用程序。从而实现特定应用程序的常见操作以及运维自动化。\",\"在Kubernetes中我们使用Deployment、DamenSet，StatefulSet来管理应用Workload，使用Service，Ingress来管理应用的访问方式，使用ConfigMap和Secret来管理应用配置。我们在集群中对这些资源的创建，更新，删除的动作都会被转换为事件(Event)，Kubernetes的Controller Manager负责监听这些事件并触发相应的任务来满足用户的期望。这种方式我们成为声明式，用户只需要关心应用程序的最终状态，其它的都通过Kubernetes来帮助我们完成，通过这种方式可以大大简化应用的配置管理复杂度。\",\"而除了这些原生的Resource资源以外，Kubernetes还允许用户添加自己的自定义资源(Custom Resource)。并且通过实现自定义Controller来实现对Kubernetes的扩展。\",\"如下所示，是Prometheus Operator的架构示意图：\",\"Prometheus Operator架构\",\"Prometheus的本职就是一组用户自定义的CRD资源以及Controller的实现，Prometheus Operator负责监听这些自定义资源的变化，并且根据这些资源的定义自动化的完成如Prometheus Server自身以及配置的自动化管理工作。\"]},\"222\":{\"h\":\"Prometheus Operator能做什么\",\"t\":[\"要了解Prometheus Operator能做什么，其实就是要了解Prometheus Operator为我们提供了哪些自定义的Kubernetes资源，列出了Prometheus Operator目前提供的️4类资源：\",\"Prometheus：声明式创建和管理Prometheus Server实例；\",\"ServiceMonitor：负责声明式的管理监控配置；\",\"PrometheusRule：负责声明式的管理告警配置；\",\"Alertmanager：声明式的创建和管理Alertmanager实例。\",\"简言之，Prometheus Operator能够帮助用户自动化的创建以及管理Prometheus Server以及其相应的配置。\"]},\"223\":{\"h\":\"在Kubernetes集群中部署Prometheus Operator\",\"t\":[\"在Kubernetes中安装Prometheus Operator非常简单，用户可以从以下地址中过去Prometheus Operator的源码：\",\"git clone https://github.com/coreos/prometheus-operator.git \",\"这里，我们为Promethues Operator创建一个单独的命名空间monitoring：\",\"kubectl create namespace monitoring \",\"由于需要对Prometheus Operator进行RBAC授权，而默认的bundle.yaml中使用了default命名空间，因此，在安装Prometheus Operator之前需要先替换一下bundle.yaml文件中所有namespace定义，由default修改为monitoring。 通过运行一下命令安装Prometheus Operator的Deployment实例：\",\"$ kubectl -n monitoring apply -f bundle.yaml clusterrolebinding.rbac.authorization.k8s.io/prometheus-operator created clusterrole.rbac.authorization.k8s.io/prometheus-operator created deployment.apps/prometheus-operator created serviceaccount/prometheus-operator created service/prometheus-operator created \",\"Prometheus Operator通过Deployment的形式进行部署，为了能够让Prometheus Operator能够监听和管理Kubernetes资源同时也创建了单独的ServiceAccount以及相关的授权动作。\",\"查看Prometheus Operator部署状态，以确保已正常运行：\",\"$ kubectl -n monitoring get pods NAME READY STATUS RESTARTS AGE prometheus-operator-6db8dbb7dd-2hz55 1/1 Running 0 19s \"]},\"224\":{\"h\":\"第2章： 探索PromQL\",\"t\":[\"本章将带领读者探秘Prometheus的自定义查询语言PromQL。通过PromQL用户可以非常方便地对监控样本数据进行统计分析，PromQL支持常见的运算操作符，同时PromQL中还提供了大量的内置函数可以实现对数据的高级处理。当然在学习PromQL之前，用户还需要了解Prometheus的样本数据模型。PromQL作为Prometheus的核心能力除了实现数据的对外查询和展现，同时告警监控也是依赖PromQL实现的。\",\"本章的主要内容：\",\"Prometheus的数据模型\",\"Prometheus中监控指标的类型\",\"深入PromQL\",\"4个黄金指标和USE方法\"]},\"225\":{\"h\":\"小结\",\"t\":[\"PromQL是Prometheus的标准查询语句，通过强大的数据统计能力，使得将监控指标与实际业务进行关联成为可能。同时通过内置的预测函数，能够帮助用户将传统的面向结果转变为面向预测的方式。从而更有效的为业务和系统的正常运行保驾护航。\"]},\"226\":{\"h\":\"PromQL聚合操作\",\"t\":[\"Prometheus还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。\",\"sum (求和)\",\"min (最小值)\",\"max (最大值)\",\"avg (平均值)\",\"stddev (标准差)\",\"stdvar (标准方差)\",\"count (计数)\",\"count_values (对value进行计数)\",\"bottomk (后n条时序)\",\"topk (前n条时序)\",\"quantile (分位数)\",\"使用聚合操作的语法如下：\",\"<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)] \",\"其中只有count_values, quantile, topk, bottomk支持参数(parameter)。\",\"without用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过without和by可以按照样本的问题对数据进行聚合。\",\"例如：\",\"sum(http_requests_total) without (instance) \",\"等价于\",\"sum(http_requests_total) by (code,handler,job,method) \",\"如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：\",\"sum(http_requests_total) \",\"count_values用于时间序列中每一个样本值出现的次数。count_values会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。\",\"例如：\",\"count_values(\\\"count\\\", http_requests_total) \",\"topk和bottomk则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。\",\"获取HTTP请求数前5位的时序样本数据，可以使用表达式：\",\"topk(5, http_requests_total) \",\"quantile用于计算当前样本数据值的分布情况quantile(φ, express)其中0 ≤ φ ≤ 1。\",\"例如，当φ为0.5时，即表示找到当前样本数据中的中位数：\",\"quantile(0.5, http_requests_total) \"]},\"227\":{\"h\":\"Metric类型\",\"t\":[\"在上一小节中我们带领读者了解了Prometheus的底层数据模型，在Prometheus的存储实现上所有的监控样本都是以time-series的形式保存在Prometheus内存的TSDB（时序数据库）中，而time-series所对应的监控指标(metric)也是通过labelset进行唯一命名的。\",\"从存储上来讲所有的监控指标metric都是相同的，但是在不同的场景下这些metric又有一些细微的差异。 例如，在Node Exporter返回的样本中指标node_load1反应的是当前系统的负载状态，随着时间的变化这个指标返回的样本数据是在不断变化的。而指标node_cpu所获取到的样本数据却不同，它是一个持续增大的值，因为其反应的是CPU的累积使用时间，从理论上讲只要系统不关机，这个值是会无限变大的。\",\"为了能够帮助用户理解和区分这些不同监控指标之间的差异，Prometheus定义了4种不同的指标类型(metric type)：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）。\",\"在Exporter返回的样本数据中，其注释中也包含了该样本的类型。例如：\",\"# HELP node_cpu Seconds the cpus spent in each mode. # TYPE node_cpu counter node_cpu{cpu=\\\"cpu0\\\",mode=\\\"idle\\\"} 362812.7890625 \"]},\"228\":{\"h\":\"Counter：只增不减的计数器\",\"t\":[\"Counter类型的指标其工作方式和计数器一样，只增不减（除非系统发生重置）。常见的监控指标，如http_requests_total，node_cpu都是Counter类型的监控指标。 一般在定义Counter类型指标的名称时推荐使用_total作为后缀。\",\"Counter是一个简单但有强大的工具，例如我们可以在应用程序中记录某些事件发生的次数，通过以时序的形式存储这些数据，我们可以轻松的了解该事件产生速率的变化。 PromQL内置的聚合操作和函数可以让用户对这些数据进行进一步的分析：\",\"例如，通过rate()函数获取HTTP请求量的增长率：\",\"rate(http_requests_total[5m]) \",\"查询当前系统中，访问量前10的HTTP地址：\",\"topk(10, http_requests_total) \"]},\"229\":{\"h\":\"Gauge：可增可减的仪表盘\",\"t\":[\"与Counter不同，Gauge类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。常见指标如：node_memory_MemFree（主机当前空闲的内存大小）、node_memory_MemAvailable（可用内存大小）都是Gauge类型的监控指标。\",\"通过Gauge指标，用户可以直接查看系统的当前状态：\",\"node_memory_MemFree \",\"对于Gauge类型的监控指标，通过PromQL内置函数delta()可以获取样本在一段时间返回内的变化情况。例如，计算CPU温度在两个小时内的差异：\",\"delta(cpu_temp_celsius{host=\\\"zeus\\\"}[2h]) \",\"还可以使用deriv()计算样本的线性回归模型，甚至是直接使用predict_linear()对数据的变化趋势进行预测。例如，预测系统磁盘空间在4个小时之后的剩余情况：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[1h], 4 * 3600) \"]},\"230\":{\"h\":\"使用Histogram和Summary分析数据分布情况\",\"t\":[\"除了Counter和Gauge类型的监控指标以外，Prometheus还定义了Histogram和Summary的指标类型。Histogram和Summary主要用于统计和分析样本的分布情况。\",\"在大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms的响应时间范围内，而个别请求的响应时间需要5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，而这种现象被称为长尾问题。\",\"为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在010ms之间的请求数有多少而1020ms之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram和Summary都是为了能够解决这样问题的存在，通过Histogram和Summary类型的监控指标，我们可以快速了解监控样本的分布情况。\",\"例如，指标prometheus_tsdb_wal_fsync_duration_seconds的指标类型为Summary。 它记录了Prometheus Server中wal_fsync处理的处理时间，通过访问Prometheus Server的/metrics地址，可以获取到以下监控样本数据：\",\"# HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync. # TYPE prometheus_tsdb_wal_fsync_duration_seconds summary prometheus_tsdb_wal_fsync_duration_seconds{quantile=\\\"0.5\\\"} 0.012352463 prometheus_tsdb_wal_fsync_duration_seconds{quantile=\\\"0.9\\\"} 0.014458005 prometheus_tsdb_wal_fsync_duration_seconds{quantile=\\\"0.99\\\"} 0.017316173 prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002 prometheus_tsdb_wal_fsync_duration_seconds_count 216 \",\"从上面的样本中可以得知当前Prometheus Server进行wal_fsync操作的总次数为216次，耗时2.888716127000002s。其中中位数（quantile=0.5）的耗时为0.012352463，9分位数（quantile=0.9）的耗时为0.014458005s。\",\"在Prometheus Server自身返回的样本数据中，我们还能找到类型为Histogram的监控指标prometheus_tsdb_compaction_chunk_range_bucket。\",\"# HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction # TYPE prometheus_tsdb_compaction_chunk_range histogram prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"100\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"400\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"1600\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"6400\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"25600\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"102400\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"409600\\\"} 0 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"1.6384e+06\\\"} 260 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"6.5536e+06\\\"} 780 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"2.62144e+07\\\"} 780 prometheus_tsdb_compaction_chunk_range_bucket{le=\\\"+Inf\\\"} 780 prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09 prometheus_tsdb_compaction_chunk_range_count 780 \",\"与Summary类型的指标相似之处在于Histogram类型的样本同样会反应当前指标的记录的总数(以_count作为后缀)以及其值的总量（以_sum作为后缀）。不同在于Histogram指标直接反应了在不同区间内样本的个数，区间通过标签len进行定义。\",\"同时对于Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。不同在于Histogram通过histogram_quantile函数是在服务器端计算的分位数。 而Sumamry的分位数则是直接在客户端计算完成。因此对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。反之对于客户端而言Histogram消耗的资源更少。在选择这两种方式时用户应该按照自己的实际场景进行选择。\"]},\"231\":{\"h\":\"最佳实践：4个黄金指标和USE方法\",\"t\":[\"前面部分介绍了Prometheus的数据存储模型以及4种指标类型，同时Prometheus提供的强大的PromQL可以实现对数据的个性化处理。Prometheus基于指标提供了一个通用的监控解决方案。这里先思考一个基本的问题，在实现监控时，我们到底应该监控哪些对象以及哪些指标？\"]},\"232\":{\"h\":\"监控所有\",\"t\":[\"在之前Prometheus简介部分介绍监控的基本目标，首先是及时发现问题，其次是要能够快速对问题进行定位。对于传统监控解决方案而言，用户看到的依然是一个黑盒，用户无法真正了解系统的真正的运行状态。因此Prometheus鼓励用户监控所有的东西。\\b下面列举一些常用的监控维度。\",\"级别\",\"监控什么\",\"Exporter\",\"网络\",\"网络协议：http、dns、tcp、icmp；网络硬件：路由器，交换机等\",\"BlackBox Exporter;SNMP Exporter\",\"主机\",\"资源用量\",\"node exporter\",\"容器\",\"资源用量\",\"cAdvisor\",\"应用(包括Library)\",\"延迟，错误，QPS，内部状态等\",\"代码中集成Prmometheus Client\",\"中间件状态\",\"资源用量，以及服务状态\",\"代码中集成Prmometheus Client\",\"编排工具\",\"集群资源用量，调度等\",\"Kubernetes Components\"]},\"233\":{\"h\":\"监控模式\",\"t\":[\"除了上述介绍的不同监控级别以外。实际上根据不同的系统类型和目标，这里还有一些通用的套路和模式可以使用。\"]},\"234\":{\"h\":\"4个黄金指标\",\"t\":[\"Four Golden Signals是Google针对大量分布式监控的经验总结，4个黄金指标可以在服务级别帮助衡量终端用户体验、服务中断、业务影响等层面的问题。主要关注与以下四种类型的指标：延迟，通讯量，错误以及饱和度：\",\"延迟：服务请求所需时间。\",\"记录用户所有请求所需的时间，重点是要区分成功请求的延迟时间和失败请求的延迟时间。 例如在数据库或者其他关键祸端服务异常触发HTTP 500的情况下，用户也可能会很快得到请求失败的响应内容，如果不加区分计算这些请求的延迟，可能导致计算结果与实际结果产生巨大的差异。除此以外，在微服务中通常提倡“快速失败”，开发人员需要特别注意这些延迟较大的错误，因为这些缓慢的错误会明显影响系统的性能，因此追踪这些错误的延迟也是非常重要的。\",\"通讯量：监控当前系统的流量，用于衡量服务的容量需求。\",\"流量对于不同类型的系统而言可能代表不同的含义。例如，在HTTP REST API中, 流量通常是每秒HTTP请求数；\",\"错误：监控当前系统所有发生的错误请求，衡量当前系统错误发生的速率。\",\"对于失败而言有些是显式的(比如, HTTP 500错误)，而有些是隐式(比如，HTTP响应200，但实际业务流程依然是失败的)。\",\"对于一些显式的错误如HTTP 500可以通过在负载均衡器(如Nginx)上进行捕获，而对于一些系统内部的异常，则可能需要直接从服务中添加钩子统计并进行获取。\",\"饱和度：衡量当前服务的饱和度。\",\"主要强调最能影响服务状态的受限制的资源。 例如，如果系统主要受内存影响，那就主要关注系统的内存状态，如果系统主要受限于磁盘I/O，那就主要观测磁盘I/O的状态。因为通常情况下，当这些资源达到饱和后，服务的性能会明显下降。同时还可以利用饱和度对系统做出预测，比如，“磁盘是否可能在4个小时候就满了”。\"]},\"235\":{\"h\":\"RED方法\",\"t\":[\"RED方法是Weave Cloud在基于Google的“4个黄金指标”的原则下结合Prometheus以及Kubernetes容器实践，细化和总结的方法论，特别适合于云原生应用以及微服务架构应用的监控和度量。主要关注以下三种关键指标：\",\"(请求)速率：服务每秒接收的请求数。\",\"(请求)错误：每秒失败的请求数。\",\"(请求)耗时：每个请求的耗时。\",\"在“4大黄金信号”的原则下，RED方法可以有效的帮助用户衡量云原生以及微服务应用下的用户体验问题。\"]},\"236\":{\"h\":\"USE方法\",\"t\":[\"USE方法全称\\\"Utilization Saturation and Errors Method\\\"，主要用于分析系统性能问题，可以指导用户快速识别资源瓶颈以及错误的方法。正如USE方法的名字所表示的含义，USE方法主要关注与资源的：使用率(Utilization)、饱和度(Saturation)以及错误(Errors)。\",\"使用率：关注系统资源的使用情况。 这里的资源主要包括但不限于：CPU，内存，网络，磁盘等等。100%的使用率通常是系统性能瓶颈的标志。\",\"饱和度：例如CPU的平均运行排队长度，这里主要是针对资源的饱和度(注意，不同于4大黄金信号)。任何资源在某种程度上的饱和都可能导致系统性能的下降。\",\"错误：错误计数。例如：“网卡在数据包传输过程中检测到的以太网网络冲突了14次”。\",\"通过对资源以上指标持续观察，通过以下流程可以知道用户识别资源瓶颈：\",\"识别资源瓶颈\"]},\"237\":{\"h\":\"PromQL内置函数\",\"t\":[\"在上一小节中，我们已经看到了类似于irate()这样的函数，可以帮助我们计算监控指标的增长率。除了irate以外，Prometheus还提供了其它大量的内置函数，可以对时序数据进行丰富的处理。本小节将带读者了解一些常用的内置函数以及相关的使用场景和用法。\"]},\"238\":{\"h\":\"计算Counter指标增长率\",\"t\":[\"我们知道Counter类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观的表示样本数据的变化剧烈情况，需要计算样本的增长速率。\",\"如下图所示，样本增长率反映出了样本变化的剧烈程度：\",\"通过增长率表示样本的变化情况\",\"increase(v range-vector)函数是PromQL中提供的众多内置函数之一。其中参数v是一个区间向量，increase函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式Counter类型指标的增长率：\",\"increase(node_cpu[2m]) / 120 \",\"这里通过node_cpu[2m]获取时间序列最近两分钟的所有样本，increase计算出最近两分钟的增长量，最后除以时间120秒得到node_cpu样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均CPU使用率。\",\"除了使用increase函数以外，PromQL中还直接内置了rate(v range-vector)函数，rate函数可以直接计算区间向量v在时间窗口内平均增长速率。因此，通过以下表达式可以得到与increase函数相同的结果：\",\"rate(node_cpu[2m]) \",\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于主机而言在2分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。\",\"为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。\",\"irate(node_cpu[2m]) \",\"irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用rate函数。\"]},\"239\":{\"h\":\"预测Gauge指标变化趋势\",\"t\":[\"在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩512MB时向相关人员发送告警通知。 这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。 但是如果资源不是平滑变化的呢？ 比如有些某些业务增长，存储空间的增长速率提升了好几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。 因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。 那么还有没有更好的方法吗？\",\"PromQL中内置的predict_linear(v range-vector, t scalar) 函数可以帮助系统管理员更好的处理此类情况，predict_linear函数可以预测时间序列v在t秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于2小时的样本数据，来预测主机可用磁盘空间的是否在4个小时候被占满，可以使用如下表达式：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[2h], 4 * 3600) < 0 \"]},\"240\":{\"h\":\"统计Histogram指标的分位数\",\"t\":[\"在本章的第2小节中，我们介绍了Prometheus的四种监控指标类型，其中Histogram和Summary都可以用于统计和分析数据的分布情况。区别在于Summary是直接在客户端计算了数据分布的分位数情况。而Histogram的分位数计算需要通过histogram_quantile(φ float, b instant-vector)函数进行计算。其中φ（0<φ<1）表示需要计算的分位数，如果需要计算中位数φ取值为0.5，以此类推即可。\",\"以指标http_request_duration_seconds_bucket为例：\",\"# HELP http_request_duration_seconds request duration histogram # TYPE http_request_duration_seconds histogram http_request_duration_seconds_bucket{le=\\\"0.5\\\"} 0 http_request_duration_seconds_bucket{le=\\\"1\\\"} 1 http_request_duration_seconds_bucket{le=\\\"2\\\"} 2 http_request_duration_seconds_bucket{le=\\\"3\\\"} 3 http_request_duration_seconds_bucket{le=\\\"5\\\"} 3 http_request_duration_seconds_bucket{le=\\\"+Inf\\\"} 3 http_request_duration_seconds_sum 6 http_request_duration_seconds_count 3 \",\"当计算9分位数时，使用如下表达式：\",\"histogram_quantile(0.5, http_request_duration_seconds_bucket) \",\"通过对Histogram类型的监控指标，用户可以轻松获取样本数据的分布情况。同时分位数的计算，也可以非常方便的用于评判当前监控指标的服务水平。\",\"获取分布直方图的中位数\",\"需要注意的是通过histogram_quantile计算的分位数，并非为精确值，而是通过http_request_duration_seconds_bucket和http_request_duration_seconds_sum近似计算的结果。\"]},\"241\":{\"h\":\"动态标签替换\",\"t\":[\"一般来说来说，使用PromQL查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过up指标可以获取到当前所有运行的Exporter实例以及其状态：\",\"up{instance=\\\"localhost:8080\\\",job=\\\"cadvisor\\\"} 1 up{instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} 1 up{instance=\\\"localhost:9100\\\",job=\\\"node\\\"} 1 \",\"这是可视化工具渲染图标时可能根据，instance和job的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过label_replace标签为时间序列添加额外的标签。label_replace的具体参数如下：\",\"label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string) \",\"该函数会依次对v中的每一条时间序列进行处理，通过regex匹配src_label的值，并将匹配部分relacement写入到dst_label标签中。如下所示：\",\"label_replace(up, \\\"host\\\", \\\"$1\\\", \\\"instance\\\", \\\"(.*):.*\\\") \",\"函数处理后，时间序列将包含一个host标签，host标签的值为Exporter实例的IP地址：\",\"up{host=\\\"localhost\\\",instance=\\\"localhost:8080\\\",job=\\\"cadvisor\\\"} 1 up{host=\\\"localhost\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} 1 up{host=\\\"localhost\\\",instance=\\\"localhost:9100\\\",job=\\\"node\\\"} 1 \",\"除了label_replace以外，Prometheus还提供了label_join函数，该函数可以将时间序列中v多个标签src_label的值，通过separator作为连接符写入到一个新的标签dst_label中:\",\"label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...) \",\"label_replace和label_join函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。\"]},\"242\":{\"h\":\"其它内置函数\",\"t\":[\"除了上文介绍的这些内置函数以外，PromQL还提供了大量的其它内置函数。这些内置函数包括一些常用的数学计算、日期等等。这里就不一一细讲，感兴趣的读者可以通过阅读Prometheus的官方文档，了解这些函数的使用方式。\"]},\"243\":{\"h\":\"PromQL操作符\",\"t\":[\"使用PromQL除了能够方便的按照查询和过滤时间序列以外，PromQL还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，布尔运算符等等。\"]},\"244\":{\"h\":\"数学运算\",\"t\":[\"例如，我们可以通过指标node_memory_free_bytes_total获取当前主机可用的内存空间大小，其样本单位为Bytes。这时如果客户端要求使用MB作为单位响应数据，那只需要将查询到的时间序列的样本值进行单位换算即可：\",\"node_memory_free_bytes_total / (1024 * 1024) \",\"node_memory_free_bytes_total表达式会查询出所有满足表达式条件的时间序列，在上一小节中我们称该表达式为瞬时向量表达式，而返回的结果成为瞬时向量。\",\"当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用于瞬时向量中的每一个样本值，从而得到一组新的时间序列。\",\"而如果是瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果我们想根据node_disk_bytes_written和node_disk_bytes_read获取主机磁盘IO的总量，可以使用如下表达式：\",\"node_disk_bytes_written + node_disk_bytes_read \",\"那这个表达式是如何工作的呢？依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：\",\"{device=\\\"sda\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>1634967552@1518146427.807 + 864551424@1518146427.807 {device=\\\"sdb\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>0@1518146427.807 + 1744384@1518146427.807 \",\"PromQL支持的所有数学运算符如下所示：\",\"+ (加法)\",\"- (减法)\",\"* (乘法)\",\"/ (除法)\",\"% (求余)\",\"^ (幂运算)\"]},\"245\":{\"h\":\"使用布尔运算过滤时间序列\",\"t\":[\"在PromQL通过标签匹配模式，用户可以根据时间序列的特征维度对其进行查询。而布尔运算则支持用户根据时间序列中样本的值，对时间序列进行过滤。\",\"例如，通过数学运算符我们可以很方便的计算出，当前所有主机节点的内存使用率：\",\"(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total \",\"而系统管理员在排查问题的时候可能只想知道当前内存使用率超过95%的主机呢？通过使用布尔运算符可以方便的获取到该结果：\",\"(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total > 0.95 \",\"瞬时向量与标量进行布尔运算时，PromQL依次比较向量中的所有时间序列样本的值，如果比较结果为true则保留，反之丢弃。\",\"瞬时向量与瞬时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的\\b右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。\",\"目前，Prometheus支持以下布尔运算符如下：\",\"== (相等)\",\"!= (不相等)\",\"> (大于)\",\"< (小于)\",\">= (大于等于)\",\"<= (小于等于)\"]},\"246\":{\"h\":\"使用bool修饰符改变布尔运算符的行为\",\"t\":[\"布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的HTTP请求量是否>=1000，如果大于等于1000则返回1（true）否则返回0（false）。这时可以使用bool修饰符改变布尔运算的默认行为。 例如：\",\"http_requests_total > bool 1000 \",\"使用bool修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1。从而形成一条新的时间序列。\",\"http_requests_total{code=\\\"200\\\",handler=\\\"query\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 1 http_requests_total{code=\\\"200\\\",handler=\\\"query_range\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 0 \",\"同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用bool修饰符\",\"2 == bool 2 # 结果为1 \"]},\"247\":{\"h\":\"使用集合运算符\",\"t\":[\"使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。 通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。目前，Prometheus支持以下集合运算符：\",\"and (并且)\",\"or (或者)\",\"unless (排除)\",\"vector1 and vector2 会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素组成。\",\"vector1 or vector2 会产生一个新的向量，该向量包含vector1中所有的\\b样本数据，以及vector2中没有与vector1匹配到的样本数据。\",\"vector1 unless vector2 会产生一个新的向量，新向量中的元素由vector1中没有与vector2匹配的元素组成。\"]},\"248\":{\"h\":\"操作符优先级\",\"t\":[\"对于复杂类型的表达式，需要了解运算操作的运行优先级\",\"例如，查询主机的CPU使用率，可以使用表达式：\",\"100 * (1 - avg (irate(node_cpu{mode='idle'}[5m])) by(job) ) \",\"其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。关于内置函数的部分，会在下一节详细介绍。\",\"在PromQL操作符中优先级由高到低依次为：\",\"^\",\"*, /, %\",\"+, -\",\"==, !=, <=, <, >=, >\",\"and, unless\",\"or\"]},\"249\":{\"h\":\"匹配模式详解\",\"t\":[\"向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。\",\"接下来将介绍在PromQL中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。\"]},\"250\":{\"h\":\"一对一匹配\",\"t\":[\"一对一\\b匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：\",\"vector1 <operator> vector2 \",\"在操作符两边表达式标签不一致的情况下，可以使用on(label list)或者ignoring(label list）来修改标签的匹配行为。使用ignoreing可以在匹配时忽略某些标签。而on则用于将匹配行为限定在某些标签之内。\",\"<vector expr> <bin-op> ignoring(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) <vector expr> \",\"例如当存在样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用PromQL表达式：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。\",\"因此结果如下：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"同时由于method为put和del的\\b样本\\b找不到匹配项，因此不会出现在结果当中。\"]},\"251\":{\"h\":\"多对一和一对多\",\"t\":[\"多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与\\\"多\\\"侧的多个元素匹配的情况。在这种情况下，必须使用group修饰符：group_left或者group_right来确定哪一个向量具有更高的基数（充当“多”的角色）。\",\"<vector expr> <bin-op> ignoring(<label list>) group_left(<label list>) <vector expr> <vector expr> <bin-op> ignoring(<label list>) group_right(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) group_left(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) group_right(<label list>) <vector expr> \",\"多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用ignoring和on修饰符来排除或者限定匹配的标签列表。\",\"例如,使用表达式：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"该表达式中，左向量method_code:http_errors:rate5m包含两个标签method和code。而右向量method:http_requests:rate5m中只包含一个标签method，因此匹配时需要使用ignoring限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素，因此该表达式的匹配模式为多对一，需要使用group修饰符group_left指定左向量具有更好的基数。\",\"最终的运算结果如下：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \",\"提醒：group修饰符只能在比较和数学运算符中使用。在逻辑运算and,unless和or才注意操作中默认与右向量中的所有元素进行匹配。\"]},\"252\":{\"h\":\"在HTTP API中使用PromQL\",\"t\":[\"Prometheus当前稳定的HTTP API可以通过/api/v1访问。\"]},\"253\":{\"h\":\"API响应格式\",\"t\":[\"Prometheus API使用了JSON格式的响应内容。 当API调用成功后将会返回2xx的HTTP状态码。\",\"反之，当API调用失败时可能返回以下几种不同的HTTP状态码：\",\"404 Bad Request：当参数错误或者缺失时。\",\"422 Unprocessable Entity 当表达式无法执行时。\",\"503 Service Unavailiable 当请求超时或者被中断时。\",\"所有的API请求均使用以下的JSON格式：\",\"{ \\\"status\\\": \\\"success\\\" | \\\"error\\\", \\\"data\\\": <data>, // Only set if status is \\\"error\\\". The data field may still hold // additional data. \\\"errorType\\\": \\\"<string>\\\", \\\"error\\\": \\\"<string>\\\" } \"]},\"254\":{\"h\":\"在HTTP API中使用PromQL\",\"t\":[\"通过HTTP API我们可以分别通过/api/v1/query和/api/v1/query_range查询PromQL表达式当前或者一定时间范围内的计算结果。\"]},\"255\":{\"h\":\"瞬时数据查询\",\"t\":[\"通过使用QUERY API我们可以查询PromQL在特定时间点下的计算结果。\",\"GET /api/v1/query \",\"URL请求参数：\",\"query=<string>：PromQL表达式。\",\"time=<rfc3339 | unix_timestamp>：用于指定用于计算PromQL的时间戳。可选参数，默认情况下使用当前系统时间。\",\"timeout=<duration>：超时设置。可选参数，默认情况下使用-query,timeout的全局设置。\",\"例如使用以下表达式查询表达式up在时间点2015-07-01T20:10:51.781Z的计算结果：\",\"$ curl 'http://localhost:9090/api/v1/query?query=up&time=2015-07-01T20:10:51.781Z' { \\\"status\\\" : \\\"success\\\", \\\"data\\\" : { \\\"resultType\\\" : \\\"vector\\\", \\\"result\\\" : [ { \\\"metric\\\" : { \\\"__name__\\\" : \\\"up\\\", \\\"job\\\" : \\\"prometheus\\\", \\\"instance\\\" : \\\"localhost:9090\\\" }, \\\"value\\\": [ 1435781451.781, \\\"1\\\" ] }, { \\\"metric\\\" : { \\\"__name__\\\" : \\\"up\\\", \\\"job\\\" : \\\"node\\\", \\\"instance\\\" : \\\"localhost:9100\\\" }, \\\"value\\\" : [ 1435781451.781, \\\"0\\\" ] } ] } } \"]},\"256\":{\"h\":\"响应数据类型\",\"t\":[\"当API调用成功后，Prometheus会返回JSON格式的响应内容，格式如上小节所示。并且在data节点中返回查询结果。data节点格式如下：\",\"{ \\\"resultType\\\": \\\"matrix\\\" | \\\"vector\\\" | \\\"scalar\\\" | \\\"string\\\", \\\"result\\\": <value> } \",\"PromQL表达式可能返回多种数据类型，在响应内容中使用resultType表示当前返回的数据类型，包括：\",\"瞬时向量：vector\",\"当返回数据类型resultType为vector时，result响应格式如下：\",\"[ { \\\"metric\\\": { \\\"<label_name>\\\": \\\"<label_value>\\\", ... }, \\\"value\\\": [ <unix_time>, \\\"<sample_value>\\\" ] }, ... ] \",\"其中metrics表示当前时间序列的特征维度，value只包含一个唯一的样本。\",\"区间向量：matrix\",\"当返回数据类型resultType为matrix时，result响应格式如下：\",\"[ { \\\"metric\\\": { \\\"<label_name>\\\": \\\"<label_value>\\\", ... }, \\\"values\\\": [ [ <unix_time>, \\\"<sample_value>\\\" ], ... ] }, ... ] \",\"其中metrics表示当前时间序列的特征维度，values包含当前事件序列的一组样本。\",\"标量：scalar\",\"当返回数据类型resultType为scalar时，result响应格式如下：\",\"[ <unix_time>, \\\"<scalar_value>\\\" ] \",\"由于标量不存在时间序列一说，因此result表示为当前系统时间一个标量的值。\",\"字符串：string\",\"当返回数据类型resultType为string时，result响应格式如下：\",\"[ <unix_time>, \\\"<string_value>\\\" ] \",\"字符串类型的响应内容格式和标量相同。\"]},\"257\":{\"h\":\"区间数据查询\",\"t\":[\"使用QUERY_RANGE API我们则可以直接查询PromQL表达式在一段时间返回内的计算结果。\",\"GET /api/v1/query_range \",\"URL请求参数：\",\"query=<string>: PromQL表达式。\",\"start=<rfc3339 | unix_timestamp>: 起始时间。\",\"end=<rfc3339 | unix_timestamp>: 结束时间。\",\"step=<duration>: 查询步长。\",\"timeout=<duration>: 超时设置。可选参数，默认情况下使用-query,timeout的全局设置。\",\"当使用QUERY_RANGE API查询PromQL表达式时，返回结果一定是一个区间向量：\",\"{ \\\"resultType\\\": \\\"matrix\\\", \\\"result\\\": <value> } \",\"需要注意的是，在QUERY_RANGE API中PromQL只能使用瞬时向量选择器类型的表达式。\",\"例如使用以下表达式查询表达式up在30秒范围内以15秒为间隔计算PromQL表达式的结果。\",\"$ curl 'http://localhost:9090/api/v1/query_range?query=up&start=2015-07-01T20:10:30.781Z&end=2015-07-01T20:11:00.781Z&step=15s' { \\\"status\\\" : \\\"success\\\", \\\"data\\\" : { \\\"resultType\\\" : \\\"matrix\\\", \\\"result\\\" : [ { \\\"metric\\\" : { \\\"__name__\\\" : \\\"up\\\", \\\"job\\\" : \\\"prometheus\\\", \\\"instance\\\" : \\\"localhost:9090\\\" }, \\\"values\\\" : [ [ 1435781430.781, \\\"1\\\" ], [ 1435781445.781, \\\"1\\\" ], [ 1435781460.781, \\\"1\\\" ] ] }, { \\\"metric\\\" : { \\\"__name__\\\" : \\\"up\\\", \\\"job\\\" : \\\"node\\\", \\\"instance\\\" : \\\"localhost:9091\\\" }, \\\"values\\\" : [ [ 1435781430.781, \\\"0\\\" ], [ 1435781445.781, \\\"0\\\" ], [ 1435781460.781, \\\"1\\\" ] ] } ] } } \"]},\"258\":{\"h\":\"初识PromQL\",\"t\":[\"Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。\",\"PromQL是Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。并且被广泛应用在Prometheus的日常应用当中，包括对数据查询、可视化、告警处理当中。可以这么说，PromQL是Prometheus所有应用场景的基础，理解和掌握PromQL是Prometheus入门的第一课。\"]},\"259\":{\"h\":\"查询时间序列\",\"t\":[\"当Prometheus通过Exporter采集到相应的监控指标样本数据后，我们就可以通过PromQL对监控样本数据进行查询。\",\"当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如：\",\"http_requests_total \",\"等同于：\",\"http_requests_total{} \",\"该表达式会返回指标名称为http_requests_total的所有时间序列：\",\"http_requests_total{code=\\\"200\\\",handler=\\\"alerts\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"}=(20889@1518096812.326) http_requests_total{code=\\\"200\\\",handler=\\\"graph\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"}=(21287@1518096812.326) \",\"PromQL还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。\",\"PromQL支持使用=和!=两种完全匹配模式：\",\"通过使用label=value可以选择那些标签满足表达式定义的时间序列；\",\"反之使用label!=value则可以根据标签匹配排除时间序列；\",\"例如，如果我们只需要查询所有http_requests_total时间序列中满足标签instance为localhost:9090的时间序列，则可以使用如下表达式：\",\"http_requests_total{instance=\\\"localhost:9090\\\"} \",\"反之使用instance!=\\\"localhost:9090\\\"则可以排除这些时间序列：\",\"http_requests_total{instance!=\\\"localhost:9090\\\"} \",\"除了使用完全匹配的方式对时间序列进行过滤以外，PromQL还可以支持使用正则表达式作为匹配条件，多个表达式之间使用|进行分离：\",\"使用label=~regx表示选择那些标签符合正则表达式定义的时间序列；\",\"反之使用label!~regx进行排除；\",\"例如，如果想查询多个环节下的时间序列序列可以使用如下表达式：\",\"http_requests_total{environment=~\\\"staging|testing|development\\\",method!=\\\"GET\\\"} \"]},\"260\":{\"h\":\"范围查询\",\"t\":[\"直接通过类似于PromQL表达式http_requests_total查询时间序列时，会选择出所有属于该度量指标的时序的当前采样值，这样的返回结果我们称之为__瞬时向量__。而相应的这样的表达式称之为__瞬时向量表达式__。\",\"而如果我们想过去一段时间范围内的样本数据时，我们则需要使用__区间向量表达式__。区间向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：\",\"http_requests_total{}[5m] \",\"该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据：\",\"http_requests_total{code=\\\"200\\\",handler=\\\"alerts\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"}=[ 1@1518096812.326 1@1518096817.326 1@1518096822.326 1@1518096827.326 1@1518096832.326 1@1518096837.325 ] http_requests_total{code=\\\"200\\\",handler=\\\"graph\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"}=[ 4 @1518096812.326 4@1518096817.326 4@1518096822.326 4@1518096827.326 4@1518096832.326 4@1518096837.325 ] \",\"通过区间向量表达式查询到的结果我们称为__区间向量__。\",\"除了使用m表示分钟以外，PromQL的时间范围选择器支持其它时间单位：\",\"s - 秒\",\"m - 分钟\",\"h - 小时\",\"d - 天\",\"w - 周\",\"y - 年\"]},\"261\":{\"h\":\"时间位移操作\",\"t\":[\"在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：\",\"http_request_total{} # 瞬时向量表达式，选择当前最新的数据 http_request_total{}[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据 \",\"而如果我们想查询，5分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为offset。\",\"可以使用offset时间位移操作：\",\"http_request_total{} offset 5m http_request_total{}[1d] offset 1d \"]},\"262\":{\"h\":\"使用聚合操作\",\"t\":[\"一般来说，如果描述样本特征的标签(label)在并非唯一的情况下，通过PromQL查询数据，会返回多条满足这些特征维度的时间序列。而PromQL提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：\",\"# 查询系统所有http请求的总量 sum(http_request_total) # 按照mode计算主机CPU的平均使用时间 avg(node_cpu) by (mode) # 按照主机查询各个主机的CPU使用率 sum(sum(irate(node_cpu{mode!='idle'}[5m])) / sum(irate(node_cpu[5m]))) by (instance) \"]},\"263\":{\"h\":\"标量和字符串\",\"t\":[\"除了使用瞬时向量表达式和区间向量表达式以外，PromQL还直接支持用户使用标量(Scalar)和字符串(String)。\"]},\"264\":{\"h\":\"标量（Scalar）：一个浮点型的数字值\",\"t\":[\"标量只有一个数字，没有时序。\",\"例如：\",\"10 \",\"需要注意的是，当使用表达式count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数scalar()将单个瞬时向量转换为标量。\"]},\"265\":{\"h\":\"字符串（String）：一个简单的字符串值\",\"t\":[\"直接使用字符串，作为PromQL表达式，则会直接返回字符串。\",\"\\\"this is a string\\\" 'these are unescaped: \\\\n \\\\\\\\ \\\\t' `these are not unescaped: \\\\n ' \\\" \\\\t` \"]},\"266\":{\"h\":\"合法的PromQL表达式\",\"t\":[\"所有的PromQL表达式都必须至少包含一个指标名称(例如http_request_total)，或者一个不会匹配到空字符串的标签过滤器(例如{code=\\\"200\\\"})。\",\"因此以下两种方式，均为合法的表达式：\",\"http_request_total # 合法 http_request_total{} # 合法 {method=\\\"get\\\"} # 合法 \",\"而如下表达式，则不合法：\",\"{job=~\\\".*\\\"} # 不合法 \",\"同时，除了使用<metric name>{label=value}的形式以外，我们还可以使用内置的__name__标签来指定监控指标名称：\",\"{__name__=~\\\"http_request_total\\\"} # 合法 {__name__=~\\\"node_disk_bytes_read|node_disk_bytes_written\\\"} # 合法 \"]},\"267\":{\"h\":\"理解时间序列\",\"t\":[\"在1.2节当中，通过Node Exporter暴露的HTTP服务，Prometheus可以采集到当前主机所有监控指标的样本数据。例如：\",\"# HELP node_cpu Seconds the cpus spent in each mode. # TYPE node_cpu counter node_cpu{cpu=\\\"cpu0\\\",mode=\\\"idle\\\"} 362812.7890625 # HELP node_load1 1m load average. # TYPE node_load1 gauge node_load1 3.0703125 \",\"其中非#开头的每一行表示当前Node Exporter采集到的一个监控样本：node_cpu和node_load1表明了当前指标的名称、大括号中的标签则反映了当前样本的一些特征和维度、浮点数则是该监控样本的具体值。\"]},\"268\":{\"h\":\"样本\",\"t\":[\"Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector). 每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。如下所示，可以将time-series理解为一个以时间为Y轴的数字矩阵：\",\" ^ │ . . . . . . . . . . . . . . . . . . . node_cpu{cpu=\\\"cpu0\\\",mode=\\\"idle\\\"} │ . . . . . . . . . . . . . . . . . . . node_cpu{cpu=\\\"cpu0\\\",mode=\\\"system\\\"} │ . . . . . . . . . . . . . . . . . . node_load1{} │ . . . . . . . . . . . . . . . . . . v <------------------ 时间 ----------------> \",\"在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：\",\"指标(metric)：metric name和描述当前样本特征的labelsets;\",\"时间戳(timestamp)：一个精确到毫秒的时间戳;\",\"样本值(value)： 一个float64的浮点型数据表示当前样本的值。\",\"<--------------- metric ---------------------><-timestamp -><-value-> http_request_total{status=\\\"200\\\", method=\\\"GET\\\"}@1434417560938 => 94355 http_request_total{status=\\\"200\\\", method=\\\"GET\\\"}@1434417561287 => 94334 http_request_total{status=\\\"404\\\", method=\\\"GET\\\"}@1434417560938 => 38473 http_request_total{status=\\\"404\\\", method=\\\"GET\\\"}@1434417561287 => 38544 http_request_total{status=\\\"200\\\", method=\\\"POST\\\"}@1434417560938 => 4748 http_request_total{status=\\\"200\\\", method=\\\"POST\\\"}@1434417561287 => 4785 \"]},\"269\":{\"h\":\"指标(Metric)\",\"t\":[\"在形式上，所有的指标(Metric)都通过如下格式标示：\",\"<metric name>{<label name>=<label value>, ...} \",\"指标的名称(metric name)可以反映被监控样本的含义（比如，http_request_total - 表示当前系统接收到的HTTP请求总量）。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式[a-zA-Z_:][a-zA-Z0-9_:]*。\",\"标签(label)反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式[a-zA-Z_][a-zA-Z0-9_]*。\",\"其中以__作为前缀的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。在Prometheus的底层实现中指标名称实际上是以__name__=<metric name>的形式保存在数据库中的，因此以下两种方式均表示的同一条time-series：\",\"api_http_requests_total{method=\\\"POST\\\", handler=\\\"/messages\\\"} \",\"等同于：\",\"{__name__=\\\"api_http_requests_total\\\"，method=\\\"POST\\\", handler=\\\"/messages\\\"} \",\"在Prometheus源码中也可以找到指标(Metric)对应的数据结构，如下所示：\",\"type Metric LabelSet type LabelSet map[LabelName]LabelValue type LabelName string type LabelValue string \"]},\"270\":{\"h\":\"第1章： 天降奇兵\",\"t\":[\"本章作为全书的开篇，我们会带读者了解Prometheus的前世今生，Prometheus是如何从众多的监控平台中脱颖而出成为下一代监控系统的首选。同时通过一个简单的例子带领读者快速了解Prometheus是如何工作的，从而了解Prometheus中的一些概念以及架构模式。\",\"本章内容：\",\"Prometheus的前世今生\",\"使用Prometheus监控主机\",\"Prometheus的核心组件和概念\"]},\"271\":{\"h\":\"本章小结\",\"t\":[\"在这一章中，我们初步了解了Prometheus以及相比于其他相似方案的优缺点，可以为读者在选择监控解决方案时，提供一定的参考。同时我们介绍了Prometheus的生态以及核心能力，在本地使用Prometheus和NodeExporter搭建了一个主机监控的环境，并且对数据进行了聚合以及可视化，相信读者通过本章能够对Prometheus有一个直观的认识。\"]},\"272\":{\"h\":\"安装Prometheus Server\",\"t\":[\"Prometheus基于Golang编写，编译后的软件包，不依赖于任何的第三方依赖。用户只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动Prometheus Server。\"]},\"273\":{\"h\":\"从二进制包安装\",\"t\":[\"对于非Docker用户，可以从https://prometheus.io/download/找到最新版本的Prometheus Sevrer软件包：\",\"export VERSION=2.4.3 curl -LO https://github.com/prometheus/prometheus/releases/download/v$VERSION/prometheus-$VERSION.darwin-amd64.tar.gz \",\"解压，并将Prometheus相关的命令，添加到系统环境变量路径即可：\",\"tar -xzf prometheus-${VERSION}.darwin-amd64.tar.gz cd prometheus-${VERSION}.darwin-amd64 \",\"解压后当前目录会包含默认的Prometheus配置文件prometheus.yml:\",\"# my global config global: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s). # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 # Load rules once and periodically evaluate them according to the global 'evaluation_interval'. rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" # A scrape configuration containing exactly one endpoint to scrape: # Here it's Prometheus itself. scrape_configs: # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config. - job_name: 'prometheus' # metrics_path defaults to '/metrics' # scheme defaults to 'http'. static_configs: - targets: ['localhost:9090'] \",\"Prometheus作为一个时间序列数据库，其采集的数据会以文件的形式存储在本地中，默认的存储路径为data/，因此我们需要先手动创建该目录：\",\"mkdir -p data \",\"用户也可以通过参数--storage.tsdb.path=\\\"data/\\\"修改本地数据存储的路径。\",\"启动prometheus服务，其会默认加载当前路径下的prometheus.yaml文件：\",\"./prometheus \",\"正常的情况下，你可以看到以下输出内容：\",\"level=info ts=2018-10-23T14:55:14.499484Z caller=main.go:554 msg=\\\"Starting TSDB ...\\\" level=info ts=2018-10-23T14:55:14.499531Z caller=web.go:397 component=web msg=\\\"Start listening for connections\\\" address=0.0.0.0:9090 level=info ts=2018-10-23T14:55:14.507999Z caller=main.go:564 msg=\\\"TSDB started\\\" level=info ts=2018-10-23T14:55:14.508068Z caller=main.go:624 msg=\\\"Loading configuration file\\\" filename=prometheus.yml level=info ts=2018-10-23T14:55:14.509509Z caller=main.go:650 msg=\\\"Completed loading of configuration file\\\" filename=prometheus.yml level=info ts=2018-10-23T14:55:14.509537Z caller=main.go:523 msg=\\\"Server is ready to receive web requests.\\\" \"]},\"274\":{\"h\":\"使用容器安装\",\"t\":[\"对于Docker用户，直接使用Prometheus的镜像即可启动Prometheus Server：\",\"docker run -p 9090:9090 -v /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus \",\"启动完成后，可以通过http://localhost:9090访问Prometheus的UI界面：\",\"Prometheus UI\"]},\"275\":{\"h\":\"Prometheus组件\",\"t\":[\"上一小节，通过部署Node Exporter我们成功的获取到了当前主机的资源使用情况。接下来我们将从Prometheus的架构角度详细介绍Prometheus生态中的各个组件。\",\"下图展示Prometheus的基本架构：\",\"Prometheus架构\"]},\"276\":{\"h\":\"Prometheus Server\",\"t\":[\"Prometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询。 Prometheus Server可以通过静态配置管理监控目标，也可以配合使用Service Discovery的方式动态管理监控目标，并从这些监控目标中获取数据。其次Prometheus Server需要对采集到的监控数据进行存储，Prometheus Server本身就是一个时序数据库，将采集到的监控数据按照时间序列的方式存储在本地磁盘当中。最后Prometheus Server对外提供了自定义的PromQL语言，实现对数据的查询以及分析。\",\"Prometheus Server内置的Express Browser UI，通过这个UI可以直接通过PromQL实现数据的查询以及可视化。\",\"Prometheus Server的联邦集群能力可以使其从其他的Prometheus Server实例中获取数据，因此在大规模监控的情况下，可以通过联邦集群以及功能分区的方式对Prometheus Server进行扩展。\"]},\"277\":{\"h\":\"Exporters\",\"t\":[\"Exporter将监控数据采集的端点通过HTTP服务的形式暴露给Prometheus Server，Prometheus Server通过访问该Exporter提供的Endpoint端点，即可获取到需要采集的监控数据。\",\"一般来说可以将Exporter分为2类：\",\"直接采集：这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。\",\"间接采集：间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。\"]},\"278\":{\"h\":\"AlertManager\",\"t\":[\"在Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。在AlertManager中我们可以与邮件，Slack等等内置的通知方式进行集成，也可以通过Webhook自定义告警处理方式。AlertManager即Prometheus体系中的告警处理中心。\"]},\"279\":{\"h\":\"PushGateway\",\"t\":[\"由于Prometheus数据采集基于Pull模型进行设计，因此在网络环境的配置上必须要让Prometheus Server能够直接与Exporter进行通信。 当这种网络需求无法直接满足时，就可以利用PushGateway来进行中转。可以通过PushGateway将内部网络的监控数据主动Push到Gateway当中。而Prometheus Server则可以采用同样Pull的方式从PushGateway中获取到监控数据。\"]},\"280\":{\"h\":\"任务和实例\",\"t\":[\"在上一小节中，通过在prometheus.yml配置文件中，添加如下配置。我们让Prometheus可以从node exporter暴露的服务中获取监控指标数据。\",\"scrape_configs: - job_name: 'prometheus' static_configs: - targets: ['localhost:9090'] - job_name: 'node' static_configs: - targets: ['localhost:9100'] \",\"当我们需要采集不同的监控指标(例如：主机、MySQL、Nginx)时，我们只需要运行相应的监控采集程序，并且让Prometheus Server知道这些Exporter实例的访问地址。在Prometheus中，每一个暴露监控样本数据的HTTP服务称为一个实例。例如在当前主机上运行的node exporter可以被称为一个实例(Instance)。\",\"而一组用于相同采集目的的实例，或者同一个采集进程的多个副本则通过一个一个任务(Job)进行管理。\",\"* job: node * instance 2: 1.2.3.4:9100 * instance 4: 5.6.7.8:9100 \",\"当前在每一个Job中主要使用了静态配置(static_configs)的方式定义监控目标。除了静态配置每一个Job的采集Instance地址以外，Prometheus还支持与DNS、Consul、E2C、Kubernetes等进行集成实现自动发现Instance实例，并从这些Instance上获取监控数据。\",\"除了通过使用“up”表达式查询当前所有Instance的状态以外，还可以通过Prometheus UI中的Targets页面查看当前所有的监控采集任务，以及各个任务下所有实例的状态:\",\"target列表以及状态\",\"我们也可以访问http://192.168.33.10:9090/targets直接从Prometheus的UI中查看当前所有的任务以及每个任务对应的实例信息。\",\"Targets状态\"]},\"281\":{\"h\":\"初识Prometheus\",\"t\":[\"Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展。为了能够更加直观的了解Prometheus Server，接下来我们将在本地部署并运行一个Prometheus Server实例，通过Node Exporter采集当前主机的系统资源使用情况。 并通过Grafana创建一个简单的可视化仪表盘。\"]},\"282\":{\"h\":\"使用PromQL查询监控数据\",\"t\":[\"Prometheus UI是Prometheus内置的一个可视化管理界面，通过Prometheus UI用户能够轻松的了解Prometheus当前的配置，监控任务运行状态等。 通过Graph面板，用户还能直接使用PromQL实时查询监控数据：\",\"Graph Query\",\"切换到Graph面板，用户可以使用PromQL表达式查询特定监控指标的监控数据。如下所示，查询主机负载变化情况，可以使用关键字node_load1可以查询出Prometheus采集到的主机负载的样本数据，这些样本数据按照时间先后顺序展示，形成了主机负载随时间变化的趋势图表：\",\"主机负载情况\",\"PromQL是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。例如使用rate()函数，可以计算在单位时间内样本数据的变化情况即增长率，因此通过该函数我们可以近似的通过CPU使用时间计算CPU的利用率：\",\"rate(node_cpu[2m]) \",\"系统进程的CPU使用率\",\"这时如果要忽略是哪一个CPU的，只需要使用without表达式，将标签CPU去除后聚合数据即可：\",\"avg without(cpu) (rate(node_cpu[2m])) \",\"系统各mode的CPU使用率\",\"那如果需要计算系统CPU的总体使用率，通过排除系统闲置的CPU使用率即可获得:\",\"1 - avg without(cpu) (rate(node_cpu{mode=\\\"idle\\\"}[2m])) \",\"系统CPU使用率\",\"通过PromQL我们可以非常方便的对数据进行查询，过滤，以及聚合，计算等操作。通过这些丰富的表达书语句，监控指标不再是一个单独存在的个体，而是一个个能够表达出正式业务含义的语言。\"]},\"283\":{\"h\":\"使用Grafana创建可视化Dashboard\",\"t\":[\"Prometheus UI提供了快速验证PromQL以及临时可视化支持的能力，而在大多数场景下引入监控系统通常还需要构建可以长期使用的监控数据可视化面板（Dashboard）。这时用户可以考虑使用第三方的可视化工具如Grafana，Grafana是一个开源的可视化平台，并且提供了对Prometheus的完整支持。\",\"docker run -d -p 3000:3000 grafana/grafana \",\"访问http://localhost:3000就可以进入到Grafana的界面中，默认情况下使用账户admin/admin进行登录。在Grafana首页中显示默认的使用向导，包括：安装、添加数据源、创建Dashboard、邀请成员、以及安装应用和插件等主要流程:\",\"Grafana向导\",\"这里将添加Prometheus作为默认的数据源，如下图所示，指定数据源类型为Prometheus并且设置Prometheus的访问地址即可，在配置正确的情况下点击“Add”按钮，会提示连接成功的信息：\",\"添加Prometheus作为数据源\",\"在完成数据源的添加之后就可以在Grafana中创建我们可视化Dashboard了。Grafana提供了对PromQL的完整支持，如下所示，通过Grafana添加Dashboard并且为该Dashboard添加一个类型为“Graph”的面板。 并在该面板的“Metrics”选项下通过PromQL查询需要可视化的数据：\",\"第一个可视化面板\",\"点击界面中的保存选项，就创建了我们的第一个可视化Dashboard了。 当然作为开源软件，Grafana社区鼓励用户分享Dashboard通过https://grafana.com/dashboards网站，可以找到大量可直接使用的Dashboard：\",\"用户共享的Dashboard\",\"Grafana中所有的Dashboard通过JSON进行共享，下载并且导入这些JSON文件，就可以直接使用这些已经定义好的Dashboard：\",\"Host Stats Dashboard\"]},\"284\":{\"h\":\"使用Node Exporter采集主机运行数据\"},\"285\":{\"h\":\"安装Node Exporter\",\"t\":[\"在Prometheus的架构设计中，Prometheus Server并不直接服务监控特定的目标，其主要任务负责数据的收集，存储并且对外提供数据查询支持。因此为了能够监控到某些东西，如主机的CPU使用率，我们需要使用到Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址（通常是/metrics）拉取监控样本数据。\",\"从上面的描述中可以看出Exporter可以是一个相对开放的概念，其可以是一个独立运行的程序独立于监控目标以外，也可以是直接内置在监控目标中。只要能够向Prometheus提供标准格式的监控样本数据即可。\",\"这里为了能够采集到主机的运行指标如CPU, 内存，磁盘等信息。我们可以使用Node Exporter。\",\"Node Exporter同样采用Golang编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。可以从https://prometheus.io/download/获取最新的node exporter版本的二进制包。\",\"curl -OL https://github.com/prometheus/node_exporter/releases/download/v0.15.2/node_exporter-0.15.2.darwin-amd64.tar.gz tar -xzf node_exporter-0.15.2.darwin-amd64.tar.gz \",\"运行node exporter:\",\"cd node_exporter-0.15.2.darwin-amd64 cp node_exporter-0.15.2.darwin-amd64/node_exporter /usr/local/bin/ node_exporter \",\"启动成功后，可以看到以下输出：\",\"INFO[0000] Listening on :9100 source=\\\"node_exporter.go:76\\\" \",\"访问http://localhost:9100/可以看到以下页面：\",\"Node Exporter页面\"]},\"286\":{\"h\":\"初始Node Exporter监控指标\",\"t\":[\"访问http://localhost:9100/metrics，可以看到当前node exporter获取到的当前主机的所有监控数据，如下所示：\",\"主机监控指标\",\"每一个监控指标之前都会有一段类似于如下形式的信息：\",\"# HELP node_cpu Seconds the cpus spent in each mode. # TYPE node_cpu counter node_cpu{cpu=\\\"cpu0\\\",mode=\\\"idle\\\"} 362812.7890625 # HELP node_load1 1m load average. # TYPE node_load1 gauge node_load1 3.0703125 \",\"其中HELP用于解释当前指标的含义，TYPE则说明当前指标的数据类型。在上面的例子中node_cpu的注释表明当前指标是cpu0上idle进程占用CPU的总时间，CPU占用时间是一个只增不减的度量指标，从类型中也可以看出node_cpu的数据类型是计数器(counter)，与该指标的实际含义一致。又例如node_load1该指标反映了当前主机在最近一分钟以内的负载情况，系统的负载情况会随系统资源的使用而变化，因此node_load1反映的是当前状态，数据可能增加也可能减少，从注释中可以看出当前指标类型为仪表盘(gauge)，与指标反映的实际含义一致。\",\"除了这些以外，在当前页面中根据物理主机系统的不同，你还可能看到如下监控指标：\",\"node_boot_time：系统启动时间\",\"node_cpu：系统CPU使用量\",\"node_disk_*：磁盘IO\",\"node_filesystem_*：文件系统用量\",\"node_load1：系统负载\",\"node_memeory_*：内存使用量\",\"node_network_*：网络带宽\",\"node_time：当前系统时间\",\"go_*：node exporter中go相关指标\",\"process_*：node exporter自身进程相关运行指标\"]},\"287\":{\"h\":\"从Node Exporter收集监控数据\",\"t\":[\"为了能够让Prometheus Server能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑prometheus.yml并在scrape_configs节点下添加以下内容:\",\"scrape_configs: - job_name: 'prometheus' static_configs: - targets: ['localhost:9090'] # 采集node exporter监控数据 - job_name: 'node' static_configs: - targets: ['localhost:9100'] \",\"重新启动Prometheus Server\",\"访问http://localhost:9090，进入到Prometheus Server。如果输入“up”并且点击执行按钮以后，可以看到如下结果：\",\"Expression Browser\",\"如果Prometheus能够正常从node exporter获取数据，则会看到以下结果：\",\"up{instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} 1 up{instance=\\\"localhost:9100\\\",job=\\\"node\\\"} 1 \",\"其中“1”表示正常，反之“0”则为异常。\"]},\"288\":{\"h\":\"Prometheus简介\",\"t\":[\"Prometheus受启发于Google的Borgmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。\",\"Prometheus简史\",\"Prometheus作为新一代的云原生监控系统，目前已经有超过650+位贡献者参与到Prometheus的研发工作上，并且超过120+项的第三方集成。\"]},\"289\":{\"h\":\"监控的目标\",\"t\":[\"在《SRE: Google运维解密》一书中指出，监控系统需要能够有效的支持白盒监控和黑盒监控。通过白盒能够了解其内部的实际运行状态，通过对监控指标的观察能够预判可能出现的问题，从而对潜在的不确定因素进行优化。而黑盒监控，常见的如HTTP探针，TCP探针等，可以在系统或者服务在发生故障时能够快速通知相关的人员进行处理。通过建立完善的监控体系，从而达到以下目的：\",\"长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。\",\"对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。\",\"告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。\",\"故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控以及历史数据的分析，能够找到并解决根源问题。\",\"数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息。\"]},\"290\":{\"h\":\"与常见监控系统比较\",\"t\":[\"对于常用的监控系统，如Nagios、Zabbix的用户而言，往往并不能很好的解决上述问题。这里以Nagios为例，如下图所示是Nagios监控系统的基本架构：\",\"Nagios监控系统\",\"Nagios的主要功能是监控服务和主机。Nagios软件需要安装在一台独立的服务器上运行，该服务器称为监控中心。每一台被监控的硬件主机或者服务都需要运行一个与监控中心服务器进行通信的Nagios软件后台程序，可以理解为Agent或者插件。\",\"Nagios主机监控页面\",\"首先对于Nagios而言，大部分的监控能力都是围绕系统的一些边缘性的问题，主要针对系统服务和资源的状态以及应用程序的可用性。 例如：Nagios通过check_disk插件可以用于检查磁盘空间，check_load用于检查CPU负载等。这些插件会返回4种Nagios可识别的状态，0(OK)表示正常，1(WARNING)表示警告，2(CRITTCAL)表示错误，3(UNKNOWN)表示未知错误，并通过Web UI显示出来。\",\"对于Nagios这类系统而言，其核心是采用了测试和告警(check&alert)的监控系统模型。 对于基于这类模型的监控系统而言往往存在以下问题：\",\"与业务脱离的监控：监控系统获取到的监控指标与业务本身也是一种分离的关系。好比客户可能关注的是服务的可用性、服务的SLA等级，而监控系统却只能根据系统负载去产生告警；\",\"运维管理难度大：Nagios这一类监控系统本身运维管理难度就比较大，需要有专业的人员进行安装，配置和管理，而且过程并不简单；\",\"可扩展性低： 监控系统自身难以扩展，以适应监控规模的变化；\",\"问题定位难度大：当问题产生之后（比如主机负载异常增加）对于用户而言，他们看到的依然是一个黑盒，他们无法了解主机上服务真正的运行情况，因此当故障发生后，这些告警信息并不能有效的支持用户对于故障根源问题的分析和定位。\"]},\"291\":{\"h\":\"Prometheus的优势\",\"t\":[\"Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统Prometheus具有以下优点：\"]},\"292\":{\"h\":\"易于管理\",\"t\":[\"Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。\",\"Prometheus基于Pull模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建我们的监控系统。对于一些复杂的情况，还可以使用Prometheus服务发现(Service Discovery)的能力动态管理监控目标。\"]},\"293\":{\"h\":\"监控服务的内部运行状态\",\"t\":[\"Prometheus鼓励用户监控服务的内部状态，基于Prometheus丰富的Client库，用户可以轻松的在应用程序中添加对Prometheus的支持，从而让用户可以获取服务和应用内部真正的运行状态。\",\"监控服务内部运行状态\"]},\"294\":{\"h\":\"强大的数据模型\",\"t\":[\"所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。\",\"如下所示：\",\"http_request_status{code='200',content_path='/api/path', environment='produment'} => [value1@timestamp1,value2@timestamp2...] http_request_status{code='200',content_path='/api/path2', environment='produment'} => [value1@timestamp1,value2@timestamp2...] \",\"每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。\",\"表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。\"]},\"295\":{\"h\":\"强大的查询语言PromQL\",\"t\":[\"Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。\",\"通过PromQL可以轻松回答类似于以下问题：\",\"在过去一段时间中95%应用延迟时间的分布范围？\",\"预测在4小时后，磁盘空间占用大致会是什么情况？\",\"CPU占用率前5位的服务有哪些？(过滤)\"]},\"296\":{\"h\":\"高效\",\"t\":[\"对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而Prometheus可以高效地处理这些数据，对于单一Prometheus Server实例而言它可以处理：\",\"数以百万的监控指标\",\"每秒处理数十万的数据点。\"]},\"297\":{\"h\":\"可扩展\",\"t\":[\"Prometheus是如此简单，因此你可以在每个数据中心、每个团队运行独立的Prometheus Sevrer。Prometheus对于联邦集群的支持，可以让多个Prometheus实例产生一个逻辑集群，当单实例Prometheus Server处理的任务量过大时，通过使用功能分区(sharding)+联邦集群(federation)可以对其进行扩展。\"]},\"298\":{\"h\":\"易于集成\",\"t\":[\"使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序。同时这些客户端收集的监控数据，不仅仅支持Prometheus，还能支持Graphite这些其他的监控工具。\",\"同时Prometheus还支持与其他的监控系统进行集成：Graphite， Statsd， Collected， Scollector， muini， Nagios等。\",\"Prometheus社区还提供了大量第三方实现的监控数据采集支持：JMX， CloudWatch， EC2， MySQL， PostgresSQL， Haskell， Bash， SNMP， Consul， Haproxy， Mesos， Bind， CouchDB， Django， Memcached， RabbitMQ， Redis， RethinkDB， Rsyslog等等。\"]},\"299\":{\"h\":\"可视化\",\"t\":[\"Prometheus Server中自带了一个Prometheus UI，通过这个UI可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时Prometheus还提供了一个独立的基于Ruby On Rails的Dashboard解决方案Promdash。最新的Grafana可视化工具也已经提供了完整的Prometheus支持，基于Grafana可以创建更加精美的监控图标。基于Prometheus提供的API还可以实现自己的监控可视化UI。\"]},\"300\":{\"h\":\"开放性\",\"t\":[\"通常来说当我们需要监控一个应用程序时，一般需要该应用程序提供对相应监控系统协议的支持。因此应用程序会与所选择的监控系统进行绑定。为了减少这种绑定所带来的限制。对于决策者而言要么你就直接在应用中集成该监控系统的支持，要么就在外部创建单独的服务来适配不同的监控系统。\",\"而对于Prometheus来说，使用Prometheus的client library的输出格式不止支持Prometheus的格式化数据，也可以输出支持其它监控系统的格式化数据，比如Graphite。\",\"因此你甚至可以在不使用Prometheus的情况下，采用Prometheus的client library来让你的应用程序支持监控数据采集。\",\"接下来，在本书当中，将带领读者感受Prometheus是如何对监控系统的重新定义。\"]},\"301\":{\"h\":\"使用Prometheus监控Rancher集群\"},\"302\":{\"h\":\"第7章 Prometheus服务发现\",\"t\":[\"在前6个章节中，我们主要介绍了Prometheus自身的一些特性，包括高效的数据能力、灵活的查询语言PromQL、Prometheus的告警模式、Exporter的使用、以及自身的高可用等。而作为下一代监控系统的首选解决方案，Prometheus对云以及容器环境下的监控场景提供了完善的支持。本章中将介绍Prometheus是如何通过服务发现机制完美解决云原生场景下的监控挑战的。\",\"本章的主要内容：\",\"云原生、容器场景下监控的挑战；\",\"Prometheus服务发现的实现机制；\",\"Prometheus中服务发现的几种实现方式；\",\"Prometheus中强大的Relabel机制。\"]},\"303\":{\"h\":\"小结\",\"t\":[\"相比于直接使用静态配置，在云环境以及容器环境下我们更多的监控对象都是动态的。通过服务发现，使得Prometheus相比于其他传统监控解决方案更适用于云以及容器环境下的监控需求。\"]},\"304\":{\"h\":\"基于Consul的服务发现\",\"t\":[\"Consul是由HashiCorp开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件，被大量应用于基于微服务的软件架构当中。\"]},\"305\":{\"h\":\"Consul初体验\",\"t\":[\"用户可以通过Consul官网https://www.consul.io/downloads.html下载对应操作系统版本的软件包。Consul与Prometheus同样使用Go语言进行开发，因此安装和部署的方式也极为简单，解压并将命令行工具放到系统PATH路径下即可。\",\"在本地可以使用开发者模式在本地快速启动一个单节点的Consul环境：\",\"$ consul agent -dev ==> Starting Consul agent... ==> Consul agent running! Version: 'v1.0.7' Node ID: 'd7b590ba-e2f8-3a82-e8a8-2a911bdf67d5' Node name: 'localhost' Datacenter: 'dc1' (Segment: '<all>') Server: true (Bootstrap: false) Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, DNS: 8600) Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302) Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false \",\"在启动成功后，在一个新的terminal窗口中运行consul members可以查看当前集群中的所有节点：\",\"$ consul members Node Address Status Type Build Protocol DC Segment localhost 127.0.0.1:8301 alive server 1.0.7 2 dc1 <all> \",\"用户还可以通过HTTP API的方式查看当前集群中的节点信息：\",\"$ curl localhost:8500/v1/catalog/nodes [ { \\\"ID\\\": \\\"d7b590ba-e2f8-3a82-e8a8-2a911bdf67d5\\\", \\\"Node\\\": \\\"localhost\\\", \\\"Address\\\": \\\"127.0.0.1\\\", \\\"Datacenter\\\": \\\"dc1\\\", \\\"TaggedAddresses\\\": { \\\"lan\\\": \\\"127.0.0.1\\\", \\\"wan\\\": \\\"127.0.0.1\\\" }, \\\"Meta\\\": { \\\"consul-network-segment\\\": \\\"\\\" }, \\\"CreateIndex\\\": 5, \\\"ModifyIndex\\\": 6 } ] \",\"Consul还提供了内置的DNS服务，可以通过Consul的DNS服务的方式访问其中的节点：\",\"$ dig @127.0.0.1 -p 8600 localhost.node.consul ; <<>> DiG 9.9.7-P3 <<>> @127.0.0.1 -p 8600 localhost.node.consul ; (1 server found) ;; global options: +cmd ;; Got answer: ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 50684 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;localhost.node.consul. IN A ;; ANSWER SECTION: localhost.node.consul. 0 IN A 127.0.0.1 ;; Query time: 5 msec ;; SERVER: 127.0.0.1#8600(127.0.0.1) ;; WHEN: Sun Apr 15 22:10:56 CST 2018 ;; MSG SIZE rcvd: 66 \",\"在Consul当中服务可以通过服务定义文件或者是HTTP API的方式进行注册。这里使用服务定义文件的方式将本地运行的node_exporter通过服务的方式注册到Consul当中。\",\"创建配置目录：\",\"sudo mkdir /etc/consul.d \",\"echo '{\\\"service\\\": {\\\"name\\\": \\\"node_exporter\\\", \\\"tags\\\": [\\\"exporter\\\"], \\\"port\\\": 9100}}' \\\\ | sudo tee /etc/consul.d/node_exporter.json \",\"重新启动Consul服务，并且声明服务定义文件所在目录：\",\"$ consul agent -dev -config-dir=/etc/consul.d ==> Starting Consul agent... 2018/04/15 22:23:47 [DEBUG] agent: Service \\\"node_exporter\\\" in sync \",\"一旦服务注册成功之后，用户就可以通过DNS或HTTP API的方式查询服务信息。默认情况下，所有的服务都可以使用NAME.service.consul域名的方式进行访问。\",\"例如，可以使用node_exporter.service.consul域名查询node_exporter服务的信息：\",\"$ dig @127.0.0.1 -p 8600 node_exporter.service.consul ;; QUESTION SECTION: ;node_exporter.service.consul. IN A ;; ANSWER SECTION: node_exporter.service.consul. 0 IN A 127.0.0.1 \",\"如上所示DNS记录会返回当前可用的node_exporter服务实例的IP地址信息。\",\"除了使用DNS的方式以外，Consul还支持用户使用HTTP API的形式获取服务列表：\",\"$ curl http://localhost:8500/v1/catalog/service/node_exporter [ { \\\"ID\\\": \\\"e561b376-2c1b-653d-61a0-1d844bce06a7\\\", \\\"Node\\\": \\\"localhost\\\", \\\"Address\\\": \\\"127.0.0.1\\\", \\\"Datacenter\\\": \\\"dc1\\\", \\\"TaggedAddresses\\\": { \\\"lan\\\": \\\"127.0.0.1\\\", \\\"wan\\\": \\\"127.0.0.1\\\" }, \\\"NodeMeta\\\": { \\\"consul-network-segment\\\": \\\"\\\" }, \\\"ServiceID\\\": \\\"node_exporter\\\", \\\"ServiceName\\\": \\\"node_exporter\\\", \\\"ServiceTags\\\": [ \\\"exporter\\\" ], \\\"ServiceAddress\\\": \\\"\\\", \\\"ServiceMeta\\\": {}, \\\"ServicePort\\\": 9100, \\\"ServiceEnableTagOverride\\\": false, \\\"CreateIndex\\\": 6, \\\"ModifyIndex\\\": 6 } ] \",\"Consul也提供了一个Web UI可以查看Consul中所有服务以及节点的状态：\",\"Consul UI\",\"当然Consul还提供了更多的API用于支持对服务的生命周期管理（添加、删除、修改等）这里就不做过多的介绍，感兴趣的同学可以通过Consul官方文档了解更多的详细信息。\"]},\"306\":{\"h\":\"与Prometheus集成\",\"t\":[\"Consul作为一个通用的服务发现和注册中心，记录并且管理了环境中所有服务的信息。Prometheus通过与Consul的交互可以获取到相应Exporter实例的访问信息。在Prometheus的配置文件当可以通过以下方式与Consul进行集成：\",\"- job_name: node_exporter metrics_path: /metrics scheme: http consul_sd_configs: - server: localhost:8500 services: - node_exporter \",\"在consul_sd_configs定义当中通过server定义了Consul服务的访问地址，services则定义了当前需要发现哪些类型服务实例的信息，这里限定了只获取node_exporter的服务实例信息。\"]},\"307\":{\"h\":\"基于文件的服务发现\",\"t\":[\"在Prometheus支持的众多服务发现的实现方式中，基于文件的服务发现是最通用的方式。这种方式不需要依赖于任何的平台或者第三方服务。对于Prometheus而言也不可能支持所有的平台或者环境。通过基于文件的服务发现方式下，Prometheus会定时从文件中读取最新的Target信息，因此，你可以通过任意的方式将监控Target的信息写入即可。\",\"用户可以通过JSON或者YAML格式的文件，定义所有的监控目标。例如，在下面的JSON文件中分别定义了3个采集任务，以及每个任务对应的Target列表：\",\"[ { \\\"targets\\\": [ \\\"localhost:8080\\\"], \\\"labels\\\": { \\\"env\\\": \\\"localhost\\\", \\\"job\\\": \\\"cadvisor\\\" } }, { \\\"targets\\\": [ \\\"localhost:9104\\\" ], \\\"labels\\\": { \\\"env\\\": \\\"prod\\\", \\\"job\\\": \\\"mysqld\\\" } }, { \\\"targets\\\": [ \\\"localhost:9100\\\"], \\\"labels\\\": { \\\"env\\\": \\\"prod\\\", \\\"job\\\": \\\"node\\\" } } ] \",\"同时还可以通过为这些实例添加一些额外的标签信息，例如使用env标签标示当前节点所在的环境，这样从这些实例中采集到的样本信息将包含这些标签信息，从而可以通过该标签按照环境对数据进行统计。\",\"创建Prometheus配置文件/etc/prometheus/prometheus-file-sd.yml，并添加以下内容：\",\"global: scrape_interval: 15s scrape_timeout: 10s evaluation_interval: 15s scrape_configs: - job_name: 'file_ds' file_sd_configs: - files: - targets.json \",\"这里定义了一个基于file_sd_configs的监控采集任务，其中模式的任务名称为file_ds。在JSON文件中可以使用job标签覆盖默认的job名称，此时启动Prometheus服务：\",\"prometheus --config.file=/etc/prometheus/prometheus-file-sd.yml --storage.tsdb.path=/data/prometheus \",\"在Prometheus UI的Targets下就可以看到当前从targets.json文件中动态获取到的Target实例信息以及监控任务的采集状态，同时在Labels列下会包含用户添加的自定义标签:\",\"基于文件动态发现Target对象\",\"Prometheus默认每5m重新读取一次文件内容，当需要修改时，可以通过refresh_interval进行设置，例如：\",\"- job_name: 'file_ds' file_sd_configs: - refresh_interval: 1m files: - targets.json \",\"通过这种方式，Prometheus会自动的周期性读取文件中的内容。当文件中定义的内容发生变化时，不需要对Prometheus进行任何的重启操作。\",\"这种通用的方式可以衍生了很多不同的玩法，比如与自动化配置管理工具(Ansible)结合、与Cron Job结合等等。 对于一些Prometheus还不支持的云环境，比如国内的阿里云、腾讯云等也可以使用这种方式通过一些自定义程序与平台进行交互自动生成监控Target文件，从而实现对这些云环境中基础设施的自动化监控支持。\"]},\"308\":{\"h\":\"服务发现与Relabeling\",\"t\":[\"在本章的前几个小节中笔者已经分别介绍了Prometheus的几种服务发现机制。通过服务发现的方式，管理员可以在不重启Prometheus服务的情况下动态的发现需要监控的Target实例信息。\",\"基于Consul的服务发现\",\"如上图所示，对于线上环境我们可能会划分为:dev, stage, prod不同的集群。每一个集群运行多个主机节点，每个服务器节点上运行一个Node Exporter实例。Node Exporter实例会自动注册到Consul中，而Prometheus则根据Consul返回的Node Exporter实例信息动态的维护Target列表，从而向这些Target轮询监控数据。\",\"然而，如果我们可能还需要：\",\"按照不同的环境dev, stage, prod聚合监控数据？\",\"对于研发团队而言，我可能只关心dev环境的监控数据，如何处理？\",\"如果为每一个团队单独搭建一个Prometheus Server。那么如何让不同团队的Prometheus Server采集不同的环境监控数据？\",\"面对以上这些场景下的需求时，我们实际上是希望Prometheus Server能够按照某些规则（比如标签）从服务发现注册中心返回的Target实例中有选择性的采集某些Exporter实例的监控数据。\",\"接下来，我们将学习如何通过Prometheus强大的Relabel机制来实现以上这些具体的目标。\"]},\"309\":{\"h\":\"Prometheus的Relabeling机制\",\"t\":[\"在Prometheus所有的Target实例中，都包含一些默认的Metadata标签信息。可以通过Prometheus UI的Targets页面中查看这些实例的Metadata标签的内容：\",\"实例的Metadata信息\",\"默认情况下，当Prometheus加载Target实例完成后，这些Target时候都会包含一些默认的标签：\",\"__address__：当前Target实例的访问地址<host>:<port>\",\"__scheme__：采集目标服务访问地址的HTTP Scheme，HTTP或者HTTPS\",\"__metrics_path__：采集目标服务访问地址的访问路径\",\"__param_<name>：采集任务目标服务的中包含的请求参数\",\"上面这些标签将会告诉Prometheus如何从该Target实例中获取监控数据。除了这些默认的标签以外，我们还可以为Target添加自定义的标签，例如，在“基于文件的服务发现”小节中的示例中，我们通过JSON配置文件，为Target实例添加了自定义标签env，如下所示该标签最终也会保存到从该实例采集的样本数据中：\",\"node_cpu{cpu=\\\"cpu0\\\",env=\\\"prod\\\",instance=\\\"localhost:9100\\\",job=\\\"node\\\",mode=\\\"idle\\\"} \",\"一般来说，Target以__作为前置的标签是在系统内部使用的，因此这些标签不会被写入到样本数据中。不过这里有一些例外，例如，我们会发现所有通过Prometheus采集的样本数据中都会包含一个名为instance的标签，该标签的内容对应到Target实例的__address__。 这里实际上是发生了一次标签的重写处理。\",\"这种发生在采集样本数据之前，对Target实例的标签进行重写的机制在Prometheus被称为Relabeling。\",\"Relabeling作用时机\",\"Prometheus允许用户在采集任务设置中通过relabel_configs来添加自定义的Relabeling过程。\"]},\"310\":{\"h\":\"使用replace/labelmap重写标签\",\"t\":[\"Relabeling最基本的应用场景就是基于Target实例中包含的metadata标签，动态的添加或者覆盖标签。例如，通过Consul动态发现的服务实例还会包含以下Metadata标签信息：\",\"__meta_consul_address：consul地址\",\"__meta_consul_dc：consul中服务所在的数据中心\",\"__meta_consulmetadata：服务的metadata\",\"__meta_consul_node：服务所在consul节点的信息\",\"__meta_consul_service_address：服务访问地址\",\"__meta_consul_service_id：服务ID\",\"__meta_consul_service_port：服务端口\",\"__meta_consul_service：服务名称\",\"__meta_consul_tags：服务包含的标签信息\",\"在默认情况下，从Node Exporter实例采集上来的样本数据如下所示：\",\"node_cpu{cpu=\\\"cpu0\\\",instance=\\\"localhost:9100\\\",job=\\\"node\\\",mode=\\\"idle\\\"} 93970.8203125 \",\"我们希望能有一个额外的标签dc可以表示该样本所属的数据中心：\",\"node_cpu{cpu=\\\"cpu0\\\",instance=\\\"localhost:9100\\\",job=\\\"node\\\",mode=\\\"idle\\\", dc=\\\"dc1\\\"} 93970.8203125 \",\"在每一个采集任务的配置中可以添加多个relabel_config配置，一个最简单的relabel配置如下：\",\"scrape_configs: - job_name: node_exporter consul_sd_configs: - server: localhost:8500 services: - node_exporter relabel_configs: - source_labels: [\\\"__meta_consul_dc\\\"] target_label: \\\"dc\\\" \",\"该采集任务通过Consul动态发现Node Exporter实例信息作为监控采集目标。在上一小节中，我们知道通过Consul动态发现的监控Target都会包含一些额外的Metadata标签，比如标签__meta_consul_dc表明了当前实例所在的Consul数据中心，因此我们希望从这些实例中采集到的监控样本中也可以包含这样一个标签，例如：\",\"node_cpu{cpu=\\\"cpu0\\\",dc=\\\"dc1\\\",instance=\\\"172.21.0.6:9100\\\",job=\\\"consul_sd\\\",mode=\\\"guest\\\"} \",\"这样可以方便的根据dc标签的值，根据不同的数据中心聚合分析各自的数据。\",\"在这个例子中，通过从Target实例中获取__meta_consul_dc的值，并且重写所有从该实例获取的样本中。\",\"完整的relabel_config配置如下所示：\",\"# The source labels select values from existing labels. Their content is concatenated # using the configured separator and matched against the configured regular expression # for the replace, keep, and drop actions. [ source_labels: '[' <labelname> [, ...] ']' ] # Separator placed between concatenated source label values. [ separator: <string> | default = ; ] # Label to which the resulting value is written in a replace action. # It is mandatory for replace actions. Regex capture groups are available. [ target_label: <labelname> ] # Regular expression against which the extracted value is matched. [ regex: <regex> | default = (.*) ] # Modulus to take of the hash of the source label values. [ modulus: <uint64> ] # Replacement value against which a regex replace is performed if the # regular expression matches. Regex capture groups are available. [ replacement: <string> | default = $1 ] # Action to perform based on regex matching. [ action: <relabel_action> | default = replace ] \",\"其中action定义了当前relabel_config对Metadata标签的处理方式，默认的action行为为replace。 replace行为会根据regex的配置匹配source_labels标签的值（多个source_label的值会按照separator进行拼接），并且将匹配到的值写入到target_label当中，如果有多个匹配组，则可以使用${1}, ${2}确定写入的内容。如果没匹配到任何内容则不对target_label进行重写。\",\"repalce操作允许用户根据Target的Metadata标签重写或者写入新的标签键值对，在多环境的场景下，可以帮助用户添加与环境相关的特征维度，从而可以更好的对数据进行聚合。\",\"除了使用replace以外，还可以定义action的配置为labelmap。与replace不同的是，labelmap会根据regex的定义去匹配Target实例所有标签的名称，并且以匹配到的内容为新的标签名称，其值作为新标签的值。\",\"例如，在监控Kubernetes下所有的主机节点时，为将这些节点上定义的标签写入到样本中时，可以使用如下relabel_config配置：\",\"- job_name: 'kubernetes-nodes' kubernetes_sd_configs: - role: node relabel_configs: - action: labelmap regex: __meta_kubernetes_node_label_(.+) \",\"而使用labelkeep或者labeldrop则可以对Target标签进行过滤，仅保留符合过滤条件的标签，例如：\",\"relabel_configs: - regex: label_should_drop_(.+) action: labeldrop \",\"该配置会使用regex匹配当前Target实例的所有标签，并将符合regex规则的标签从Target实例中移除。labelkeep正好相反，会移除那些不匹配regex定义的所有标签。\"]},\"311\":{\"h\":\"使用keep/drop过滤Target实例\",\"t\":[\"在上一部分中我们介绍了Prometheus的Relabeling机制，并且使用了replace/labelmap/labelkeep/labeldrop对标签进行管理。而本节开头还提到过第二个问题，使用中心化的服务发现注册中心时，所有环境的Exporter实例都会注册到该服务发现注册中心中。而不同职能（开发、测试、运维）的人员可能只关心其中一部分的监控数据，他们可能各自部署的自己的Prometheus Server用于监控自己关心的指标数据，如果让这些Prometheus Server采集所有环境中的所有Exporter数据显然会存在大量的资源浪费。如何让这些不同的Prometheus Server采集各自关心的内容？答案还是Relabeling，relabel_config的action除了默认的replace以外，还支持keep/drop行为。例如，如果我们只希望采集数据中心dc1中的Node Exporter实例的样本数据，那么可以使用如下配置：\",\"scrape_configs: - job_name: node_exporter consul_sd_configs: - server: localhost:8500 services: - node_exporter relabel_configs: - source_labels: [\\\"__meta_consul_dc\\\"] regex: \\\"dc1\\\" action: keep \",\"当action设置为keep时，Prometheus会丢弃source_labels的值中没有匹配到regex正则表达式内容的Target实例，而当action设置为drop时，则会丢弃那些source_labels的值匹配到regex正则表达式内容的Target实例。可以简单理解为keep用于选择，而drop用于排除。\"]},\"312\":{\"h\":\"使用hashmod计算source_labels的Hash值\",\"t\":[\"当relabel_config设置为hashmod时，Prometheus会根据modulus的值作为系数，计算source_labels值的hash值。例如：\",\"scrape_configs - job_name: 'file_ds' relabel_configs: - source_labels: [__address__] modulus: 4 target_label: tmp_hash action: hashmod file_sd_configs: - files: - targets.json \",\"根据当前Target实例__address__的值以4作为系数，这样每个Target实例都会包含一个新的标签tmp_hash，并且该值的范围在1~4之间，查看Target实例的标签信息，可以看到如下的结果，每一个Target实例都包含了一个新的tmp_hash值：\",\"计算Hash值\",\"在第6章的“Prometheus高可用”小节中，正是利用了Hashmod的能力在Target实例级别实现对采集任务的功能分区的:\",\"scrape_configs: - job_name: some_job relabel_configs: - source_labels: [__address__] modulus: 4 target_label: __tmp_hash action: hashmod - source_labels: [__tmp_hash] regex: ^1$ action: keep \",\"这里需要注意的是，如果relabel的操作只是为了产生一个临时变量，以作为下一个relabel操作的输入，那么我们可以使用__tmp作为标签名的前缀，通过该前缀定义的标签就不会写入到Target或者采集到的样本的标签中。\"]},\"313\":{\"h\":\"Prometheus与服务发现\",\"t\":[\"在基于云(IaaS或者CaaS)的基础设施环境中用户可以像使用水、电一样按需使用各种资源（计算、网络、存储）。按需使用就意味着资源的动态性，这些资源可以随着需求规模的变化而变化。例如在AWS中就提供了专门的AutoScall服务，可以根据用户定义的规则动态地创建或者销毁EC2实例，从而使用户部署在AWS上的应用可以自动的适应访问规模的变化。\",\"这种按需的资源使用方式对于监控系统而言就意味着没有了一个固定的监控目标，所有的监控对象(基础设施、应用、服务)都在动态的变化。对于Nagios这类基于Push模式传统监控软件就意味着必须在每一个节点上安装相应的Agent程序，并且通过配置指向中心的Nagios服务，受监控的资源与中心监控服务器之间是一个强耦合的关系，要么直接将Agent构建到基础设施镜像当中，要么使用一些自动化配置管理工具(如Ansible、Chef)动态的配置这些节点。当然实际场景下除了基础设施的监控需求以外，我们还需要监控在云上部署的应用，中间件等等各种各样的服务。要搭建起这样一套中心化的监控系统实施成本和难度是显而易见的。\",\"而对于Prometheus这一类基于Pull模式的监控系统，显然也无法继续使用的static_configs的方式静态的定义监控目标。而对于Prometheus而言其解决方案就是引入一个中间的代理人（服务注册中心），这个代理人掌握着当前所有监控目标的访问信息，Prometheus只需要向这个代理人询问有哪些监控目标即可， 这种模式被称为服务发现。\",\"基于服务发现与注册中心动态发现监控目标\",\"在不同的场景下，会有不同的东西扮演代理人（服务发现与注册中心）这一角色。比如在AWS公有云平台或者OpenStack的私有云平台中，由于这些平台自身掌握着所有资源的信息，此时这些云平台自身就扮演了代理人的角色。Prometheus通过使用平台提供的API就可以找到所有需要监控的云主机。在Kubernetes这类容器管理平台中，Kubernetes掌握并管理着所有的容器以及服务信息，那此时Prometheus只需要与Kubernetes打交道就可以找到所有需要监控的容器以及服务对象。Prometheus还可以直接与一些开源的服务发现工具进行集成，例如在微服务架构的应用程序中，经常会使用到例如Consul这样的服务发现注册软件，Promethues也可以与其集成从而动态的发现需要监控的应用服务实例。除了与这些平台级的公有云、私有云、容器云以及专门的服务发现注册中心集成以外，Prometheus还支持基于DNS以及文件的方式动态发现监控目标，从而大大的减少了在云原生，微服务以及云模式下监控实施难度。\",\"Push系统 vs Pull系统\",\"如上所示，展示了Push系统和Pull系统的核心差异。相较于Push模式，Pull模式的优点可以简单总结为以下几点：\",\"只要Exporter在运行，你可以在任何地方（比如在本地），搭建你的监控系统；\",\"你可以更容易的查看监控目标实例的健康状态，并且可以快速定位故障；\",\"更利于构建DevOps文化的团队；\",\"松耦合的架构模式更适合于云原生的部署环境。\"]},\"314\":{\"h\":\"DNS探针\",\"t\":[\"# The preferred IP protocol of the DNS probe (ip4, ip6). [ preferred_ip_protocol: <string> | default = \\\"ip6\\\" ] # The source IP address. [ source_ip_address: <string> ] [ transport_protocol: <string> | default = \\\"udp\\\" ] # udp, tcp query_name: <string> [ query_type: <string> | default = \\\"ANY\\\" ] # List of valid response codes. valid_rcodes: [ - <string> ... | default = \\\"NOERROR\\\" ] validate_answer_rrs: fail_if_matches_regexp: [ - <regex>, ... ] fail_if_not_matches_regexp: [ - <regex>, ... ] validate_authority_rrs: fail_if_matches_regexp: [ - <regex>, ... ] fail_if_not_matches_regexp: [ - <regex>, ... ] validate_additional_rrs: fail_if_matches_regexp: [ - <regex>, ... ] fail_if_not_matches_regexp: [ - <regex>, ... ] \"]},\"315\":{\"h\":\"\"},\"316\":{\"h\":\"HTTP探针\",\"t\":[\"HTTP探针是进行黑盒监控时最常用的探针之一，通过HTTP探针能够网站或者HTTP服务建立有效的监控，包括其本身的可用性，以及用户体验相关的如响应时间等等。除了能够在服务出现异常的时候及时报警，还能帮助系统管理员分析和优化网站体验。\",\"在上一小节讲过，Blockbox Exporter中所有的探针均是以Module的信息进行配置。如下所示，配置了一个最简单的HTTP探针：\",\"modules: http_2xx_example: prober: http http: \",\"通过prober配置项指定探针类型。配置项http用于自定义探针的探测方式，这里有没对http配置项添加任何配置，表示完全使用HTTP探针的默认配置，该探针将使用HTTP GET的方式对目标服务进行探测，并且验证返回状态码是否为2XX，是则表示验证成功，否则失败。\"]},\"317\":{\"h\":\"自定义HTTP请求\",\"t\":[\"HTTP服务通常会以不同的形式对外展现，有些可能就是一些简单的网页，而有些则可能是一些基于REST的API服务。 对于不同类型的HTTP的探测需要管理员能够对HTTP探针的行为进行更多的自定义设置，包括：HTTP请求方法、HTTP头信息、请求参数等。对于某些启用了安全认证的服务还需要能够对HTTP探测设置相应的Auth支持。对于HTTPS类型的服务还需要能够对证书进行自定义设置。\",\"如下所示，这里通过method定义了探测时使用的请求方法，对于一些需要请求参数的服务，还可以通过headers定义相关的请求头信息，使用body定义请求内容：\",\"http_post_2xx: prober: http timeout: 5s http: method: POST headers: Content-Type: application/json body: '{}' \",\"如果HTTP服务启用了安全认证，Blockbox Exporter内置了对basic_auth的支持，可以直接设置相关的认证信息即可：\",\"http_basic_auth_example: prober: http timeout: 5s http: method: POST headers: Host: \\\"login.example.com\\\" basic_auth: username: \\\"username\\\" password: \\\"mysecret\\\" \",\"对于使用了Bear Token的服务也可以通过bearer_token配置项直接指定令牌字符串，或者通过bearer_token_file指定令牌文件。\",\"对于一些启用了HTTPS的服务，但是需要自定义证书的服务，可以通过tls_config指定相关的证书信息：\",\" http_custom_ca_example: prober: http http: method: GET tls_config: ca_file: \\\"/certs/my_cert.crt\\\" \"]},\"318\":{\"h\":\"自定义探针行为\",\"t\":[\"在默认情况下HTTP探针只会对HTTP返回状态码进行校验，如果状态码为2XX（200 <= StatusCode < 300）则表示探测成功，并且探针返回的指标probe_success值为1。\",\"如果用户需要指定HTTP返回状态码，或者对HTTP版本有特殊要求，如下所示，可以使用valid_http_versions和valid_status_codes进行定义：\",\" http_2xx_example: prober: http timeout: 5s http: valid_http_versions: [\\\"HTTP/1.1\\\", \\\"HTTP/2\\\"] valid_status_codes: [] \",\"默认情况下，Blockbox返回的样本数据中也会包含指标probe_http_ssl，用于表明当前探针是否使用了SSL：\",\"# HELP probe_http_ssl Indicates if SSL was used for the final redirect # TYPE probe_http_ssl gauge probe_http_ssl 0 \",\"而如果用户对于HTTP服务是否启用SSL有强制的标准。则可以使用fail_if_ssl和fail_if_not_ssl进行配置。fail_if_ssl为true时，表示如果站点启用了SSL则探针失败，反之成功。fail_if_not_ssl刚好相反。\",\" http_2xx_example: prober: http timeout: 5s http: valid_status_codes: [] method: GET no_follow_redirects: false fail_if_ssl: false fail_if_not_ssl: false \",\"除了基于HTTP状态码，HTTP协议版本以及是否启用SSL作为控制探针探测行为成功与否的标准以外，还可以匹配HTTP服务的响应内容。使用fail_if_matches_regexp和fail_if_not_matches_regexp用户可以定义一组正则表达式，用于验证HTTP返回内容是否符合或者不符合正则表达式的内容。\",\" http_2xx_example: prober: http timeout: 5s http: method: GET fail_if_matches_regexp: - \\\"Could not connect to database\\\" fail_if_not_matches_regexp: - \\\"Download the latest version here\\\" \",\"最后需要提醒的时，默认情况下HTTP探针会走IPV6的协议。 在大多数情况下，可以使用preferred_ip_protocol=ip4强制通过IPV4的方式进行探测。在Bloackbox响应的监控样本中，也会通过指标probe_ip_protocol，表明当前的协议使用情况：\",\"# HELP probe_ip_protocol Specifies whether probe ip protocol is IP4 or IP6 # TYPE probe_ip_protocol gauge probe_ip_protocol 6 \"]},\"319\":{\"h\":\"ICMP探针\",\"t\":[\"# The preferred IP protocol of the ICMP probe (ip4, ip6). [ preferred_ip_protocol: <string> | default = \\\"ip6\\\" ] # The source IP address. [ source_ip_address: <string> ] # Set the DF-bit in the IP-header. Only works with ip4 and on *nix systems. [ dont_fragment: <boolean> | default = false ] # The size of the payload. [ payload_size: <int> ] \"]},\"320\":{\"h\":\"IPv4和IPv6探针\"},\"321\":{\"h\":\"TCP探针\",\"t\":[\"# The preferred IP protocol of the TCP probe (ip4, ip6). [ preferred_ip_protocol: <string> | default = \\\"ip6\\\" ] # The source IP address. [ source_ip_address: <string> ] # The query sent in the TCP probe and the expected associated response. # starttls upgrades TCP connection to TLS. query_response: [ - [ [ expect: <string> ], [ send: <string> ], [ starttls: <boolean | default = false> ] ], ... ] # Whether or not TLS is used when the connection is initiated. [ tls: <boolean | default = false> ] # Configuration for TLS protocol of TCP probe. tls_config: [ <tls_config> ] \"]},\"322\":{\"h\":\"百里挑一\",\"t\":[\"TODO\"]},\"323\":{\"h\":\"Prometheus Vs Graphite\"},\"324\":{\"h\":\"范围\",\"t\":[\"Graphite专注于时序数据库本身，对外提供查询和图形可视化的功能。 而其他监控相关的问题都需要由外部组件来解决。\",\"Prometheus则是一个完整的监控系统，包括内置的数据采集，存储，查询，图形可视化以及基于时间序列数据的告警能力。\"]},\"325\":{\"h\":\"数据模型\",\"t\":[\"Graphite和Prometheus一样，对基于时间序列的数据进行存储。\",\"Graphite中的监控指标通过一组基于“.”的关键字维度组成：\",\"stats.api-server.tracks.post.500 -> 93 \",\"而Prometheus中，每一个监控指标拥有对个基于key-value形式的标签组成。 通过这些标签，我们可以更容易的对数据进行过滤，分组，以及查询。\",\"api_server_http_requests_total{method=\\\"POST\\\",handler=\\\"/tracks\\\",status=\\\"500\\\",instance=\\\"<sample1>\\\"} -> 34 api_server_http_requests_total{method=\\\"POST\\\",handler=\\\"/tracks\\\",status=\\\"500\\\",instance=\\\"<sample2>\\\"} -> 28 api_server_http_requests_total{method=\\\"POST\\\",handler=\\\"/tracks\\\",status=\\\"500\\\",instance=\\\"<sample3>\\\"} -> 31 \"]},\"326\":{\"h\":\"存储\",\"t\":[\"Graphite使用Whisper的格式将时间序列数据存储在本地磁盘中，这是一种RRD风格的数据库，期望采集到的样本数据能定期到达。每一条时间序列存储在单独的文件当中，并且新的样本数据会在一段时间后覆盖旧的样本数据。\",\"Prometheus同样将时间序列数据分别存储在独立的本地磁盘中，但是运行样本已不同的周期进行采集。因为新的样本数据只是简单的追加到时间序列上，因此老的数据可能会保留较长的时间。Prometheus也适用于那些生命周期较短，变化频繁的时间序列。\"]},\"327\":{\"h\":\"总结\",\"t\":[\"Prometehus提供了更灵活的数据模型以及查询语言，同时更容易运行以及集成到现有的环境中。但是如果你想要一个可以长期保存历史数据的集群解决方案，那么Graphite可能是一个更好的选择。\"]},\"328\":{\"h\":\"Prometheus Vs InfluxDB\",\"t\":[\"InfluxDB是一个开源的时间序列数据库，同时具有支持扩展以及集群的商业版本。Prometheus和InfluxDB之间存在着一些显著的差异，并且由各自适用的使用场景。\",\"但是当将Kapacitor和InfluxDB一起考虑时，它们的组合与Prometheus与AlertManager解决了相同的问题。\"]},\"329\":{\"h\":\"范围\"},\"330\":{\"h\":\"数据模型/存储\"},\"331\":{\"h\":\"架构设计\"},\"332\":{\"h\":\"总结\"},\"333\":{\"h\":\"Prometheus Vs OpenTSDB\"},\"334\":{\"h\":\"范围\"},\"335\":{\"h\":\"数据模型\"},\"336\":{\"h\":\"存储\"},\"337\":{\"h\":\"总结\"},\"338\":{\"h\":\"Prometheus Vs Nagios\"},\"339\":{\"h\":\"范围\"},\"340\":{\"h\":\"架构\"},\"341\":{\"h\":\"总结\"},\"342\":{\"h\":\"Prometheus vs. Sensu\"},\"343\":{\"h\":\"范围\"},\"344\":{\"h\":\"数据模型\"},\"345\":{\"h\":\"架构\"},\"346\":{\"h\":\"总结\"},\"347\":{\"h\":\"自定义Exporter实战\",\"t\":[\"除了使用Prometheus已经提供的大量Exporter以外，还可以通过Prometheus社区提供的Client Library用户可以完全根据自己的需求实现自定义Exporter。目前社区官方提供支持的包括：Go、Java、Python、Ruby。 除此之外还包括一些第三方的Client library如：Bash、C++、Node.js、PHP等等。即使找不到可以直接使用的client library，用户只需要按照Prometheus的格式输出指标数据即可。这一部分，我们将带来读者使用Prometheus的这些client library创建自定义Exporter。\"]},\"348\":{\"h\":\"client_java\",\"t\":[\"为了方便用户集成，Prometheus提供了多种Client Library。通过这些Client Library用户可以创建自定义的Exporter程序，也可以直接在业务系统中集成对Prometheus的支持。 这一小节中，我们将学习如何使用Prometheus官方提供的client_java创建Exporter程序。\",\"这部分我们将带领读者学习Prometheus社区提供的client_java（Github地址）的基本用法，并基于它实现一个简单的Exporter程序。\"]},\"349\":{\"h\":\"初识client_java\",\"t\":[\"你可以根据自己的喜好使用Maven或者Gradle创建应用程序，在本书中将以Gradle为例。\",\"添加Prometheus client_java依赖包，在build.gradle中添加依赖，如下：\",\"# 省略其它gradle配置 dependencies { compile \\\"io.prometheus:simpleclient:0.3.0\\\" compile \\\"io.prometheus:simpleclient_hotspot:0.3.0\\\" compile \\\"io.prometheus:simpleclient_httpserver:0.3.0\\\" compile \\\"io.prometheus:simpleclient_pushgateway:0.3.0\\\" } \",\"其中simpleclient是对Prometheus集成的核心依赖，simpleclient_hotspot是对Hotspot JVM相关监控数据采集的实现。simpleclient_httpserver中提供的一个简单的能够处理Prometheus监控请求的HTTP服务器实现。simpleclient_pushgateway则提供了与PushGateway的对接支持。\",\"使用simpleclient_http创建一个简单的HTTPServer。\",\"package com.github.prometheus.samples; import io.prometheus.client.exporter.HTTPServer; import io.prometheus.client.hotspot.DefaultExports; import java.io.IOException; public class Server { public static void main(String[] args) throws IOException { DefaultExports.initialize(); new HTTPServer(1234); } } \",\"运行main函数，并且访问http://localhost:1234/metrics，可以在网页中看到以下内容。\",\"# HELP jvm_info JVM version info # TYPE jvm_info gauge jvm_info{version=\\\"1.8.0_51-b16\\\",vendor=\\\"Oracle Corporation\\\",runtime=\\\"Java(TM) SE Runtime Environment\\\",} 1.0 # HELP jvm_gc_collection_seconds Time spent in a given JVM garbage collector in seconds. # TYPE jvm_gc_collection_seconds summary jvm_gc_collection_seconds_count{gc=\\\"PS Scavenge\\\",} 0.0 jvm_gc_collection_seconds_sum{gc=\\\"PS Scavenge\\\",} 0.0 jvm_gc_collection_seconds_count{gc=\\\"PS MarkSweep\\\",} 0.0 jvm_gc_collection_seconds_sum{gc=\\\"PS MarkSweep\\\",} 0.0 # HELP jvm_buffer_pool_used_bytes Used bytes of a given JVM buffer pool. # TYPE jvm_buffer_pool_used_bytes gauge jvm_buffer_pool_used_bytes{pool=\\\"direct\\\",} 8192.0 jvm_buffer_pool_used_bytes{pool=\\\"mapped\\\",} 0.0 \",\"恭喜你，已经成功完成了你的第一个Exporter程序。这里返回的是当前应用中JVM相关的监控指标，包括JVM中GC，Memory Pool，JMX, Classloading，以及线程数等监控统计信息。\"]},\"350\":{\"h\":\"client_java的实现过程\",\"t\":[\"查看DefaultExports.initialize()中的实现代码，可以看到类似于如下代码：\",\"public class DefaultExports { private static boolean initialized = false; public static synchronized void initialize() { if (!initialized) { new StandardExports().register(); new MemoryPoolsExports().register(); new BufferPoolsExports().register(); new GarbageCollectorExports().register(); new ThreadExports().register(); new ClassLoadingExports().register(); new VersionInfoExports().register(); initialized = true; } } } \",\"这里所有的Exporters都继承自Collector，并且实现collect()方法，用于返回该Collector中获取到的所有监控指标和样本数据。而register()方法，会将该Collector自己注册到CollectorRegistry.defaultRegistry中。\",\"HTTPServer中则创建了一个HTTPMetricHandler用于来处理Prometheus抓取监控样本数据的请求：\",\" server = HttpServer.create(); server.bind(addr, 3); HttpHandler mHandler = new HTTPMetricHandler(registry); server.createContext(\\\"/\\\", mHandler); server.createContext(\\\"/metrics\\\", mHandler); executorService = Executors.newFixedThreadPool(5, DaemonThreadFactory.defaultThreadFactory(daemon)); server.setExecutor(executorService); start(daemon); \",\"HTTPMetricHandler主要负责响应Prometheus Server向该Exporter发起的请求。通过从CollectorRegistry.defaultRegistry中所有的Collector实例的collect()方法中获取样本数据，并对样本数据进行格式化，从而将监控样本返回给Prometheus Server:\",\" public void handle(HttpExchange t) throws IOException { String query = t.getRequestURI().getRawQuery(); ByteArrayOutputStream response = this.response.get(); response.reset(); OutputStreamWriter osw = new OutputStreamWriter(response); TextFormat.write004(osw, registry.filteredMetricFamilySamples(parseQuery(query))); osw.flush(); osw.close(); response.flush(); response.close(); t.getResponseHeaders().set(\\\"Content-Type\\\", TextFormat.CONTENT_TYPE_004); t.getResponseHeaders().set(\\\"Content-Length\\\", String.valueOf(response.size())); if (shouldUseCompression(t)) { t.getResponseHeaders().set(\\\"Content-Encoding\\\", \\\"gzip\\\"); t.sendResponseHeaders(HttpURLConnection.HTTP_OK, 0); final GZIPOutputStream os = new GZIPOutputStream(t.getResponseBody()); response.writeTo(os); os.finish(); } else { t.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.size()); response.writeTo(t.getResponseBody()); } t.close(); } \",\"这里以GarbageCollectorExports为例，collect()方法会从java.lang.management中获取到GC回收相关的运行数据，并且转换为SummaryMetricFamily：\",\"package io.prometheus.client.hotspot; import io.prometheus.client.Collector; import io.prometheus.client.SummaryMetricFamily; import java.lang.management.GarbageCollectorMXBean; import java.lang.management.ManagementFactory; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class GarbageCollectorExports extends Collector { private final List<GarbageCollectorMXBean> garbageCollectors; public GarbageCollectorExports() { this(ManagementFactory.getGarbageCollectorMXBeans()); } GarbageCollectorExports(List<GarbageCollectorMXBean> garbageCollectors) { this.garbageCollectors = garbageCollectors; } public List<MetricFamilySamples> collect() { SummaryMetricFamily gcCollection = new SummaryMetricFamily( \\\"jvm_gc_collection_seconds\\\", \\\"Time spent in a given JVM garbage collector in seconds.\\\", Collections.singletonList(\\\"gc\\\")); for (final GarbageCollectorMXBean gc : garbageCollectors) { gcCollection.addMetric( Collections.singletonList(gc.getName()), gc.getCollectionCount(), gc.getCollectionTime() / MILLISECONDS_PER_SECOND); } List<MetricFamilySamples> mfs = new ArrayList<MetricFamilySamples>(); mfs.add(gcCollection); return mfs; } } \",\"下图描述了一下通过Prometheus Java Client中HTTP Server对获取监控样本请求的处理过程。\",\"处理流程\",\"除了使用Prometheus提供的HttpServer以外，Prometheus提供了针对Servlet，Spring Boot, Spring Web以及Dropwizard等的实现。可以让用户快速实现已有应用程序与Prometheus的集成。\"]},\"351\":{\"h\":\"自定义Collector\",\"t\":[\"在上面的例子中，已经了解过simpleclient_hotspot是如果实现对JVM相关运行指标的监控的。通过添加自定义的Collector，用户可以轻松实现对外部系统（或者服务）的监控数据收集。\",\"使用自定义Collector监控第三方监控指标\",\"以下代码，演示了如何在Exporter中创建自定义Collector:\",\"class YourCustomCollector extends Collector { List<MetricFamilySamples> collect() { List<MetricFamilySamples> mfs = new ArrayList<MetricFamilySamples>(); // With no labels. mfs.add(new GaugeMetricFamily(\\\"my_gauge\\\", \\\"help\\\", 42)); // With labels GaugeMetricFamily labeledGauge = new GaugeMetricFamily(\\\"my_other_gauge\\\", \\\"help\\\", Arrays.asList(\\\"labelname\\\")); labeledGauge.addMetric(Arrays.asList(\\\"foo\\\"), 4); labeledGauge.addMetric(Arrays.asList(\\\"bar\\\"), 5); mfs.add(labeledGauge); return mfs; } } \",\"实现Collector后通过register()方法，将其注册到CollectorRegistry中：\",\"// Registration static final YourCustomCollector requests = new YourCustomCollector().register() \",\"除了GaugeMetricFamily以外，client_java中该提供了对CounterMetricFamily以及SummaryMetricFamily等针对其它监控指标类型的支持。\"]},\"352\":{\"h\":\"直接在代码中集成\",\"t\":[\"除了通过实现Collector接口以外，Prometheus的Java Client还内置了多种类型构造器，如Counter、Gauge、Histogram、Summary等。 通过这些构造器，用户可以直接在业务代码中实现监控样本收集，从而可以监控程序的内部运行情况。\",\"Counter是对client_java中对Collector的一个针对计数器类型指标的封装。对于Counter而言只有一个.inc()方法用于计数+1。 例如，当需要统计对某些特定方法调用次数的统计时，可以通过以下方式实现：\",\"import io.prometheus.client.Counter; class YourClass { static final Counter requests = Counter.build() .name(\\\"requests_total\\\").help(\\\"Total requests.\\\").register(); void processRequest() { requests.inc(); // Your code here. } } \",\"Gauge是一个可增可减的仪表盘，可以通过.inc()和.dec()对样本数据进行+1或者-1。例如，可以通过Gauge统计函数中某个方法正在处理中的调用次数：\",\"class YourClass { static final Gauge inprogressRequests = Gauge.build() .name(\\\"inprogress_requests\\\").help(\\\"Inprogress requests.\\\").register(); void processRequest() { inprogressRequest.inc(); // Your code here. inprogressRequest.dec(); } } \",\"Histogram是一个自带buckets区间的用于统计分布的对象，主要用于在指定分布范围内(Buckets)记录大小或者事件发生的次数。通过构造Histogram可以记录某个方法的处理时间在Buckets上的分布情况。默认的Buckets范围为{.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10}。如果需要覆盖默认的buckets，可以使用.buckets(double… buckets)覆盖。以下代码会自动统计请求的响应时间以及请求的数据量在Buckets下的分布情况。\",\"class YourClass { static final Histogram receivedBytes = Histogram.build() .name(\\\"requests_size_bytes\\\").help(\\\"Request size in bytes.\\\").register(); static final Histogram requestLatency = Histogram.build() .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\").register(); void processRequest(Request req) { Histogram.Timer requestTimer = requestLatency.startTimer(); try { // Your code here. } finally { requestTimer.observeDuration(); receivedBytes.observe(req.size()) } } } \",\"Summary与Histogram非常类似，都可以完成对事件发生次数或者大小分布情况的统计。区别在于Summary直接在客户端完成了分位数的统计和计算,通过quantile()方法可以指定需要计算的分位数。以下代码会自动计算当前请求延迟和请求量大小的中位数以及9分位数。\",\"class YourClass { static final Summary receivedBytes = Summary.build() .quantile(0.5, 0.05) .quantile(0.9, 0.01) .name(\\\"requests_size_bytes\\\").help(\\\"Request size in bytes.\\\").register(); static final Summary requestLatency = Summary.build() .quantile(0.5, 0.05) .quantile(0.9, 0.01) .name(\\\"requests_latency_seconds\\\").help(\\\"Request latency in seconds.\\\").register(); void processRequest(Request req) { Summary.Timer requestTimer = requestLatency.startTimer(); try { // Your code here. } finally { receivedBytes.observe(req.size()); requestTimer.observeDuration(); } } } \",\"通过以上的例子，我们简单了解了通过实现Collector或者使用Counter、Guage这样的构造器均可实现自定义监控指标，并且将相应的指标样本返回给Prometheus。 接下来，将以一个具体的例子详细讲解如何在应用中实现对Prometheus的集成。\"]},\"353\":{\"h\":\"采集集群状态\"},\"354\":{\"h\":\"PromQL操作符\",\"t\":[\"PromQL除了能够对数据进行基本的查询统计以外，还支持时间序列之间进行逻辑和数学运算。这一小节中将重点介绍如何利用PromQL对时间序列进行各种逻辑和数学运算的。\"]},\"355\":{\"h\":\"数学运算符\",\"t\":[\"算术运算支持用于：标量和标量、瞬时向量和标量、瞬时向量和瞬时之间的运算。\",\"在PromQL中支持使用常用的算术运算符：\",\"+ (加法)\",\"- (减法)\",\"* (乘法)\",\"/ (除法)\",\"% (求余)\",\"^ (幂运算)\"]},\"356\":{\"h\":\"标量与标量\",\"t\":[\"标量和标量之间进行数学运算，产生一个新的标量。\",\"2 * 2 # 产生标量4 \"]},\"357\":{\"h\":\"标量与瞬时向量\",\"t\":[\"标量和瞬时向量之间进行数学运算，数学运算符将被作用于瞬时向量中的每一个样本值。并且产生一个新的瞬时向量。\",\"http_requests_total{} \",\"http_requests_total{code=\\\"200\\\",handler=\\\"alerts\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} => 1@1518145642.308 http_requests_total{code=\\\"200\\\",handler=\\\"federate\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} => 1@1518145642.308 \",\"例如，如果表达式http_requests_total{}查询出一组时间序列的瞬时样本数据，那*5操作会将每一条时间序列数据中的瞬时样本数据*5， 并且产生一组新的时间序列。\",\"http_requests_total{} * 5 \",\"返回结果：\",\"http_requests_total{code=\\\"200\\\",handler=\\\"alerts\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} => 5@1518145642.308 http_requests_total{code=\\\"200\\\",handler=\\\"federate\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} => 5@1518145642.308 \"]},\"358\":{\"h\":\"瞬时向量与瞬时向量\",\"t\":[\"两个瞬时向量之间进行数学运算，数学运算将将会作用于左边数据中的每一个样本数据，与该样本在右边数据中匹配到的样本数据之间。\",\"例如,\",\"node_disk_bytes_written + node_disk_bytes_written \",\"表达式node_disk_bytes_written返回当前主机中各个磁盘的写入数据总量的瞬时向量。\",\"node_disk_bytes_written{device=\\\"sda\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>1634967552@1518146427.807 node_disk_bytes_written{device=\\\"sdb\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>0@1518146427.807 \",\"表达式node_disk_bytes_read{}会返回，当前主机中各个磁盘的读取数据总量的瞬时向量。\",\"node_disk_bytes_read{device=\\\"sda\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>864551424@1518146427.807 node_disk_bytes_read{device=\\\"sdb\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>1744384@1518146427.807 \",\"匹配规则会比较两个表达式返回的瞬时向量中的所有标签。标签的键值对完全相等则表示匹配成功，并将运算符作用域两个匹配的样本数据中。返回一组新的瞬时向量，同时结果中会丢弃指标名称。对于没有匹配的样本数据，则不会出现在运算结果中。\",\"{device=\\\"sda\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>1634967552@1518146427.807 + 864551424@1518146427.807 {device=\\\"sdb\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>0@1518146427.807 + 1744384@1518146427.807 \",\"即结果为\",\"{device=\\\"sda\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>2499568128@1518146427.807 {device=\\\"sdb\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\"}=>1744384@1518146427.807 \"]},\"359\":{\"h\":\"比较运算符\",\"t\":[\"比较运算符运算支持：标量和标量、瞬时向量和标量、瞬时向量和瞬时向量之间的运算。\",\"目前，Prometheus支持以下，比较运算符：\",\"== (相等)\",\"!= (不相等)\",\"> (大于)\",\"< (小于)\",\">= (大于等于)\",\"<= (小于等于)\"]},\"360\":{\"h\":\"瞬时向量与标量\",\"t\":[\"瞬时向量和标量之间进行比较运算时，PromQL的默认行为会依次将瞬时向量中的所有样本与标量之间进行比较运算。如果比较结果为true则保留样本，如果比较结果为false则丢弃该样本，从而产生一条新的瞬时时间序列。\",\"例如，当需要找到当前系统请求量大于100次的处理模块，可以使用表达式：\",\"http_requests_total > 100 \",\"该表达式会过滤监控指标http_requests_total的所有时间序列，返回瞬时样本值满足条件比较条件(> 1000)的所有时间序列。\",\"http_requests_total{code=\\\"200\\\",handler=\\\"prometheus\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 36733 http_requests_total{code=\\\"200\\\",handler=\\\"prometheus\\\",instance=\\\"localhost:9100\\\",job=\\\"node_exporter\\\",method=\\\"get\\\"} 37131 http_requests_total{code=\\\"200\\\",handler=\\\"query\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 126 \"]},\"361\":{\"h\":\"使用bool改变比较运算的默认行为\",\"t\":[\"默认情况下比较运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的HTTP请求量是否>=1000，如果大于等于1000则返回1（true）否则返回0（false）。这时我们可以使用bool改变比较运算的默认行为。\",\"例如：\",\"http_requests_total > bool 100 \",\"使用bool修改比较运算的默认行为之后，比较运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1。从而形成一条新的时间序列。\",\"http_requests_total{code=\\\"200\\\",handler=\\\"query\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 1 http_requests_total{code=\\\"200\\\",handler=\\\"query_range\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\",method=\\\"get\\\"} 0 \"]},\"362\":{\"h\":\"标量和标量\",\"t\":[\"标量和标量之间进行比较运算，根据比较的结果产生一个新的标量0（false）或者1（true）用于返回比较的结果。需要注意的时，标量和标量之间进行比较时，必须使用bool进行修饰，例如：\",\"2 == bool 2 # 结果为1 \"]},\"363\":{\"h\":\"瞬时向量和瞬时向量\",\"t\":[\"瞬时向量和瞬时向量之间，进行比较运算时，根据默认的匹配规则，依次比较匹配到的样本数据。默认情况下，如果匹配到的数据比较结果为true则保留，反之则丢弃。从而形成一条新的时间序列。 同样，我们可以通过bool修饰符来改变比较运算的默认行为。\",\"例如，使用表达式获取当前正常的任务状态：\",\"up == 1 \",\"或者我们只想知道当前任务的状态是否为正常：\",\"up == bool 1 \"]},\"364\":{\"h\":\"逻辑/集合运算符\",\"t\":[\"逻辑运算符只支持在瞬时向量和瞬时向量之间使用。\",\"目前，Prometheus支持以下，比较逻辑运算符有：\",\"and (并且)\",\"or (或者)\",\"unless (排除)\",\"vector1 and vector2 会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素组成。\",\"vector1 or vector2 会产生一个新的向量，该向量包含vector1中所有的\\b样本数据，以及vector2中没有与vector1匹配到的样本数据。\",\"vector1 unless vector2 会产生一个新的向量，新向量中的元素由vector1中没有与vector2匹配的元素组成。\"]},\"365\":{\"h\":\"向量匹配模式\",\"t\":[\"向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的\\b右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。\",\"接下来将介绍在PromQL中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。\"]},\"366\":{\"h\":\"一对一匹配\",\"t\":[\"一对一\\b匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：\",\"vector1 <operator> vector2 \",\"在操作符两边表达式标签不一致的情况下，可以使用on(label list)或者ignoring(label list）来修改便签的匹配行为。使用ignoreing可以在匹配时忽略某些便签。而on则用于将匹配行为限定在某些便签之内。\",\"<vector expr> <bin-op> ignoring(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) <vector expr> \",\"例如当存在样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用PromQL表达式：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。\",\"因此结果如下：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"同时由于method为put和del的\\b样本\\b找不到匹配项，因此不会出现在结果当中。\"]},\"367\":{\"h\":\"多对一和一对多\",\"t\":[\"多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与\\\"多\\\"侧的多个元素匹配的情况。在这种情况下，必须使用group修饰符：group_left或者group_right来确定哪一个向量具有更高的基数（充当“多”的角色）。\",\"<vector expr> <bin-op> ignoring(<label list>) group_left(<label list>) <vector expr> <vector expr> <bin-op> ignoring(<label list>) group_right(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) group_left(<label list>) <vector expr> <vector expr> <bin-op> on(<label list>) group_right(<label list>) <vector expr> \",\"多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用ignoring和on修饰符来排除或者限定匹配的标签列表。\",\"例如,使用表达式：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"该表达式中，左向量method_code:http_errors:rate5m包含两个标签method和code。而右向量method:http_requests:rate5m中只包含一个标签method，因此匹配时需要使用ignoring限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用group修饰符group_left指定左向量具有更好的基数。\",\"最终的运算结果如下：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \",\"提醒：group修饰符只能在比较和数学运算符中使用。在逻辑运算and,unless和or才注意操作中默认与右向量中的所有元素进行匹配。\"]},\"368\":{\"h\":\"聚合操作\",\"t\":[\"Prometheus还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。\",\"sum (求和)\",\"min (最小值)\",\"max (最大值)\",\"avg (平均值)\",\"stddev (标准差)\",\"stdvar (标准差异)\",\"count (计数)\",\"count_values (对value进行计数)\",\"bottomk (后n条时序)\",\"topk (前n条时序)\",\"quantile (分布统计)\",\"使用聚合操作的语法如下：\",\"<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)] \",\"其中只有count_values, quantile, topk, bottomk支持参数(parameter)。\",\"without用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过without和by可以按照样本的问题对数据进行聚合。\",\"例如：\",\"sum(http_requests_total) without (instance) \",\"等价于\",\"sum(http_requests_total) by (code,handler,job,method) \",\"如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：\",\"sum(http_requests_total) \",\"count_values用于时间序列中每一个样本值出现的次数。count_values会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。\",\"例如：\",\"count_values(\\\"count\\\", http_requests_total) \",\"topk和bottomk则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。\",\"获取HTTP请求数前5位的时序样本数据，可以使用表达式：\",\"topk(5, http_requests_total) \",\"quantile用于计算当前样本数据值的分布情况quantile(φ, express)其中0 ≤ φ ≤ 1。\",\"例如，当φ为0.5时，即表示找到当前样本数据中的中位数：\",\"quantile(0.5, http_requests_total) \"]},\"369\":{\"h\":\"操作符优先级\",\"t\":[\"最后对于复杂类型的表达式，我们需要了解运算操作的优先级。\",\"例如，查询主机的CPU使用率，我们可以使用表达式：\",\"100 * (1 - avg (irate(node_cpu{mode='idle'}[5m])) by(job) ) \",\"其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。关于内置函数的部分，会在下一节详细介绍。\",\"在PromQL操作符中优先级由高到低依次为：\",\"^\",\"*, /, %\",\"+, -\",\"==, !=, <=, <, >=, >\",\"and, unless\",\"or\"]},\"370\":{\"h\":\"使用NodeExporter监控主机\",\"t\":[\"在上一小节中，我们尝试了部署Prometheus Server，并且采集了Prometheus自身的一些运行指标数据。通过Prometheus内置的UI可以对这些采集到的样本数据进行查询，过滤以及聚合，同时Prometheus内置的UI还支持简单的图形化显示需求。\",\"在Prometheus Server中将用于获取监控样本数据的服务称为一个target实例(例如Prometheus自身)。对于某些应用和服务而言它们可能内置了对Prometheus的支持，而对于没有内置Prometheus支持的监控需求，需要运行单独的采集程序，这些程序被称为Exporter，通过这些Exporter程序，可以使Prometheus可以从这些Exporter间接的获取到相应的监控数据。\",\"接下来，为了能够采集到主机的监控指标（CPU，内存，磁盘），我们需要在主机上运行一个Node Exporter程序，实现对主机监控的支持。\"]},\"371\":{\"h\":\"安装Node Exporter\"},\"372\":{\"h\":\"创建用户\",\"t\":[\"sudo useradd --no-create-home node_exporter \"]},\"373\":{\"h\":\"获取并安装软件包\",\"t\":[\"cd ~ curl -LO https://github.com/prometheus/node_exporter/releases/download/v0.15.1/node_exporter-0.15.1.linux-amd64.tar.gz tar xvf node_exporter-0.15.1.linux-amd64.tar.gz sudo cp node_exporter-0.15.1.linux-amd64/node_exporter /usr/local/bin sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter rm -rf node_exporter-0.15.1.linux-amd64.tar.gz node_exporter-0.15.1.linux-amd64 \"]},\"374\":{\"h\":\"创建Node Exporter的Service Unit文件\",\"t\":[\"sudo vim /etc/systemd/system/node_exporter.service \",\"[Unit] Description=Node Exporter Wants=network-online.target After=network-online.target [Service] User=node_exporter Group=node_exporter Type=simple ExecStart=/usr/local/bin/node_exporter [Install] WantedBy=multi-user.target \"]},\"375\":{\"h\":\"启动Node Exporter\",\"t\":[\"service node_exporter start \",\"NodeExporter启动后，访问http://192.168.33.10:9100/metrics，我们可以获取到当前NodeExporter所在主机的当前资源使用情况的监控数据。\",\"./static/node_exporter_metrics.png\"]},\"376\":{\"h\":\"配置主机监控采集任务\"},\"377\":{\"h\":\"配置Prometheus采集主机信息\",\"t\":[\"编辑配置文件/etc/prometheus/prometheus.yml，并添加以下内容：\",\" - job_name: 'node_exporter' scrape_interval: 5s static_configs: - targets: ['localhost:9100'] \",\"这里我们添加了一个新的Job名字为node_exporter。并且定义了一个实例为localhost:9100。\",\"完整的Prometheus配置文件/etc/prometheus/prometheus.yml如下：\",\"global: scrape_interval: 15s scrape_configs: - job_name: 'prometheus' scrape_interval: 5s static_configs: - targets: ['localhost:9090'] - job_name: 'node_exporter' scrape_interval: 5s static_configs: - targets: ['localhost:9100'] \",\"重新启动Prometheus Server\",\"sudo service prometheus restart \"]},\"378\":{\"h\":\"验证结果\",\"t\":[\"访问http://192.168.33.10:9090/targets查看所有的采集目标实例，这时我们可以看到新的采集任务：node_exporter以及相应的实例。\",\"./static/node_exporter_targets.png\",\"这时我们可以通过PromQL语言在，Prometheus UI上直接查询主机相关资源的使用情况。\",\"例如:\",\"按CPU模式查询主机的CPU使用率：\",\"avg without (cpu)(irate(node_cpu{mode!=\\\"idle\\\"}[5m])) \",\"查询主机CPU总体使用率：\",\"sum(avg without (cpu)(irate(node_cpu{mode!='idle'}[5m]))) by (instance) \",\"按主机查询主机内存使用量：\",\"sum(node_memory_MemTotal - node_memory_MemFree - node_memory_Buffers - node_memory_Cached) by (instance) \",\"按主机查询各个磁盘的IO状态：\",\"sum(irate(node_disk_io_time_ms{device!~'^(md\\\\\\\\\\\\\\\\d+$|dm-)'}[5m]) / 1000) by (instance, device) \"]},\"379\":{\"h\":\"新的存储层\"},\"380\":{\"h\":\"\"},\"381\":{\"h\":\"时间序列选择器\"},\"382\":{\"h\":\"瞬时向量选择器\"},\"383\":{\"h\":\"区间向量选择器\"},\"384\":{\"h\":\"位移选择器\"},\"385\":{\"h\":\"Prometheus的优势\"},\"386\":{\"h\":\"使用Prometheus监控Nginx状态\"},\"387\":{\"h\":\"从Nginx Stats获取监控样本\"},\"388\":{\"h\":\"从日志文件中获取监控样本\"},\"389\":{\"h\":\"与Prometheus集成\"},\"390\":{\"h\":\"使用Prometheus监控RabbitMQ\"},\"391\":{\"h\":\"Prometheus Standalone Environment\"},\"392\":{\"h\":\"Components\",\"t\":[\"Prometheus Server\",\"Alertmanager\",\"Node Exporter\"]},\"393\":{\"h\":\"在Kubernetes下安装部署Prometheus\",\"t\":[\"部署Prometheus\",\"kubectl create -f prometheus/prometheus-rbac-setup.yml kubectl create -f prometheus/prometheus-config.yml kubectl create -f prometheus/prometheus-deployment.yml kubectl create -f prometheus/prometheus-ingress.yml \",\"部署Exporters\",\"kubectl create -f prometheus/node-exporter-daemonset.yml kubectl create -f prometheus/blackbox-exporter-deployment.yml \",\"部署测试应用\",\"kubectl create -f nginx-deployment.yml kubectl create -f nginx/nginx-service.yml \"]},\"394\":{\"h\":\"Use Operator Manage Prometheus\"},\"395\":{\"h\":\"Prepare Helm\",\"t\":[\"brew install kubernetes-helm helm init \"]},\"396\":{\"h\":\"Kubernetes RBD\",\"t\":[\"# minikube vm docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.99.100 -e CEPH_PUBLIC_NETWORK=192.168.99.0/24 ceph/demo ceph \"]},\"397\":{\"h\":\"Install Operator\",\"t\":[\"helm repo add coreos https://s3-eu-west-1.amazonaws.com/coreos-charts/stable/ helm install coreos/prometheus-operator --name prometheus-operator --namespace monitoring helm install coreos/kube-prometheus --name kube-prometheus --set global.rbacEnable=true --namespace monitoring \"]},\"398\":{\"h\":\"Standalone Prometheus Sample\"},\"399\":{\"h\":\"Components:\",\"t\":[\"Prometheus\",\"Node Exporter\",\"cAdvisor\",\"Grafana\"]},\"400\":{\"h\":\"How To Run\",\"t\":[\"go get github.com/mattn/goreman \",\"docker volume create grafana-storage \",\"goreman -f prometheus.procfile start \"]},\"401\":{\"h\":\"Draft\"},\"402\":{\"h\":\"Ha\"},\"403\":{\"h\":\"Kubernetes\"},\"404\":{\"h\":\"Sources\"},\"405\":{\"h\":\"Examples\"}},\"dirtCount\":0,\"index\":[[\"位移选择器\",{\"0\":{\"384\":1}}],[\"位移操作的关键字为offset\",{\"1\":{\"261\":1}}],[\"~\",{\"1\":{\"373\":1,\"378\":1}}],[\"~regx进行排除\",{\"1\":{\"259\":1}}],[\"向量匹配模式\",{\"0\":{\"365\":1}}],[\"向量与向量之间进行运算操作时会基于默认的匹配规则\",{\"1\":{\"249\":1,\"365\":1}}],[\"比较逻辑运算符有\",{\"1\":{\"364\":1}}],[\"比较运算不会对时间序列进行过滤\",{\"1\":{\"361\":1}}],[\"比较运算符运算支持\",{\"1\":{\"359\":1}}],[\"比较运算符\",{\"0\":{\"359\":1},\"1\":{\"359\":1}}],[\"比如在本地\",{\"1\":{\"313\":1}}],[\"比如在aws公有云平台或者openstack的私有云平台中\",{\"1\":{\"313\":1}}],[\"比如标签\",{\"1\":{\"308\":1,\"310\":1}}],[\"比如国内的阿里云\",{\"1\":{\"307\":1}}],[\"比如与自动化配置管理工具\",{\"1\":{\"307\":1}}],[\"比如graphite\",{\"1\":{\"300\":1}}],[\"比如environment=produment\",{\"1\":{\"294\":1}}],[\"比如code=404或者content\",{\"1\":{\"294\":1}}],[\"比如cadvisor\",{\"1\":{\"277\":1}}],[\"比如主机负载异常增加\",{\"1\":{\"290\":1}}],[\"比如有些某些业务增长\",{\"1\":{\"239\":1}}],[\"比如\",{\"1\":{\"234\":3,\"269\":1}}],[\"比如某一个节点绑定了多个ip\",{\"1\":{\"130\":1}}],[\"比如mysql\",{\"1\":{\"115\":1}}],[\"比如中位数\",{\"1\":{\"95\":1}}],[\"比如记录应用请求的总量\",{\"1\":{\"95\":1}}],[\"比如用于描述告警详细信息的文字等\",{\"1\":{\"66\":1}}],[\"比如由于系统宕机导致大量的告警被同时触发\",{\"1\":{\"62\":1}}],[\"比如当接收到大量重复告警时能够消除重复的告警信息\",{\"1\":{\"60\":1}}],[\"比如系统运维\",{\"1\":{\"55\":1}}],[\"比如可以按照角色\",{\"1\":{\"55\":1}}],[\"产生标量4\",{\"1\":{\"356\":1}}],[\"产生一个新的标量\",{\"1\":{\"356\":1}}],[\"算术运算支持用于\",{\"1\":{\"355\":1}}],[\"覆盖\",{\"1\":{\"352\":1}}],[\"演示了如何在exporter中创建自定义collector\",{\"1\":{\"351\":1}}],[\"处理流程\",{\"1\":{\"350\":1}}],[\"处理集群实际\",{\"1\":{\"183\":1}}],[\"已经了解过simpleclient\",{\"1\":{\"351\":1}}],[\"已经成功完成了你的第一个exporter程序\",{\"1\":{\"349\":1}}],[\"已解决\",{\"1\":{\"26\":1}}],[\"恭喜你\",{\"1\":{\"349\":1}}],[\"架构\",{\"0\":{\"340\":1,\"345\":1}}],[\"架构设计\",{\"0\":{\"331\":1}}],[\"总结\",{\"0\":{\"327\":1,\"332\":1,\"337\":1,\"341\":1,\"346\":1}}],[\"总耗时为51\",{\"1\":{\"139\":1}}],[\"期望采集到的样本数据能定期到达\",{\"1\":{\"326\":1}}],[\"图形可视化以及基于时间序列数据的告警能力\",{\"1\":{\"324\":1}}],[\"图题\",{\"1\":{\"4\":1}}],[\"百里挑一\",{\"0\":{\"322\":1}}],[\"松耦合的架构模式更适合于云原生的部署环境\",{\"1\":{\"313\":1}}],[\"展示了push系统和pull系统的核心差异\",{\"1\":{\"313\":1}}],[\"微服务以及云模式下监控实施难度\",{\"1\":{\"313\":1}}],[\"微信针对企业的应用场景专门退出了面向企业版微信\",{\"1\":{\"73\":1}}],[\"微信已经是最大的即时通讯工具\",{\"1\":{\"73\":1}}],[\"私有云\",{\"1\":{\"313\":1}}],[\"经常会使用到例如consul这样的服务发现注册软件\",{\"1\":{\"313\":1}}],[\"显然也无法继续使用的static\",{\"1\":{\"313\":1}}],[\"显示提示框中的内容\",{\"1\":{\"138\":1}}],[\"显示告警信息\",{\"1\":{\"67\":1}}],[\"显示如下内容\",{\"1\":{\"37\":1,\"39\":1}}],[\"受监控的资源与中心监控服务器之间是一个强耦合的关系\",{\"1\":{\"313\":1}}],[\"电一样按需使用各种资源\",{\"1\":{\"313\":1}}],[\"答案还是relabeling\",{\"1\":{\"311\":1}}],[\"仅保留符合过滤条件的标签\",{\"1\":{\"310\":1}}],[\"动态的配置这些节点\",{\"1\":{\"313\":1}}],[\"动态的添加或者覆盖标签\",{\"1\":{\"310\":1}}],[\"动态标签替换\",{\"0\":{\"241\":1}}],[\"我可能只关心dev环境的监控数据\",{\"1\":{\"308\":1}}],[\"我们尝试了部署prometheus\",{\"1\":{\"370\":1}}],[\"我们尝试了使用graph面板来可视化histogram类型的监控指标prometheus\",{\"1\":{\"141\":1}}],[\"我们简单了解了通过实现collector或者使用counter\",{\"1\":{\"352\":1}}],[\"我们知道通过consul动态发现的监控target都会包含一些额外的metadata标签\",{\"1\":{\"310\":1}}],[\"我们知道counter类型的监控指标其特点是只增不减\",{\"1\":{\"238\":1}}],[\"我们实际上是希望prometheus\",{\"1\":{\"308\":1}}],[\"我们实际上使用的是promql\",{\"1\":{\"123\":1}}],[\"我们主要介绍了prometheus自身的一些特性\",{\"1\":{\"302\":1}}],[\"我们也可以访问http\",{\"1\":{\"280\":1}}],[\"我们也可以和原生prometheus\",{\"1\":{\"135\":1}}],[\"我们让prometheus可以从node\",{\"1\":{\"280\":1}}],[\"我们初步了解了prometheus以及相比于其他相似方案的优缺点\",{\"1\":{\"271\":1}}],[\"我们称之为向量\",{\"1\":{\"268\":1}}],[\"我们称为瞬时向量\",{\"1\":{\"247\":1}}],[\"我们则需要使用\",{\"1\":{\"260\":1}}],[\"我们到底应该监控哪些对象以及哪些指标\",{\"1\":{\"231\":1}}],[\"我们为promethues\",{\"1\":{\"223\":1}}],[\"我们为cadvisor定义了单独采集任务\",{\"1\":{\"190\":1}}],[\"我们就能看到当前prometheus已经能够正常的采集实例应用的相关监控数据了\",{\"1\":{\"219\":1}}],[\"我们就可以通过promql对监控样本数据进行查询\",{\"1\":{\"259\":1}}],[\"我们就可以通过volume挂载的方式\",{\"1\":{\"175\":1}}],[\"我们就可以使用client\",{\"1\":{\"95\":1}}],[\"我们在集群中对这些资源的创建\",{\"1\":{\"221\":1}}],[\"我们在prometheus配置文件中定义单独的job\",{\"1\":{\"217\":1}}],[\"我们在monitoring命名空间下创建一个prometheus实例\",{\"1\":{\"216\":1}}],[\"我们在主机上安装了一个node\",{\"1\":{\"82\":1}}],[\"我们创建一个prometheus\",{\"1\":{\"210\":1}}],[\"我们通过json配置文件\",{\"1\":{\"309\":1}}],[\"我们通过标签\",{\"1\":{\"203\":1}}],[\"我们通过dashboard来组织和管理我们的数据可视化图表\",{\"1\":{\"123\":1}}],[\"我们通常讲数据库服务部署到集群外\",{\"1\":{\"202\":1}}],[\"我们希望能有一个额外的标签dc可以表示该样本所属的数据中心\",{\"1\":{\"310\":1}}],[\"我们希望能够显示当前的最新值\",{\"1\":{\"144\":1}}],[\"我们希望能够及时的了解系统的变化\",{\"1\":{\"5\":1}}],[\"我们希望它能够相对较快的完成对用户操作的响应\",{\"1\":{\"191\":1}}],[\"我们还需要监控在云上部署的应用\",{\"1\":{\"313\":1}}],[\"我们还能找到类型为histogram的监控指标prometheus\",{\"1\":{\"230\":1}}],[\"我们还应该关注kubernetes本身的状态\",{\"1\":{\"191\":1}}],[\"我们还可能需要添加一些自定义的监控metrics实现对系统性能\",{\"1\":{\"94\":1}}],[\"我们还可以为target添加自定义的标签\",{\"1\":{\"309\":1}}],[\"我们还可以通过histogram\",{\"1\":{\"230\":1}}],[\"我们还可以通过kubernetes的api\",{\"1\":{\"190\":1}}],[\"我们还可以通过自定义的collector实现对相关业务指标的暴露\",{\"1\":{\"96\":1}}],[\"我们还可以使用内置的\",{\"1\":{\"266\":1}}],[\"我们还可以使用变量自动生成panel或者row\",{\"1\":{\"131\":1}}],[\"我们还可以使用client\",{\"1\":{\"85\":1}}],[\"我们还可以定义一个row\",{\"1\":{\"123\":1}}],[\"我们还可以定义更多的子route\",{\"1\":{\"40\":1}}],[\"我们介绍了在kubernetes下如何使用operator来有状态的运维和管理prometheus以及alertmanager等组件\",{\"1\":{\"209\":1}}],[\"我们介绍了prometheus在kubernetes下的服务发现能力\",{\"1\":{\"198\":1}}],[\"我们介绍了prometheus的四种监控指标类型\",{\"1\":{\"240\":1}}],[\"我们介绍了prometheus的服务发现能力\",{\"1\":{\"185\":1}}],[\"我们介绍了prometheus的relabeling能力\",{\"1\":{\"100\":1}}],[\"我们介绍了如何使用cadvisor监控主机中容器的运行状态\",{\"1\":{\"188\":1}}],[\"我们添加如下job配置\",{\"1\":{\"187\":1}}],[\"我们首先需要关注kubernetes的api响应时间\",{\"1\":{\"193\":1}}],[\"我们首先需要做的是\",{\"1\":{\"186\":1}}],[\"我们首先需要明确一些grafana下的基本概念\",{\"1\":{\"121\":1}}],[\"我们应该考虑\",{\"1\":{\"184\":1}}],[\"我们定义了需要创建的资源类型为deployment\",{\"1\":{\"181\":1}}],[\"我们定义了一个全局的smtp配置\",{\"1\":{\"50\":1}}],[\"我们来看alertmanager是如何基于gossip协议实现集群高可用的\",{\"1\":{\"148\":1}}],[\"我们系统学习了如果实现prometheus下各个中间的高可用部署方式\",{\"1\":{\"146\":1}}],[\"我们\\b需要显示的是当前主机当前的负载情况\",{\"1\":{\"144\":1}}],[\"我们需要了解运算操作的优先级\",{\"1\":{\"369\":1}}],[\"我们需要了解kubernetes的基本架构\",{\"1\":{\"179\":1,\"183\":1}}],[\"我们需要使用到exporter\",{\"1\":{\"285\":1}}],[\"我们需要手动移除已经运行的pod实例\",{\"1\":{\"220\":1}}],[\"我们需要手动创建prometheus的告警文件\",{\"1\":{\"213\":1}}],[\"我们需要通过服务发现自动找到所有的service信息\",{\"1\":{\"203\":1}}],[\"我们需要先了解一下kubernetes中service是如何实现负载均衡的\",{\"1\":{\"202\":1}}],[\"我们需要有明确的监控目标\",{\"1\":{\"187\":1}}],[\"我们需要综合使用白盒监控和黑盒监控模式\",{\"1\":{\"180\":1}}],[\"我们需要关注集群中各个节点的主机负载\",{\"1\":{\"180\":1,\"184\":1}}],[\"我们需要对graph图表的坐标轴显示进行优化\",{\"1\":{\"138\":1}}],[\"我们需要在主机上运行一个node\",{\"1\":{\"370\":1}}],[\"我们需要在monitoring命名空间下为创建一个名为prometheus的serviceaccount\",{\"1\":{\"219\":1}}],[\"我们需要在集群部署blackbox\",{\"1\":{\"203\":1}}],[\"我们需要在各节点中部署一个node\",{\"1\":{\"201\":1}}],[\"我们需要在axes选项中定义数据的date\",{\"1\":{\"141\":1}}],[\"我们需要在prometheus全局配置文件中通过\",{\"1\":{\"66\":1}}],[\"我们需要在channel的设置选项中使用\",{\"1\":{\"48\":1}}],[\"我们使用configmap了管理prometheus配置文件\",{\"1\":{\"220\":1}}],[\"我们使用了kubernetes内置的控制器之一deployment\",{\"1\":{\"201\":1,\"205\":1}}],[\"我们使用了如下表达式\",{\"1\":{\"127\":1}}],[\"我们使用以下promql定义\\b如何从prometheus中读取数据\",{\"1\":{\"138\":1}}],[\"我们先直接使用console\",{\"1\":{\"134\":1}}],[\"我们会发现所有通过prometheus采集的样本数据中都会包含一个名为instance的标签\",{\"1\":{\"309\":1}}],[\"我们会发现alertmanager的pod实例一直处于containercreating的状态中\",{\"1\":{\"214\":1}}],[\"我们会带读者了解prometheus的前世今生\",{\"1\":{\"270\":1}}],[\"我们会惊喜的发现prometheus中配置文件自动包含了一条名为monitoring\",{\"1\":{\"218\":1}}],[\"我们会看到告警已经处于触发状态\",{\"1\":{\"213\":1}}],[\"我们会看到以下错误提示信息\",{\"1\":{\"199\":1}}],[\"我们会看到一个空白页\",{\"1\":{\"133\":1}}],[\"我们会接收到一条告警信息如下所示\",{\"1\":{\"49\":1}}],[\"我们依然使用了job反应的是当前迭代的值\",{\"1\":{\"131\":1}}],[\"我们监控主机的资源用量\",{\"1\":{\"98\":1}}],[\"我们已经看到了类似于irate\",{\"1\":{\"237\":1}}],[\"我们已经通过prometheus\",{\"1\":{\"214\":1}}],[\"我们已经基本了解和使用过node\",{\"1\":{\"204\":1}}],[\"我们已经能够通过kubernetes自动的发现当前集群中的所有node节点\",{\"1\":{\"189\":1}}],[\"我们已经能够通过prometheus自动发现kubernetes集群中的各类资源以及其基本信息\",{\"1\":{\"187\":1}}],[\"我们已经能够在kubernetes下部署一个简单的prometheus实例\",{\"1\":{\"185\":1}}],[\"我们已经介绍过histogram的指标\",{\"1\":{\"139\":1}}],[\"我们已经带领读者大致了解了grafana的基本使用方式\",{\"1\":{\"125\":1}}],[\"我们已经初步了解了node\",{\"1\":{\"92\":1}}],[\"我们已经成功安装部署了alertmanager并且与prometheus关联\",{\"1\":{\"59\":1}}],[\"我们只能创建一个不包含任何与配置文件内容相关的prometheus实例\",{\"1\":{\"210\":1}}],[\"我们只能通过prometheus\",{\"1\":{\"70\":1}}],[\"我们只需要运行相应的监控采集程序\",{\"1\":{\"280\":1}}],[\"我们只需要修改我们的prometheus资源定义\",{\"1\":{\"214\":1}}],[\"我们只需要通过prometheus的pod服务发现模式\",{\"1\":{\"201\":1}}],[\"我们只需要对应修改prometheus的配置文件即可\",{\"1\":{\"192\":1}}],[\"我们只需要在每一个数据中心\",{\"1\":{\"169\":1}}],[\"我们只需要为receiver配置email\",{\"1\":{\"50\":1}}],[\"我们只定义了一个路由\",{\"1\":{\"40\":1}}],[\"我们可能还需要对图表进行一些更高级的定制化\",{\"1\":{\"138\":1}}],[\"我们可能会有完全不同的处理方式\",{\"1\":{\"40\":1}}],[\"我们可以获取到当前nodeexporter所在主机的当前资源使用情况的监控数据\",{\"1\":{\"375\":1}}],[\"我们可以使用表达式\",{\"1\":{\"369\":1}}],[\"我们可以使用node\",{\"1\":{\"285\":1}}],[\"我们可以更容易的对数据进行过滤\",{\"1\":{\"325\":1}}],[\"我们可以提前预测在未来什么时间节点上需要对资源进行扩容\",{\"1\":{\"289\":1}}],[\"我们可以快速了解监控样本的分布情况\",{\"1\":{\"230\":1}}],[\"我们可以轻松的了解该事件产生速率的变化\",{\"1\":{\"228\":1}}],[\"我们可以看到prometheus\",{\"1\":{\"214\":1}}],[\"我们可以看到pod中会包含一个volume配置\",{\"1\":{\"210\":1}}],[\"我们可以确保当前prometheus\",{\"1\":{\"156\":1}}],[\"我们可以绘制出表达式sum\",{\"1\":{\"135\":1}}],[\"我们可以创建多个organization\",{\"1\":{\"124\":1}}],[\"我们可以为每一个panel设置查询的数据源以及数据查询方式\",{\"1\":{\"123\":1}}],[\"我们可以为监控建立一个单独的channel用于接收各种监控信息\",{\"1\":{\"47\":1}}],[\"我们可以利用promql快速建立多个监控项\",{\"1\":{\"111\":1}}],[\"我们可以通过bool修饰符来改变比较运算的默认行为\",{\"1\":{\"363\":1}}],[\"我们可以通过指标node\",{\"1\":{\"244\":1}}],[\"我们可以通过标签选择当前prometheus需要监控的servicemonitor对象\",{\"1\":{\"218\":1}}],[\"我们可以通过为service添加特定的标签进行标记\",{\"1\":{\"207\":1}}],[\"我们可以通过minikube虚拟机的ip地址和端口32584访问到prometheus的服务\",{\"1\":{\"175\":1}}],[\"我们可以通过定义legend\",{\"1\":{\"138\":1}}],[\"我们可以通过自定义collector直接从应用程序的数据库中统计监控指标\",{\"1\":{\"96\":1}}],[\"我们可以通过企业微信来管理报警\",{\"1\":{\"51\":1}}],[\"我们可以直接基于client\",{\"1\":{\"84\":1}}],[\"我们可以手动拉高系统的cpu使用率\",{\"1\":{\"69\":1}}],[\"我们可以将一组相关的规则设置定义在一个group下\",{\"1\":{\"66\":1}}],[\"我们可以在命令行中通过curl模拟一次消息通知\",{\"1\":{\"48\":1}}],[\"我们将学习如何使用prometheus官方提供的client\",{\"1\":{\"348\":1}}],[\"我们将学习如何通过prometheus强大的relabel机制来实现以上这些具体的目标\",{\"1\":{\"308\":1}}],[\"我们将带来读者使用prometheus的这些client\",{\"1\":{\"347\":1}}],[\"我们将带领读者利用promethues提供的服务发现能力\",{\"1\":{\"198\":1}}],[\"我们将带领读者了解如何通过panel创建精美的可视化图表\",{\"1\":{\"125\":1}}],[\"我们将继续使用prometheus\",{\"1\":{\"214\":1}}],[\"我们将利用prometheus监控kubernetes\",{\"1\":{\"191\":1}}],[\"我们将利用prometheus的服务发现能力\",{\"1\":{\"187\":1,\"188\":1}}],[\"我们将在本地通过工具minikube\",{\"1\":{\"181\":1}}],[\"我们将介绍kubernetes的一些基本概念\",{\"1\":{\"171\":1}}],[\"我们将介绍如何使用prometheus\",{\"1\":{\"208\":1}}],[\"我们将介绍如何通过prometheus\",{\"1\":{\"75\":1}}],[\"我们将介绍如何将企业微信集成到alertmanager中\",{\"1\":{\"73\":1}}],[\"我们将详细介绍blackbox中常用的http探针使用方式\",{\"1\":{\"100\":1}}],[\"我们将尝试利用prometheus体系中的另一个组件alertmanager对这些触发的告警进行处理\",{\"1\":{\"70\":1}}],[\"我们将已一些实际的例子解释alertmanager的其它配置内容\",{\"1\":{\"26\":1}}],[\"我们将会在kubernetes下基于prometheus构建我们的容器云监控平台\",{\"1\":{\"1\":1}}],[\"我们如何实现对prometheus的扩展\",{\"1\":{\"5\":1}}],[\"我们的重点将放在监控告警部分\",{\"1\":{\"5\":1}}],[\"然而\",{\"1\":{\"308\":1}}],[\"然后发布到任何流行的linux\",{\"1\":{\"104\":1}}],[\"管理员可以在不重启prometheus服务的情况下动态的发现需要监控的target实例信息\",{\"1\":{\"308\":1}}],[\"腾讯云等也可以使用这种方式通过一些自定义程序与平台进行交互自动生成监控target文件\",{\"1\":{\"307\":1}}],[\"感兴趣的同学可以通过consul官方文档了解更多的详细信息\",{\"1\":{\"305\":1}}],[\"感兴趣的读者可以通过阅读prometheus的官方文档\",{\"1\":{\"242\":1}}],[\"感兴趣的读者可以自行在go语言官网了解更多内容https\",{\"1\":{\"134\":1}}],[\"感兴趣的读者可以自行尝试\",{\"1\":{\"112\":1}}],[\"感兴趣的读者可以从blackbox的github项目中获取更多使用信息\",{\"1\":{\"103\":1}}],[\"被大量应用于基于微服务的软件架构当中\",{\"1\":{\"304\":1}}],[\"灵活的查询语言promql\",{\"1\":{\"302\":1}}],[\"易于集成\",{\"0\":{\"298\":1}}],[\"易于管理\",{\"0\":{\"292\":1}}],[\"高效\",{\"0\":{\"296\":1}}],[\"高可用方案选择\",{\"0\":{\"157\":1}}],[\"强大的查询语言promql\",{\"0\":{\"295\":1}}],[\"强大的数据模型\",{\"0\":{\"294\":1}}],[\"裁剪\",{\"1\":{\"294\":1}}],[\"测试\",{\"1\":{\"311\":1}}],[\"测试环境\",{\"1\":{\"292\":1}}],[\"测试消息\",{\"1\":{\"30\":1,\"48\":1}}],[\"缓存等等\",{\"1\":{\"292\":1}}],[\"缓冲池使用情况以及查询执行性能等\",{\"1\":{\"108\":1}}],[\"他们可能各自部署的自己的prometheus\",{\"1\":{\"311\":1}}],[\"他们无法了解主机上服务真正的运行情况\",{\"1\":{\"290\":1}}],[\"他们看到的依然是一个黑盒\",{\"1\":{\"290\":1}}],[\"他们更关注通过容器启动服务所需的时间\",{\"1\":{\"193\":1}}],[\"问题定位难度大\",{\"1\":{\"290\":1}}],[\"运维\",{\"1\":{\"311\":1}}],[\"运维管理难度大\",{\"1\":{\"290\":1}}],[\"运行main函数\",{\"1\":{\"349\":1}}],[\"运行node\",{\"1\":{\"285\":1}}],[\"运行的pod以及进行则通过template进行定义\",{\"1\":{\"181\":1}}],[\"运行的副本数量以及升级策略等等信息\",{\"1\":{\"178\":1}}],[\"运行多个命令\",{\"1\":{\"151\":1}}],[\"运行send\",{\"1\":{\"150\":1}}],[\"运行blackbox\",{\"1\":{\"99\":1}}],[\"运行customexporter并访问http\",{\"1\":{\"86\":1}}],[\"运行命令后查看cpu使用率情况\",{\"1\":{\"69\":1}}],[\"运行并启动dingtalk\",{\"1\":{\"34\":1}}],[\"好比客户可能关注的是服务的可用性\",{\"1\":{\"290\":1}}],[\"好消息是cadvisor已经内置了对prometheus的支持\",{\"1\":{\"105\":1}}],[\"往往并不能很好的解决上述问题\",{\"1\":{\"290\":1}}],[\"往往可能会包含来自多个data\",{\"1\":{\"123\":1}}],[\"避免出现对业务的影响\",{\"1\":{\"289\":1}}],[\"避免一次性接受大量的告警通知\",{\"1\":{\"62\":1}}],[\"长期趋势分析\",{\"1\":{\"289\":1}}],[\"长尾问题\",{\"1\":{\"238\":2}}],[\"又例如node\",{\"1\":{\"286\":1}}],[\"又可以分为\",{\"1\":{\"115\":1}}],[\"拉取监控样本数据\",{\"1\":{\"285\":1}}],[\"邀请成员\",{\"1\":{\"283\":1}}],[\"帮助用户进一步对时序数据进行处理\",{\"1\":{\"282\":1}}],[\"帮助用户创建\",{\"1\":{\"221\":1}}],[\"形成了基于中央化的规则计算\",{\"1\":{\"291\":1}}],[\"形成了主机负载随时间变化的趋势图表\",{\"1\":{\"282\":1}}],[\"形成一条新的时间序列\",{\"1\":{\"262\":1}}],[\"形成一个新的时间序列\",{\"1\":{\"226\":1,\"368\":1}}],[\"切换到graph面板\",{\"1\":{\"282\":1}}],[\"切换到alerts标签http\",{\"1\":{\"69\":1}}],[\"原有监控目标并不直接支持prometheus\",{\"1\":{\"277\":1}}],[\"间接采集\",{\"1\":{\"277\":2}}],[\"你可以根据自己的喜好使用maven或者gradle创建应用程序\",{\"1\":{\"349\":1}}],[\"你可以更容易的查看监控目标实例的健康状态\",{\"1\":{\"313\":1}}],[\"你可以在任何地方\",{\"1\":{\"313\":1}}],[\"你可以通过任意的方式将监控target的信息写入即可\",{\"1\":{\"307\":1}}],[\"你可以看到以下输出内容\",{\"1\":{\"273\":1}}],[\"你还可能看到如下监控指标\",{\"1\":{\"286\":1}}],[\"你应该监控可用连接的数量\",{\"1\":{\"110\":1}}],[\"正是利用了hashmod的能力在target实例级别实现对采集任务的功能分区的\",{\"1\":{\"312\":1}}],[\"正常的情况下\",{\"1\":{\"273\":1}}],[\"正如use方法的名字所表示的含义\",{\"1\":{\"236\":1}}],[\"解压并将命令行工具放到系统path路径下即可\",{\"1\":{\"305\":1}}],[\"解压并且添加基本的配置即可正常启动prometheus\",{\"1\":{\"272\":1}}],[\"解压即可运行\",{\"1\":{\"285\":1}}],[\"解压后当前目录会包含默认的prometheus配置文件prometheus\",{\"1\":{\"273\":1}}],[\"解压\",{\"1\":{\"273\":1}}],[\"解决了基于容器应用程序的调度\",{\"1\":{\"177\":1}}],[\"解决prometheus的持久化问题\",{\"1\":{\"168\":1}}],[\"命名\",{\"1\":{\"268\":1}}],[\"命名空间\",{\"1\":{\"178\":1}}],[\"浮点数则是该监控样本的具体值\",{\"1\":{\"267\":1}}],[\"均为合法的表达式\",{\"1\":{\"266\":1}}],[\"均是源自google内部多年的运维经验\",{\"1\":{\"172\":1}}],[\"合法\",{\"1\":{\"266\":5}}],[\"合法的promql表达式\",{\"0\":{\"266\":1}}],[\"合理设置抑制规则可以减少垃圾告警的产生\",{\"1\":{\"26\":1}}],[\"依次比较匹配到的样本数据\",{\"1\":{\"363\":1}}],[\"依次找到与左边向量元素匹配\",{\"1\":{\"244\":1,\"245\":1,\"249\":1,\"365\":1}}],[\"依然是瞬时向量\",{\"1\":{\"264\":1}}],[\"没有时序\",{\"1\":{\"264\":1}}],[\"年\",{\"1\":{\"260\":1}}],[\"周\",{\"1\":{\"260\":1}}],[\"天\",{\"1\":{\"260\":1}}],[\"天降奇兵\",{\"0\":{\"270\":1},\"1\":{\"8\":1,\"20\":1}}],[\"唯一标识\",{\"1\":{\"294\":1}}],[\"唯一需要的就是本地磁盘\",{\"1\":{\"292\":1}}],[\"唯一定义一条时间序列\",{\"1\":{\"258\":1}}],[\"唯一的区别在于counter实例只包含一个inc\",{\"1\":{\"89\":1}}],[\"起始时间\",{\"1\":{\"257\":1}}],[\"格式如上小节所示\",{\"1\":{\"256\":1}}],[\"格式化时间序列\",{\"0\":{\"77\":1}}],[\"响应数据类型\",{\"0\":{\"256\":1}}],[\"超时设置\",{\"1\":{\"255\":1,\"257\":1}}],[\"超时时间\",{\"1\":{\"99\":1}}],[\"瞬时向量选择器\",{\"0\":{\"382\":1}}],[\"瞬时向量和瞬时向量之间\",{\"1\":{\"363\":1}}],[\"瞬时向量和瞬时向量之间的运算\",{\"1\":{\"359\":1}}],[\"瞬时向量和瞬时向量\",{\"0\":{\"363\":1}}],[\"瞬时向量和瞬时之间的运算\",{\"1\":{\"355\":1}}],[\"瞬时向量和标量之间进行比较运算时\",{\"1\":{\"360\":1}}],[\"瞬时向量和标量\",{\"1\":{\"355\":1,\"359\":1}}],[\"瞬时向量表达式\",{\"1\":{\"260\":1,\"261\":1}}],[\"瞬时向量\",{\"1\":{\"256\":1,\"260\":1}}],[\"瞬时向量与标量\",{\"0\":{\"360\":1}}],[\"瞬时向量与标量进行布尔运算时\",{\"1\":{\"245\":1}}],[\"瞬时向量与瞬时向量\",{\"0\":{\"358\":1}}],[\"瞬时向量与瞬时向量直接进行布尔运算时\",{\"1\":{\"245\":1}}],[\"瞬时数据查询\",{\"0\":{\"255\":1}}],[\"右向量中的元素可能匹配到多个左向量中的元素\",{\"1\":{\"251\":1,\"367\":1}}],[\"左向量method\",{\"1\":{\"251\":1,\"367\":1}}],[\"充当\",{\"1\":{\"251\":1,\"367\":1}}],[\"必须使用bool进行修饰\",{\"1\":{\"362\":1}}],[\"必须使用group修饰符\",{\"1\":{\"251\":1,\"367\":1}}],[\"必须按照分位数quantile和分布le的值的递增顺序排序\",{\"1\":{\"116\":1}}],[\"侧的多个元素匹配的情况\",{\"1\":{\"251\":1,\"367\":1}}],[\"侧的每一个向量元素可以与\",{\"1\":{\"251\":1,\"367\":1}}],[\"或昨天一天的区间内的样本数据呢\",{\"1\":{\"261\":1}}],[\"或一对多\",{\"1\":{\"249\":1,\"365\":1}}],[\"或者我们只想知道当前任务的状态是否为正常\",{\"1\":{\"363\":1}}],[\"或者1\",{\"1\":{\"362\":1}}],[\"或者服务\",{\"1\":{\"351\":1}}],[\"或者开发自己的监控数据收集程序\",{\"1\":{\"298\":1}}],[\"或者同一个采集进程的多个副本则通过一个一个任务\",{\"1\":{\"280\":1}}],[\"或者一个不会匹配到空字符串的标签过滤器\",{\"1\":{\"266\":1}}],[\"或者一组\",{\"1\":{\"178\":1,\"180\":1}}],[\"或者ignoring\",{\"1\":{\"250\":1,\"366\":1}}],[\"或者后n位的时间序列\",{\"1\":{\"226\":1,\"368\":1}}],[\"或者对http版本有特殊要求\",{\"1\":{\"103\":1,\"318\":1}}],[\"或者通过bearer\",{\"1\":{\"102\":1,\"317\":1}}],[\"或者事件发生的次数\",{\"1\":{\"95\":1}}],[\"或者容器当前的cpu使用率\",{\"1\":{\"95\":1}}],[\"或者\",{\"1\":{\"48\":1,\"247\":1,\"364\":1}}],[\"或者弹性伸缩等\",{\"1\":{\"27\":1}}],[\"或者直接使用英文\",{\"1\":{\"4\":1}}],[\"匹配规则会比较两个表达式返回的瞬时向量中的所有标签\",{\"1\":{\"358\":1}}],[\"匹配模式详解\",{\"0\":{\"249\":1}}],[\"匹配出ip地址和端口\",{\"1\":{\"190\":1}}],[\"操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项\",{\"1\":{\"250\":1,\"366\":1}}],[\"操作符优先级\",{\"0\":{\"248\":1,\"369\":1}}],[\"操作系统\",{\"1\":{\"181\":1}}],[\"排除\",{\"1\":{\"247\":1,\"364\":1}}],[\"布尔运算不会对时间序列进行过滤\",{\"1\":{\"246\":1}}],[\"布尔运算符的默认行为是对时序数据进行过滤\",{\"1\":{\"246\":1}}],[\"布尔运算符等等\",{\"1\":{\"243\":1}}],[\"同样\",{\"1\":{\"363\":1}}],[\"同样遵循默认的匹配模式\",{\"1\":{\"245\":1}}],[\"同年6月正式发布1\",{\"1\":{\"288\":1}}],[\"同时结果中会丢弃指标名称\",{\"1\":{\"358\":1}}],[\"同时具有支持扩展以及集群的商业版本\",{\"1\":{\"328\":1}}],[\"同时更容易运行以及集成到现有的环境中\",{\"1\":{\"327\":1}}],[\"同时这些客户端收集的监控数据\",{\"1\":{\"298\":1}}],[\"同时由于method为put和del的\\b样本\\b找不到匹配项\",{\"1\":{\"250\":1,\"366\":1}}],[\"同时由于promethus高效的数据处理能力\",{\"1\":{\"145\":1}}],[\"同时需要注意的是\",{\"1\":{\"246\":1}}],[\"同时新的时间序列将不会包含指标名称\",{\"1\":{\"244\":1}}],[\"同时分位数的计算\",{\"1\":{\"240\":1}}],[\"同时告警监控也是依赖promql实现的\",{\"1\":{\"224\":1}}],[\"同时promql也被应用于数据可视化\",{\"1\":{\"295\":1}}],[\"同时promql中还提供了大量的内置函数可以实现对数据的高级处理\",{\"1\":{\"224\":1}}],[\"同时prometheus内置的ui还支持简单的图形化显示需求\",{\"1\":{\"370\":1}}],[\"同时prometheus还提供了一个独立的基于ruby\",{\"1\":{\"299\":1}}],[\"同时prometheus还支持与其他的监控系统进行集成\",{\"1\":{\"298\":1}}],[\"同时prometheus提供的强大的promql可以实现对数据的个性化处理\",{\"1\":{\"231\":1}}],[\"同时prometheus会自动将该资源的所有信息\",{\"1\":{\"187\":1}}],[\"同时prometheus\",{\"1\":{\"154\":1}}],[\"同时使用kubernetes\",{\"1\":{\"217\":1}}],[\"同时使用也会有许多问题\",{\"1\":{\"120\":1}}],[\"同时yaml文件中也创建了nodeexporter相应的service\",{\"1\":{\"201\":1,\"205\":1}}],[\"同时创建prometheus所使用的账号\",{\"1\":{\"186\":1}}],[\"同时kubernetes也提供了一个dashboard管理界面\",{\"1\":{\"181\":1}}],[\"同时通过一个简单的例子带领读者快速了解prometheus是如何工作的\",{\"1\":{\"270\":1}}],[\"同时通过内置的预测函数\",{\"1\":{\"225\":1}}],[\"同时通过服务blackbox\",{\"1\":{\"203\":1}}],[\"同时通过labelmap步骤\",{\"1\":{\"199\":1}}],[\"同时通过在节点上部署node\",{\"1\":{\"180\":1}}],[\"同时通过notifier包的send方法将告警通知发送给dingtalk群聊机器人\",{\"1\":{\"33\":1}}],[\"同时我们介绍了prometheus的生态以及核心能力\",{\"1\":{\"271\":1}}],[\"同时我们还将学习如何通过prometheus\",{\"1\":{\"171\":1}}],[\"同时我们也能快速的从中找到我们希望的dashboard实现\",{\"1\":{\"123\":1}}],[\"同时将\",{\"1\":{\"199\":1,\"203\":1}}],[\"同时将prometheus\",{\"1\":{\"169\":1}}],[\"同时将数据转换为prometheus的原始样本数据返回给prometheus\",{\"1\":{\"164\":1}}],[\"同时删除prometheus的data目录\",{\"1\":{\"167\":1}}],[\"同时也无法灵活扩展和迁移\",{\"1\":{\"162\":1}}],[\"同时能够满足大部分用户监控规模的需求\",{\"1\":{\"162\":1}}],[\"同时能够确保prometheus\",{\"1\":{\"154\":1}}],[\"同时该存储方式可以简化历史数据的删除逻辑\",{\"1\":{\"159\":1}}],[\"同时确保了数据的持久化\",{\"1\":{\"154\":1}}],[\"同时定义告警规则文件\",{\"1\":{\"151\":1}}],[\"同时基于alertmanager的告警分组机制即使不同的prometheus\",{\"1\":{\"147\":1}}],[\"同时给出了集中常用的高可用方案\",{\"1\":{\"146\":1}}],[\"同时减少高可用\",{\"1\":{\"145\":1}}],[\"同时\",{\"1\":{\"136\":1,\"266\":1}}],[\"同时grafana通过json\\b数据结构管理了整个dasboard的定义\",{\"1\":{\"123\":1}}],[\"同时http响应头还需要指定压缩格式为gzip\",{\"1\":{\"117\":1}}],[\"同时必须包含一个样本x\",{\"1\":{\"116\":1}}],[\"同时用户也无法通过直接从操作系统层面上提供对prometheus的支持\",{\"1\":{\"115\":1}}],[\"同时很多查询命令会直接在磁盘中执行\",{\"1\":{\"111\":1}}],[\"同时如果aborted\",{\"1\":{\"110\":1}}],[\"同时connection\",{\"1\":{\"110\":1}}],[\"同时cadvisor默认只保存2分钟的监控数据\",{\"1\":{\"105\":1}}],[\"同时summary和histogram都可以计算和统计样本的分布情况\",{\"1\":{\"95\":1}}],[\"同时在labels列下会包含用户添加的自定义标签\",{\"1\":{\"307\":1}}],[\"同时在endpoints中指定port名称为web的端口\",{\"1\":{\"217\":1}}],[\"同时在样本计数时\",{\"1\":{\"89\":1}}],[\"同时在告警规则中定义了告警级别severity=critical\",{\"1\":{\"36\":1}}],[\"同时对于histogram的指标\",{\"1\":{\"230\":1}}],[\"同时对于prometheus\",{\"1\":{\"148\":1}}],[\"同时对于已经pending或者firing的告警\",{\"1\":{\"68\":1}}],[\"同时对告警信息进行分组并且路由到正确的通知方\",{\"1\":{\"60\":1}}],[\"同时alertmanager的ui也会根据这两个标签值\",{\"1\":{\"67\":1}}],[\"同时alertmanager还提供了静默和告警抑制机制来对告警通知行为进行优化\",{\"1\":{\"60\":1}}],[\"同时还可以通过为这些实例添加一些额外的标签信息\",{\"1\":{\"307\":1}}],[\"同时还可以通过labels为这些样本添加额外的标签\",{\"1\":{\"72\":1}}],[\"同时还可以利用饱和度对系统做出预测\",{\"1\":{\"234\":1}}],[\"同时还有第三方实现的如\",{\"1\":{\"114\":1}}],[\"同时还支持与webhook的集成\",{\"1\":{\"60\":1}}],[\"同时还提供了对webhook通知的支持\",{\"1\":{\"24\":1}}],[\"同时其提供了强大的集成能力\",{\"1\":{\"46\":1}}],[\"同时其还提供了简单有效的扩展方式\",{\"1\":{\"25\":1}}],[\"同时了解如何在现有应用系统上添加对prometheus支持\",{\"1\":{\"5\":1}}],[\"同时了解如何使用alertmanager对告警进行处理\",{\"1\":{\"5\":1}}],[\"同时会学习到如何利用prometheus的数据查询语言prmql\",{\"1\":{\"5\":1}}],[\"幂运算\",{\"1\":{\"244\":1,\"355\":1}}],[\"求余\",{\"1\":{\"244\":1,\"355\":1}}],[\"求和\",{\"1\":{\"226\":1,\"368\":1}}],[\"乘法\",{\"1\":{\"244\":1,\"355\":1}}],[\"减法\",{\"1\":{\"244\":1,\"355\":1}}],[\"减少时间序列的数量效果更明显\",{\"1\":{\"160\":1}}],[\"加法\",{\"1\":{\"244\":1,\"355\":1}}],[\"加入这个时间轴控制器的方式也很简单\",{\"1\":{\"135\":1}}],[\"过滤以及聚合\",{\"1\":{\"370\":1}}],[\"过滤\",{\"1\":{\"282\":1,\"294\":1,\"295\":1}}],[\"过程会相对复杂一点\",{\"1\":{\"244\":1}}],[\"过去10秒容器cpu的平均负载\",{\"1\":{\"105\":1}}],[\"逻辑\",{\"0\":{\"364\":1}}],[\"逻辑运算符只支持在瞬时向量和瞬时向量之间使用\",{\"1\":{\"364\":1}}],[\"逻辑运算符\",{\"1\":{\"243\":1}}],[\"逻辑数据\",{\"1\":{\"159\":1}}],[\"数以百万的监控指标\",{\"1\":{\"296\":1}}],[\"数字以及下划线组成并满足正则表达式\",{\"1\":{\"269\":1}}],[\"数字\",{\"1\":{\"269\":1}}],[\"数学运算将将会作用于左边数据中的每一个样本数据\",{\"1\":{\"358\":1}}],[\"数学运算\",{\"0\":{\"244\":1}}],[\"数学运算符将被作用于瞬时向量中的每一个样本值\",{\"1\":{\"357\":1}}],[\"数学运算符会依次作用于瞬时向量中的每一个样本值\",{\"1\":{\"244\":1}}],[\"数学运算符\",{\"0\":{\"355\":1},\"1\":{\"243\":1}}],[\"数据模型\",{\"0\":{\"325\":1,\"330\":1,\"335\":1,\"344\":1}}],[\"数据可视化\",{\"1\":{\"289\":1}}],[\"数据可能增加也可能减少\",{\"1\":{\"286\":1}}],[\"数据持久化\",{\"1\":{\"157\":1}}],[\"数据丢失后无法恢复\",{\"1\":{\"153\":1}}],[\"数据源\",{\"0\":{\"122\":1},\"1\":{\"198\":1}}],[\"数据库\",{\"1\":{\"114\":1,\"292\":1}}],[\"数据库的稳定运行是保证业务可用性的关键因素之一\",{\"1\":{\"107\":1}}],[\"数据库中间件的运行数据\",{\"1\":{\"98\":1}}],[\"数据库管理员\",{\"1\":{\"55\":1}}],[\"数据的collector实现\",{\"1\":{\"87\":1}}],[\"数据与可视化\",{\"1\":{\"9\":1,\"21\":1}}],[\"了解这些函数的使用方式\",{\"1\":{\"242\":1}}],[\"了解以上基础知识以后\",{\"1\":{\"192\":1}}],[\"日期等等\",{\"1\":{\"242\":1}}],[\"日志\",{\"1\":{\"114\":1}}],[\"时\",{\"1\":{\"280\":1}}],[\"时间序列选择器\",{\"0\":{\"381\":1}}],[\"时间序列将包含一个host标签\",{\"1\":{\"241\":1}}],[\"时间戳\",{\"1\":{\"268\":1}}],[\"时间\",{\"1\":{\"268\":1}}],[\"时间位移操作\",{\"0\":{\"261\":1}}],[\"时间范围通过时间范围选择器\",{\"1\":{\"260\":1}}],[\"时序数据库\",{\"1\":{\"227\":1}}],[\"系统负载\",{\"1\":{\"286\":1}}],[\"系统cpu使用量\",{\"1\":{\"286\":1}}],[\"系统cpu使用率\",{\"1\":{\"282\":1}}],[\"系统启动时间\",{\"1\":{\"286\":1}}],[\"系统的负载情况会随系统资源的使用而变化\",{\"1\":{\"286\":1}}],[\"系统各mode的cpu使用率\",{\"1\":{\"282\":1}}],[\"系统进程的cpu使用率\",{\"1\":{\"282\":1}}],[\"系统就已经不可用了\",{\"1\":{\"239\":1}}],[\"系统管理员为了确保业务的持续可用运行\",{\"1\":{\"239\":1}}],[\"预测在4小时后\",{\"1\":{\"295\":1}}],[\"预测gauge指标变化趋势\",{\"0\":{\"239\":1}}],[\"预测系统磁盘空间在4个小时之后的剩余情况\",{\"1\":{\"229\":1}}],[\"容易陷入\",{\"1\":{\"238\":1}}],[\"容器云以及专门的服务发现注册中心集成以外\",{\"1\":{\"313\":1}}],[\"容器场景下监控的挑战\",{\"1\":{\"302\":1}}],[\"容器\",{\"1\":{\"232\":1}}],[\"容器基础设施\",{\"1\":{\"180\":1}}],[\"容器文件系统写入速率\",{\"1\":{\"106\":1}}],[\"容器文件系统读取速率\",{\"1\":{\"106\":1}}],[\"容器网络传输量\",{\"1\":{\"106\":1}}],[\"容器网络接收量\",{\"1\":{\"106\":1}}],[\"容器网络累积传输数据总量\",{\"1\":{\"105\":1}}],[\"容器网络累积接收数据总量\",{\"1\":{\"105\":1}}],[\"容器cpu使用率\",{\"1\":{\"106\":1}}],[\"容器当前的内存使用量\",{\"1\":{\"105\":1}}],[\"容器的内存使用量限制\",{\"1\":{\"105\":1}}],[\"容器的最大内存使用量\",{\"1\":{\"105\":1}}],[\"容器的运行状态\",{\"1\":{\"98\":1}}],[\"容器累积写入数据的总量\",{\"1\":{\"105\":1}}],[\"容器累积读取数据的总量\",{\"1\":{\"105\":1}}],[\"容器可以使用的文件系统总量\",{\"1\":{\"105\":1}}],[\"容器中文件系统的使用量\",{\"1\":{\"105\":1}}],[\"容器在每个cpu内核上的累积占用时间\",{\"1\":{\"105\":1}}],[\"容器镜像正成为一个新的标准化软件交付方式\",{\"1\":{\"104\":1}}],[\"容器以及源码方式安装\",{\"1\":{\"52\":1}}],[\"容器监控\",{\"0\":{\"104\":1},\"1\":{\"9\":1,\"21\":1}}],[\"识别资源瓶颈\",{\"1\":{\"236\":1}}],[\"网卡在数据包传输过程中检测到的以太网网络冲突了14次\",{\"1\":{\"236\":1}}],[\"网络带宽\",{\"1\":{\"286\":1}}],[\"网络硬件\",{\"1\":{\"232\":1}}],[\"网络协议\",{\"1\":{\"232\":1}}],[\"网络\",{\"1\":{\"232\":1,\"236\":1,\"313\":1}}],[\"网络等资源的使用情况\",{\"1\":{\"188\":1}}],[\"网络io总量以及磁盘io总量等信息\",{\"1\":{\"104\":1}}],[\"网络探测\",{\"0\":{\"98\":1},\"1\":{\"9\":1,\"21\":1}}],[\"任何资源在某种程度上的饱和都可能导致系统性能的下降\",{\"1\":{\"236\":1}}],[\"任务和实例\",{\"0\":{\"280\":1},\"1\":{\"8\":1,\"20\":1}}],[\"磁盘\",{\"1\":{\"370\":1}}],[\"磁盘空间占用大致会是什么情况\",{\"1\":{\"295\":1}}],[\"磁盘io\",{\"1\":{\"286\":1}}],[\"磁盘等信息\",{\"1\":{\"285\":1}}],[\"磁盘等等\",{\"1\":{\"236\":1}}],[\"磁盘是否可能在4个小时候就满了\",{\"1\":{\"234\":1}}],[\"耗时\",{\"1\":{\"235\":1}}],[\"耗时2\",{\"1\":{\"230\":1}}],[\"速率\",{\"1\":{\"235\":1}}],[\"细化和总结的方法论\",{\"1\":{\"235\":1}}],[\"衡量当前服务的饱和度\",{\"1\":{\"234\":1}}],[\"衡量当前系统错误发生的速率\",{\"1\":{\"234\":1}}],[\"饱和度\",{\"1\":{\"234\":1,\"236\":2}}],[\"流量通常是每秒http请求数\",{\"1\":{\"234\":1}}],[\"流量对于不同类型的系统而言可能代表不同的含义\",{\"1\":{\"234\":1}}],[\"快速失败\",{\"1\":{\"234\":1}}],[\"快速开始\",{\"0\":{\"133\":1}}],[\"记录并且管理了环境中所有服务的信息\",{\"1\":{\"306\":1}}],[\"记录用户所有请求所需的时间\",{\"1\":{\"234\":1}}],[\"记录大小或者事件发生的次数\",{\"1\":{\"352\":1}}],[\"记录大小\",{\"1\":{\"95\":1}}],[\"业务影响等层面的问题\",{\"1\":{\"234\":1}}],[\"编译后的软件包\",{\"1\":{\"272\":1}}],[\"编排工具\",{\"1\":{\"232\":1}}],[\"编辑配置文件\",{\"1\":{\"377\":1}}],[\"编辑prometheus\",{\"1\":{\"287\":1}}],[\"编辑prometheus配置文件prometheus\",{\"1\":{\"58\":1}}],[\"编辑页面\",{\"1\":{\"144\":1}}],[\"代码中集成prmometheus\",{\"1\":{\"232\":2}}],[\"代理对集群外部服务的请求\",{\"1\":{\"202\":1}}],[\"代理对集群内部应用pod实例的请求\",{\"1\":{\"202\":1}}],[\"延迟\",{\"1\":{\"232\":1,\"234\":2}}],[\"资源使用情况\",{\"1\":{\"289\":1}}],[\"资源用量\",{\"1\":{\"232\":3}}],[\"资源的创建和销毁成本变得更加频繁\",{\"1\":{\"5\":1}}],[\"交换机等\",{\"1\":{\"232\":1}}],[\"级别\",{\"1\":{\"232\":1}}],[\"区间数据查询\",{\"0\":{\"257\":1}}],[\"区间向量选择器\",{\"0\":{\"383\":1}}],[\"区间向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围\",{\"1\":{\"260\":1}}],[\"区间向量表达式\",{\"1\":{\"260\":1,\"261\":1}}],[\"区间向量\",{\"1\":{\"256\":1,\"260\":1}}],[\"区间通过标签len进行定义\",{\"1\":{\"230\":1}}],[\"区别在于summary直接在客户端完成了分位数的统计和计算\",{\"1\":{\"352\":1}}],[\"区别在于summary是直接在客户端计算了数据分布的分位数情况\",{\"1\":{\"240\":1}}],[\"区别在于summary可以指定在客户端统计的分位数\",{\"1\":{\"90\":1}}],[\"统一分析和告警的新模型\",{\"1\":{\"291\":1}}],[\"统一管理的云操作系统\",{\"1\":{\"180\":1,\"182\":1}}],[\"统计从而产生新的计算后的一条时间序列\",{\"1\":{\"258\":1}}],[\"统计histogram指标的分位数\",{\"0\":{\"240\":1}}],[\"统计延迟在010ms之间的请求数有多少而1020ms之间的请求数又有多少\",{\"1\":{\"230\":1}}],[\"页面的平均响应时间\",{\"1\":{\"230\":1}}],[\"甚至是直接使用predict\",{\"1\":{\"229\":1}}],[\"甚至是直接使用emoji\",{\"1\":{\"144\":1}}],[\"摘要\",{\"1\":{\"227\":1}}],[\"随着时间的变化这个指标返回的样本数据是在不断变化的\",{\"1\":{\"227\":1}}],[\"随机的从其它节点b并向其发送相应的消息\",{\"1\":{\"148\":1}}],[\"≤\",{\"1\":{\"226\":2,\"368\":2}}],[\"φ\",{\"1\":{\"226\":2,\"240\":1,\"368\":2}}],[\"前面部分介绍了prometheus的数据存储模型以及4种指标类型\",{\"1\":{\"231\":1}}],[\"前n条时序\",{\"1\":{\"226\":1,\"368\":1}}],[\"前上一小节已经讲过\",{\"1\":{\"43\":1}}],[\"深入promql\",{\"1\":{\"224\":1}}],[\"简言之\",{\"1\":{\"222\":1}}],[\"简单性一致是prometheus设计的基本原则\",{\"1\":{\"146\":1}}],[\"简单类型gauge和counter\",{\"0\":{\"89\":1}}],[\"列出了prometheus\",{\"1\":{\"222\":1}}],[\"保存prometheus变更到集群中\",{\"1\":{\"219\":1}}],[\"保存以上内容到example\",{\"1\":{\"217\":1}}],[\"保存变量后\",{\"1\":{\"130\":1}}],[\"大量的监控任务必然导致有大量的数据产生\",{\"1\":{\"296\":1}}],[\"大量的采集任务\",{\"1\":{\"155\":1}}],[\"大部分的监控能力都是围绕系统的一些边缘性的问题\",{\"1\":{\"290\":1}}],[\"大括号中的标签则反映了当前样本的一些特征和维度\",{\"1\":{\"267\":1}}],[\"大于等于\",{\"1\":{\"245\":1,\"359\":1}}],[\"大于\",{\"1\":{\"245\":1,\"359\":1}}],[\"大大简化了kubernetes下的prometheus运维管理的复杂度\",{\"1\":{\"214\":1}}],[\"到目前为止\",{\"1\":{\"214\":1}}],[\"到外部部署的pushgateway服务中\",{\"1\":{\"91\":1}}],[\"声明式的创建和管理alertmanager实例\",{\"1\":{\"222\":1}}],[\"声明式创建和管理prometheus\",{\"1\":{\"222\":1}}],[\"声明式创建的一个资源\",{\"1\":{\"213\":1}}],[\"声明监控指标的标签\",{\"1\":{\"89\":1}}],[\"观察配置文件变化即可\",{\"1\":{\"210\":1}}],[\"省略其它gradle配置\",{\"1\":{\"349\":1}}],[\"省略其它内容\",{\"1\":{\"210\":1}}],[\"省略的代码\",{\"1\":{\"95\":11,\"96\":2}}],[\"生成文件内容的base64编码后的内容\",{\"1\":{\"210\":1}}],[\"所以返回的metadata标签中包含了关联的service的信息\",{\"1\":{\"207\":1}}],[\"所有环境的exporter实例都会注册到该服务发现注册中心中\",{\"1\":{\"311\":1}}],[\"所有采集的监控数据均以指标\",{\"1\":{\"294\":1}}],[\"所有的监控对象\",{\"1\":{\"313\":1}}],[\"所有的服务都可以使用name\",{\"1\":{\"305\":1}}],[\"所有的样本除了基本的指标名称以外\",{\"1\":{\"294\":1}}],[\"所有的指标\",{\"1\":{\"269\":1}}],[\"所有的promql表达式都必须至少包含一个指标名称\",{\"1\":{\"266\":1}}],[\"所有的api请求均使用以下的json格式\",{\"1\":{\"253\":1}}],[\"所有的exporter程序都需要按照prometheus的规范\",{\"1\":{\"116\":1}}],[\"所有的告警都会发送给default\",{\"1\":{\"55\":1}}],[\"所有的告警信息从顶级路由开始\",{\"1\":{\"55\":1}}],[\"所有的告警信息都会从配置中的顶级路由\",{\"1\":{\"55\":1}}],[\"所有可以向prometheus提供监控样本数据的程序都可以被称为一个exporter\",{\"1\":{\"113\":1}}],[\"所有事件产生值的大小的总和\",{\"1\":{\"95\":1}}],[\"转换为获取监控数据的请求参数\",{\"1\":{\"203\":1}}],[\"得到以下结果\",{\"1\":{\"202\":1}}],[\"得到当前的指标名称以及指标类型\",{\"1\":{\"116\":1}}],[\"得到当前的指标名称以及相应的说明信息\",{\"1\":{\"116\":1}}],[\"各节点的kubelet组件中除了包含自身的监控指标信息以外\",{\"1\":{\"200\":1}}],[\"白盒监控\",{\"1\":{\"198\":5}}],[\"梳理了监控kubernetes集群监控的各个维度以及策略\",{\"1\":{\"198\":1}}],[\"上面这些标签将会告诉prometheus如何从该target实例中获取监控数据\",{\"1\":{\"309\":1}}],[\"上面的部分\",{\"1\":{\"157\":1}}],[\"上一小节\",{\"1\":{\"275\":1}}],[\"上一小节中\",{\"1\":{\"198\":1}}],[\"上进行捕获\",{\"1\":{\"234\":1}}],[\"评估kubernetes性能\",{\"0\":{\"193\":1}}],[\"评估等待时间\",{\"1\":{\"66\":1}}],[\"替换监控采集地址到kubernetes\",{\"1\":{\"202\":1}}],[\"替换为api\",{\"1\":{\"199\":1}}],[\"替换为kubernetes\",{\"1\":{\"199\":1}}],[\"替换为集群内的dns地址kubernetes\",{\"1\":{\"192\":1}}],[\"替换端口同理\",{\"1\":{\"130\":1}}],[\"想要获取节点minikube上cadvisor的监控数据可以使用ca证书和令牌在kubernetes集群内访问以下地址获取\",{\"1\":{\"190\":1}}],[\"😦\",{\"1\":{\"190\":1}}],[\"👻\",{\"1\":{\"48\":1}}],[\"登录到minikube主机\",{\"1\":{\"188\":1}}],[\"登录到influxdb容器\",{\"1\":{\"167\":1}}],[\"文件系统用量\",{\"1\":{\"286\":1}}],[\"文件系统\",{\"1\":{\"188\":1}}],[\"文中的图例\",{\"1\":{\"4\":1}}],[\"文中的图\",{\"1\":{\"4\":1}}],[\"暂时没有任何的监控采集目标\",{\"1\":{\"185\":1}}],[\"检测service和ingress的可用性\",{\"1\":{\"184\":1}}],[\"检查清单\",{\"0\":{\"4\":1}}],[\"节点上运行一个唯一的pod实例\",{\"1\":{\"201\":1,\"205\":1}}],[\"节点中运行的容器的监控指标\",{\"1\":{\"198\":1}}],[\"节点中运行的容器监控\",{\"1\":{\"184\":1}}],[\"节点b接收到消息后在重复完成相同的工作\",{\"1\":{\"148\":1}}],[\"视容器为这个操作中独自运行的\",{\"1\":{\"181\":1}}],[\"搭建你的监控系统\",{\"1\":{\"313\":1}}],[\"搭建我们的监控系统\",{\"1\":{\"292\":1}}],[\"搭建一个本地的kubernetes测试环境\",{\"1\":{\"181\":1}}],[\"搭建本地kubernetes集群\",{\"0\":{\"181\":1}}],[\"搭建本地集群环境\",{\"0\":{\"149\":1}}],[\"建立从基础设施\",{\"1\":{\"180\":1}}],[\"综上所述\",{\"1\":{\"180\":1}}],[\"结合\",{\"1\":{\"307\":1}}],[\"结合黑盒监控模式\",{\"1\":{\"180\":1,\"184\":1}}],[\"结束时间\",{\"1\":{\"257\":1}}],[\"结果为1\",{\"1\":{\"246\":1,\"362\":1}}],[\"结果向量中只保留列出的标签\",{\"1\":{\"226\":1,\"368\":1}}],[\"结果可能会让人不太满意\",{\"1\":{\"187\":1}}],[\"结果就会有数百个告警被发送到alertmanager\",{\"1\":{\"62\":1}}],[\"云原生\",{\"1\":{\"302\":1}}],[\"云原生监控之道\",{\"0\":{\"1\":1}}],[\"云平台配合\",{\"1\":{\"288\":1}}],[\"云主机等等\",{\"1\":{\"180\":1,\"184\":1}}],[\"虚拟机\",{\"1\":{\"180\":1,\"184\":1}}],[\"持续优化和改进\",{\"1\":{\"180\":1,\"182\":1}}],[\"负责实现对监控数据的获取\",{\"1\":{\"276\":1}}],[\"负责声明式的管理告警配置\",{\"1\":{\"222\":1}}],[\"负责声明式的管理监控配置\",{\"1\":{\"222\":1}}],[\"负责维护主机上的网络规则以及转发\",{\"1\":{\"179\":1,\"183\":1}}],[\"负责维护和管理节点上pod的运行状态\",{\"1\":{\"179\":1,\"183\":1}}],[\"负责为新创建的pod选择可供其运行的节点\",{\"1\":{\"179\":1,\"183\":1}}],[\"负责对外暴露kubernetes\",{\"1\":{\"179\":1,\"183\":1,\"202\":1}}],[\"负责接收并处理来自prometheus\",{\"1\":{\"60\":1}}],[\"入口\",{\"1\":{\"178\":1}}],[\"找到最新版本的prometheus\",{\"1\":{\"273\":1}}],[\"找到当前集群中部署的node\",{\"1\":{\"201\":1}}],[\"找到dashboard对应的service对外暴露的端口\",{\"1\":{\"181\":1}}],[\"找到匹配标签规则的pod实例\",{\"1\":{\"178\":1}}],[\"找到menu\",{\"1\":{\"134\":1}}],[\"外部部署的mysql\",{\"1\":{\"206\":1}}],[\"外部访问入口\",{\"1\":{\"180\":1}}],[\"外部的用户如何访问部署在集群内的应用\",{\"1\":{\"178\":1}}],[\"外部服务可以是真正的存储系统\",{\"1\":{\"163\":1}}],[\"守护模式\",{\"1\":{\"178\":1}}],[\"副本\",{\"1\":{\"178\":1}}],[\"功能\",{\"1\":{\"178\":1,\"180\":1}}],[\"功能分区\",{\"0\":{\"170\":1},\"1\":{\"170\":2}}],[\"访问量前10的http地址\",{\"1\":{\"228\":1}}],[\"访问本地的http\",{\"1\":{\"217\":1}}],[\"访问负载均衡以及整个系统的管理和监控的问题\",{\"1\":{\"177\":1}}],[\"访问http\",{\"1\":{\"105\":1,\"214\":1,\"283\":1,\"285\":1,\"286\":1,\"287\":1,\"375\":1,\"378\":1}}],[\"伸缩\",{\"1\":{\"177\":1}}],[\"弹性伸缩\",{\"1\":{\"176\":1}}],[\"至此\",{\"1\":{\"175\":1}}],[\"安装node\",{\"0\":{\"285\":1,\"371\":1}}],[\"安装\",{\"1\":{\"283\":1}}],[\"安装完成后\",{\"1\":{\"181\":1}}],[\"安装minikube的方式很简单\",{\"1\":{\"181\":1}}],[\"安装一个prometheus\",{\"1\":{\"169\":1}}],[\"安装prometheus\",{\"0\":{\"272\":1},\"1\":{\"8\":1,\"20\":1}}],[\"打开prometheus\",{\"1\":{\"167\":1,\"187\":1}}],[\"模拟prometheus数据丢失的情况后重启prometheus\",{\"1\":{\"167\":1}}],[\"模板参数\",{\"1\":{\"123\":1}}],[\"模板化\",{\"0\":{\"67\":1}}],[\"模板化dashboard\",{\"0\":{\"127\":1},\"1\":{\"9\":1,\"21\":1,\"126\":1}}],[\"模板源码可以从https\",{\"1\":{\"45\":1}}],[\"模板\",{\"1\":{\"26\":1}}],[\"停止prometheus服务\",{\"1\":{\"167\":1}}],[\"写的http服务地址\",{\"1\":{\"165\":1}}],[\"写入到样本中\",{\"1\":{\"190\":1}}],[\"写入日志\",{\"1\":{\"159\":1}}],[\"写入\",{\"1\":{\"100\":1}}],[\"公有云的存储服务\",{\"1\":{\"163\":1}}],[\"远程读\",{\"1\":{\"164\":1}}],[\"远程写\",{\"1\":{\"163\":1}}],[\"远程存储\",{\"0\":{\"154\":1,\"155\":1,\"162\":1},\"1\":{\"9\":1,\"21\":1,\"155\":1,\"157\":1}}],[\"考虑到prometheus会对时间序列进行压缩效率\",{\"1\":{\"160\":1}}],[\"二是增加采集样本的时间间隔\",{\"1\":{\"160\":1}}],[\"二进制包\",{\"1\":{\"52\":1}}],[\"└────┼─────┘\",{\"1\":{\"159\":1}}],[\"└──────────────┴───────┬──────┘\",{\"1\":{\"159\":1}}],[\"└────────────┘\",{\"1\":{\"159\":2}}],[\"└───────────┘\",{\"1\":{\"159\":5}}],[\"┌────┼─────┐\",{\"1\":{\"159\":1}}],[\"┌────────────┐\",{\"1\":{\"159\":2}}],[\"┌───────────┐\",{\"1\":{\"159\":5}}],[\"只能在系统内部使用\",{\"1\":{\"269\":1}}],[\"只能通过减少每秒获取样本数\",{\"1\":{\"160\":1}}],[\"只增不减\",{\"1\":{\"228\":1}}],[\"只增不减的计数器\",{\"0\":{\"228\":1}}],[\"只要exporter在运行\",{\"1\":{\"313\":1}}],[\"只要能够向prometheus提供标准格式的监控样本数据即可\",{\"1\":{\"285\":1}}],[\"只要其提供了对prometheus的支持\",{\"1\":{\"201\":1}}],[\"只要一个块的时间范围落在了配置的保留范围之外\",{\"1\":{\"159\":1}}],[\"只在数据查询时有效\",{\"1\":{\"164\":1}}],[\"只需要下载\",{\"1\":{\"285\":1}}],[\"只需要使用without表达式\",{\"1\":{\"282\":1}}],[\"只需要知道当前模块的http请求量是否>=1000\",{\"1\":{\"246\":1,\"361\":1}}],[\"只需要通过endpoints资源找到kubernetes对应的所有后端地址即可\",{\"1\":{\"202\":1}}],[\"只需要简单的从落在该范围内的块中查询数据即可\",{\"1\":{\"159\":1}}],[\"只需要确保主prometheus\",{\"1\":{\"155\":1}}],[\"只需要修改navbar组件的定义即可\",{\"1\":{\"134\":1}}],[\"只需要在row的设置中\",{\"1\":{\"131\":1}}],[\"只需要在prometheus下配置对blockbox\",{\"1\":{\"100\":1}}],[\"只需要将这些对象以数据源的形式添加到grafana中\",{\"1\":{\"122\":1}}],[\"只需要一些基本的配置即可实现通过邮件的通知\",{\"1\":{\"50\":1}}],[\"索引文件\",{\"1\":{\"159\":1}}],[\"元数据\",{\"1\":{\"159\":2}}],[\"元数据文件\",{\"1\":{\"159\":1}}],[\"块\",{\"1\":{\"159\":2}}],[\"此期间如果通过api删除时间序列\",{\"1\":{\"159\":1}}],[\"此时这些云平台自身就扮演了代理人的角色\",{\"1\":{\"313\":1}}],[\"此时启动prometheus服务\",{\"1\":{\"307\":1}}],[\"此时查看prometheus\",{\"1\":{\"219\":1}}],[\"此时需要用户手动创建service对应的endpoint资源\",{\"1\":{\"202\":1}}],[\"此时prometheus采集到的指标是内网的ip\",{\"1\":{\"130\":1}}],[\"此时可以通过connection\",{\"1\":{\"110\":1}}],[\"此时\",{\"1\":{\"58\":1,\"69\":1,\"134\":1,\"201\":1,\"205\":1,\"216\":1,\"218\":1}}],[\"此时接收到的消息中建辉包含一个可点击的超链接地址\",{\"1\":{\"48\":1}}],[\"此时如果应用出现异常\",{\"1\":{\"42\":1}}],[\"此时则需要将告警发送给相应的数据库管理员\",{\"1\":{\"42\":1}}],[\"此时dingtalk即可接收到相应的告警通知信息\",{\"1\":{\"34\":1}}],[\"┤\",{\"1\":{\"159\":1}}],[\"──────────────────────────────────┘\",{\"1\":{\"159\":1}}],[\"────\",{\"1\":{\"159\":1}}],[\"│\",{\"1\":{\"159\":31,\"268\":4}}],[\"采用prometheus的client\",{\"1\":{\"300\":1}}],[\"采用自定义的存储格式将样本数据保存在本地磁盘当中\",{\"1\":{\"159\":1}}],[\"采集集群状态\",{\"0\":{\"353\":1}}],[\"采集任务目标服务的中包含的请求参数\",{\"1\":{\"309\":1}}],[\"采集目标服务访问地址的访问路径\",{\"1\":{\"309\":1}}],[\"采集目标服务访问地址的http\",{\"1\":{\"309\":1}}],[\"采集node\",{\"1\":{\"287\":1}}],[\"采集相同的targets即可实现基本的ha\",{\"1\":{\"145\":1}}],[\"水平扩展\",{\"1\":{\"157\":1}}],[\"需求\",{\"1\":{\"157\":1}}],[\"需要运行单独的采集程序\",{\"1\":{\"370\":1}}],[\"需要注意的时\",{\"1\":{\"362\":1}}],[\"需要注意的是通过histogram\",{\"1\":{\"240\":1}}],[\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率\",{\"1\":{\"238\":1}}],[\"需要注意的是\",{\"1\":{\"135\":1,\"138\":1,\"190\":1,\"201\":1,\"257\":1,\"264\":1}}],[\"需要注意的是metricfamilysamples中所有样本的名称必须保持一致\",{\"1\":{\"85\":1}}],[\"需要注意的是新的google账号安全规则需要使用\",{\"1\":{\"50\":1}}],[\"需要注意的是顶级的route必须匹配所有告警\",{\"1\":{\"41\":1}}],[\"需要有专业的人员进行安装\",{\"1\":{\"290\":1}}],[\"需要对问题进行调查和处理\",{\"1\":{\"289\":1}}],[\"需要了解运算操作的运行优先级\",{\"1\":{\"248\":1}}],[\"需要定期进行调整才能保证该告警阈值能够发挥去作用\",{\"1\":{\"239\":1}}],[\"需要计算样本的增长速率\",{\"1\":{\"238\":1}}],[\"需要说明的是kubernetes\",{\"1\":{\"201\":1}}],[\"需要跳过ca证书认证\",{\"1\":{\"200\":1}}],[\"需要从pod实例中采集其自定义监控指标\",{\"1\":{\"198\":1}}],[\"需要让kubernetes集群外的用户能够访问访问集群内的应用\",{\"1\":{\"194\":1}}],[\"需要使用group修饰符group\",{\"1\":{\"251\":1,\"367\":1}}],[\"需要使用namespaceselector定义让其可以跨命名空间关联servicemonitor资源\",{\"1\":{\"217\":1}}],[\"需要使用到service\",{\"1\":{\"194\":1}}],[\"需要使用单独的x\",{\"1\":{\"116\":1}}],[\"需要将容器端口映射到主机上\",{\"1\":{\"181\":1}}],[\"需要通过各节点的kubelet获取节点的基本状态\",{\"1\":{\"180\":1}}],[\"需要启动多个实例\",{\"1\":{\"178\":1}}],[\"需要确保prometheus将告警发送到所有的alertmanager实例中\",{\"1\":{\"151\":1}}],[\"需要在pormtheus定义中使用servicemonitorselector\",{\"1\":{\"218\":1}}],[\"需要在prometheus中设置alertmanager相关的信息\",{\"1\":{\"58\":1}}],[\"需要在alertmanager启动时设置相应的参数\",{\"1\":{\"149\":1}}],[\"需要在query\",{\"1\":{\"139\":1}}],[\"需要按照以下约定返回样本数据\",{\"1\":{\"116\":1}}],[\"需要特别注意的是对于histogram和summary类型的样本\",{\"1\":{\"116\":1}}],[\"需要时刻关注mysql服务器的连接情况\",{\"1\":{\"110\":1}}],[\"需要用户提供探针的配置信息\",{\"1\":{\"99\":1}}],[\"需要持久化到一个metricfamilysamples实例中\",{\"1\":{\"85\":1}}],[\"需要能够直接表达出该告警的主要内容\",{\"1\":{\"60\":1}}],[\"需要直接发给特定用户时使用\",{\"1\":{\"48\":1}}],[\"需要考虑印刷效果\",{\"1\":{\"4\":1}}],[\"多个source\",{\"1\":{\"310\":1}}],[\"多个表达式之间使用|进行分离\",{\"1\":{\"259\":1}}],[\"多\",{\"1\":{\"251\":2,\"367\":2}}],[\"多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况\",{\"1\":{\"251\":1,\"367\":1}}],[\"多对一和一对多两种匹配模式指的是\",{\"1\":{\"251\":1,\"367\":1}}],[\"多对一和一对多\",{\"0\":{\"251\":1,\"367\":1}}],[\"多对一\",{\"1\":{\"249\":1,\"365\":1}}],[\"多数据中心\",{\"1\":{\"155\":1}}],[\"多实例prometheus与alertmanager集群\",{\"0\":{\"151\":1}}],[\"场景二\",{\"1\":{\"155\":1}}],[\"场景一\",{\"1\":{\"155\":1}}],[\"再有中心prometheus实例进行聚合\",{\"1\":{\"170\":1}}],[\"再有上层prometheus\",{\"1\":{\"155\":1}}],[\"再次尝试手动拉高系统cpu使用率\",{\"1\":{\"58\":1}}],[\"另外一个prometheus\",{\"1\":{\"155\":1}}],[\"服务注册中心\",{\"1\":{\"313\":1}}],[\"服务包含的标签信息\",{\"1\":{\"310\":1}}],[\"服务名称\",{\"1\":{\"310\":1}}],[\"服务端口\",{\"1\":{\"310\":1}}],[\"服务id\",{\"1\":{\"310\":1}}],[\"服务访问地址\",{\"1\":{\"310\":1}}],[\"服务所在consul节点的信息\",{\"1\":{\"310\":1}}],[\"服务的metadata\",{\"1\":{\"310\":1}}],[\"服务的sla等级\",{\"1\":{\"290\":1}}],[\"服务的性能会明显下降\",{\"1\":{\"234\":1}}],[\"服务每秒接收的请求数\",{\"1\":{\"235\":1}}],[\"服务请求所需时间\",{\"1\":{\"234\":1}}],[\"服务中断\",{\"1\":{\"234\":1}}],[\"服务发现与注册中心\",{\"1\":{\"313\":1}}],[\"服务发现与relabeling\",{\"0\":{\"308\":1}}],[\"服务发现与relabel\",{\"1\":{\"3\":1,\"9\":1,\"21\":1,\"100\":1}}],[\"服务发现模式\",{\"1\":{\"198\":1}}],[\"服务发现\",{\"0\":{\"187\":1}}],[\"服务\",{\"1\":{\"178\":1,\"313\":1}}],[\"服务可用性\",{\"0\":{\"153\":1},\"1\":{\"157\":1}}],[\"基础设施\",{\"1\":{\"313\":1}}],[\"基础设施层\",{\"1\":{\"180\":1}}],[\"基础资源的使用直接影响当前集群的容量和应用的状态\",{\"1\":{\"180\":1,\"184\":1}}],[\"基本的ha模式只能确保prometheus服务的可用性问题\",{\"1\":{\"153\":1}}],[\"基本ha\",{\"0\":{\"153\":1,\"154\":1,\"155\":1},\"1\":{\"153\":1,\"155\":1}}],[\"基于服务发现与注册中心动态发现监控目标\",{\"1\":{\"313\":1}}],[\"基于文件动态发现target对象\",{\"1\":{\"307\":1}}],[\"基于文件的服务发现是最通用的方式\",{\"1\":{\"307\":1}}],[\"基于文件的服务发现\",{\"0\":{\"307\":1},\"1\":{\"3\":1,\"9\":1,\"21\":1,\"309\":1}}],[\"基于grafana可以创建更加精美的监控图标\",{\"1\":{\"299\":1}}],[\"基于这些sdk可以快速让应用程序纳入到prometheus的监控当中\",{\"1\":{\"298\":1}}],[\"基于这些labels我们可以方便地对监控数据进行聚合\",{\"1\":{\"294\":1}}],[\"基于这些实现\",{\"1\":{\"88\":1}}],[\"基于2小时的样本数据\",{\"1\":{\"239\":1}}],[\"基于node模式\",{\"1\":{\"199\":1}}],[\"基于node的服务发现模式\",{\"0\":{\"189\":1}}],[\"基于以上服务发现以及relabel的过程后\",{\"1\":{\"192\":1}}],[\"基于api\",{\"1\":{\"190\":1}}],[\"基于push\",{\"1\":{\"148\":1}}],[\"基于prometheus提供的api还可以实现自己的监控可视化ui\",{\"1\":{\"299\":1}}],[\"基于prometheus丰富的client库\",{\"1\":{\"293\":1}}],[\"基于prometheus的弹性伸缩\",{\"0\":{\"176\":1},\"1\":{\"10\":1,\"22\":1}}],[\"基于promql表达式告警触发条件\",{\"1\":{\"66\":1}}],[\"基于当前我们已经学习到的知识只有两种方式\",{\"1\":{\"127\":1}}],[\"基于模板字符串\",{\"1\":{\"45\":1}}],[\"基于告警中包含的标签\",{\"1\":{\"42\":1}}],[\"基于标签的告警路由\",{\"0\":{\"40\":1}}],[\"基于标签的告警处理路由\",{\"1\":{\"8\":1,\"20\":1}}],[\"基于标签的动态告警处理\",{\"1\":{\"24\":1}}],[\"基于webhook的扩展\",{\"1\":{\"8\":1,\"20\":1}}],[\"基于consul的服务发现\",{\"0\":{\"304\":1},\"1\":{\"3\":1,\"9\":1,\"21\":1,\"308\":1}}],[\"基于如何使用prometheus的服务发现能力\",{\"1\":{\"1\":1}}],[\"影响prometheus性能表现的另外一个重要因素就是数据采集任务量\",{\"1\":{\"152\":1}}],[\"带来了数据持久化等一系列的问题\",{\"1\":{\"152\":1}}],[\"带来的复杂性\",{\"1\":{\"145\":1}}],[\"两个瞬时向量之间进行数学运算\",{\"1\":{\"358\":1}}],[\"两个版本的系统运行资源使用情况的差异如何\",{\"1\":{\"289\":1}}],[\"两个prometheus实例告警分别被触发\",{\"1\":{\"151\":1}}],[\"两种方式\",{\"1\":{\"144\":1}}],[\"手动拉高系统cpu使用率\",{\"1\":{\"151\":1}}],[\"手动拉高虚拟机cpu使用率触发告警条件\",{\"1\":{\"34\":1}}],[\"执行goreman\",{\"1\":{\"150\":1}}],[\"确定写入的内容\",{\"1\":{\"310\":1}}],[\"确定当前告警应该如何处理\",{\"1\":{\"26\":1}}],[\"确保外部用户能够正常访问集群内的功能\",{\"1\":{\"180\":1}}],[\"确保当service不可用时能够快速得到告警通知\",{\"1\":{\"180\":1}}],[\"确保平台自身的稳定运行\",{\"1\":{\"180\":1}}],[\"确保及时在多个alertmanager分别接收到相同告警信息的情况下\",{\"1\":{\"147\":1}}],[\"就创建了我们的第一个可视化dashboard了\",{\"1\":{\"283\":1}}],[\"就需要使用kubernetes的另外一种控制器daemonset\",{\"1\":{\"201\":1,\"205\":1}}],[\"就是尝试部署多套alertmanager\",{\"1\":{\"147\":1}}],[\"就可以利用pushgateway来进行中转\",{\"1\":{\"279\":1}}],[\"就可以对当前kubernetes集群的性能做出评估\",{\"1\":{\"193\":1}}],[\"就可以指定prometheus使用特定的serviceaccount创建pod实例\",{\"1\":{\"186\":1}}],[\"就可以直接使用这些已经定义好的dashboard\",{\"1\":{\"283\":1}}],[\"就可以直接访问到nginx实例的80端口\",{\"1\":{\"181\":1}}],[\"就可以直接进行使用\",{\"1\":{\"87\":1}}],[\"就可以开始尝试在kubernetes下尝试部署一个应用程序\",{\"1\":{\"181\":1}}],[\"就可以在各个数据中心处理上千规模的集群\",{\"1\":{\"169\":1}}],[\"就可以在exporter程序的main方法中启动一个httpserver实例\",{\"1\":{\"86\":1}}],[\"就可以进入panel的配置页面\",{\"1\":{\"126\":1}}],[\"就可以通过访问http\",{\"1\":{\"99\":1}}],[\"虽然job配置有了\",{\"1\":{\"218\":1}}],[\"虽然prometheus能够自动发现所有的资源对象\",{\"1\":{\"187\":1}}],[\"虽然alertmanager能够同时处理多个相同的prometheus\",{\"1\":{\"147\":1}}],[\"虽然能展示各个bucket区间内的样本分布\",{\"1\":{\"141\":1}}],[\"单数据中心\",{\"1\":{\"155\":1}}],[\"单一prometheus实例在数据抓取时可能会出现一些性能问题\",{\"1\":{\"145\":1}}],[\"单个prometheus\",{\"1\":{\"145\":1}}],[\"单位\",{\"1\":{\"105\":11,\"106\":5}}],[\"启用远程读设置后\",{\"1\":{\"164\":1}}],[\"启用之后\",{\"1\":{\"144\":1}}],[\"启动node\",{\"0\":{\"375\":1}}],[\"启动remote\",{\"1\":{\"167\":1}}],[\"启动influxdb服务\",{\"1\":{\"167\":1}}],[\"启动参数\",{\"1\":{\"160\":1}}],[\"启动所有进程\",{\"1\":{\"150\":1}}],[\"启动服务\",{\"1\":{\"150\":1}}],[\"启动该功能后mysqld\",{\"1\":{\"112\":1}}],[\"启动prometheus\",{\"1\":{\"108\":1}}],[\"启动prometheus服务\",{\"1\":{\"106\":1,\"273\":1}}],[\"启动完成后访问任意alertmanager节点http\",{\"1\":{\"150\":1}}],[\"启动完成后\",{\"1\":{\"106\":1,\"108\":1,\"274\":1}}],[\"启动成功后\",{\"1\":{\"99\":1,\"285\":1}}],[\"启动应用程序访问http\",{\"1\":{\"93\":1}}],[\"启动alertmanager\",{\"0\":{\"56\":1}}],[\"详细介绍\",{\"1\":{\"138\":1}}],[\"顾名思义\",{\"1\":{\"138\":1,\"201\":1,\"205\":1}}],[\"点\",{\"1\":{\"138\":1}}],[\"点击界面中的保存选项\",{\"1\":{\"283\":1}}],[\"点击query\",{\"1\":{\"126\":1}}],[\"点击dashboard右上角的\",{\"1\":{\"126\":1}}],[\"点击\",{\"1\":{\"37\":2,\"39\":2}}],[\"线性分布\",{\"1\":{\"142\":1}}],[\"线条\",{\"1\":{\"138\":1}}],[\"线程池等\",{\"1\":{\"87\":1}}],[\"柱状\",{\"1\":{\"138\":1}}],[\"样式以及交互提示行为\",{\"1\":{\"138\":1}}],[\"样本由以下三部分组成\",{\"1\":{\"268\":1}}],[\"样本\",{\"0\":{\"268\":1}}],[\"样本增长率反映出了样本变化的剧烈程度\",{\"1\":{\"238\":1}}],[\"样本数据\",{\"1\":{\"159\":1}}],[\"样本分布的离散程度\",{\"1\":{\"141\":1}}],[\"样本的类型注释信息\",{\"1\":{\"116\":1}}],[\"样本的一般注释信息\",{\"1\":{\"116\":1}}],[\"样本值\",{\"1\":{\"268\":1}}],[\"样本值则为0\",{\"1\":{\"68\":1}}],[\"样本值为1表示当前告警处于活动状态\",{\"1\":{\"68\":1}}],[\"平均值\",{\"1\":{\"226\":1,\"368\":1}}],[\"平均值等\",{\"1\":{\"138\":1}}],[\"平台\",{\"1\":{\"47\":1}}],[\"面对以上这些场景下的需求时\",{\"1\":{\"308\":1}}],[\"面积等各种类型单位的自动换算\",{\"1\":{\"138\":1}}],[\"面板\",{\"1\":{\"123\":1}}],[\"货币\",{\"1\":{\"138\":1}}],[\"控制每条线的图例名称\",{\"1\":{\"138\":1}}],[\"方式二\",{\"1\":{\"200\":1}}],[\"方式一\",{\"1\":{\"200\":1}}],[\"方便用户按需查询数据\",{\"1\":{\"135\":1}}],[\"方法可以指定需要计算的分位数\",{\"1\":{\"352\":1}}],[\"方法用于计数+1\",{\"1\":{\"352\":1}}],[\"方法会从java\",{\"1\":{\"350\":1}}],[\"方法会将该gauge实例注册到collectorregistry中\",{\"1\":{\"89\":1}}],[\"方法中获取样本数据\",{\"1\":{\"350\":1}}],[\"方法中获取采集到的监控指标\",{\"1\":{\"96\":1}}],[\"方法后\",{\"1\":{\"96\":1}}],[\"方法定义监控指标的名称\",{\"1\":{\"95\":1}}],[\"方法指定\",{\"1\":{\"90\":1}}],[\"方法指定标签的值\",{\"1\":{\"89\":1}}],[\"方法获取所有样本\",{\"1\":{\"86\":1}}],[\"方法时\",{\"1\":{\"86\":1}}],[\"方法\",{\"1\":{\"86\":2,\"89\":2,\"90\":1,\"350\":2,\"351\":1}}],[\"方法并返回一组监控样本\",{\"1\":{\"85\":1}}],[\"无状态应用\",{\"1\":{\"178\":1}}],[\"无法存储大量历史数据\",{\"1\":{\"162\":1}}],[\"无法持久化的\",{\"1\":{\"132\":1}}],[\"无论是kubernetes的自身组件还是客户端请求都需要经过kubernetes的apiserver\",{\"1\":{\"193\":1}}],[\"无论是外部的客户端还是集群内部的组件都直接与kube\",{\"1\":{\"180\":1,\"184\":1}}],[\"无论是从其他的prometheus实例还是exporter实例中获取数据实际上并没有任何差异\",{\"1\":{\"169\":1}}],[\"无论是单机部署还是集群化部署\",{\"1\":{\"146\":1}}],[\"无论是\",{\"1\":{\"134\":1}}],[\"刷新prometheus界面可以看到在顶部菜单中多了一个consoles菜单项\",{\"1\":{\"133\":1}}],[\"更利于构建devops文化的团队\",{\"1\":{\"313\":1}}],[\"更新\",{\"1\":{\"221\":1}}],[\"更新prometheus配置文件\",{\"1\":{\"187\":1}}],[\"更灵活的控制prometheus的任务采集信息\",{\"1\":{\"207\":1}}],[\"更通用的方式是通过apiserver访问kubelet提供的\",{\"1\":{\"190\":1}}],[\"更好的选择是采用heatmap\",{\"1\":{\"141\":1}}],[\"更别说我们想实时关注某些特定监控指标的变化趋势\",{\"1\":{\"132\":1}}],[\"更进一步可以通过企业微信和微信的互通来直接将告警消息转发到个人微信上\",{\"1\":{\"51\":1}}],[\"注意\",{\"1\":{\"150\":1,\"151\":1,\"164\":1,\"236\":1}}],[\"注\",{\"1\":{\"130\":1}}],[\"注释信息等\",{\"1\":{\"85\":1}}],[\"进程间的隔离通过命名空间\",{\"1\":{\"181\":1}}],[\"进程\",{\"1\":{\"177\":1,\"181\":1}}],[\"进行比较运算时\",{\"1\":{\"363\":1}}],[\"进行管理\",{\"1\":{\"280\":1}}],[\"进行定义\",{\"1\":{\"260\":1}}],[\"进行判断\",{\"1\":{\"203\":1}}],[\"进行访问\",{\"1\":{\"178\":1}}],[\"进行重播\",{\"1\":{\"159\":1}}],[\"进行ip段的替换\",{\"1\":{\"130\":1}}],[\"进入到prometheus\",{\"1\":{\"287\":1}}],[\"进入到群设置后选择\",{\"1\":{\"30\":1}}],[\"进入status菜单\",{\"1\":{\"57\":1}}],[\"进入路由树\",{\"1\":{\"55\":1}}],[\"进入alertmanager\",{\"1\":{\"37\":1,\"39\":1}}],[\"函数处理后\",{\"1\":{\"241\":1}}],[\"函数进行计算\",{\"1\":{\"240\":1}}],[\"函数可以帮助系统管理员更好的处理此类情况\",{\"1\":{\"239\":1}}],[\"函数是promql中提供的众多内置函数之一\",{\"1\":{\"238\":1}}],[\"函数计算出其值的分位数\",{\"1\":{\"230\":1}}],[\"函数获取http请求量的增长率\",{\"1\":{\"228\":1}}],[\"函数\",{\"1\":{\"130\":1,\"135\":1,\"238\":1,\"282\":1}}],[\"因为新的样本数据只是简单的追加到时间序列上\",{\"1\":{\"326\":1}}],[\"因为通常情况下\",{\"1\":{\"234\":1}}],[\"因为这些缓慢的错误会明显影响系统的性能\",{\"1\":{\"234\":1}}],[\"因为其反应的是cpu的累积使用时间\",{\"1\":{\"227\":1}}],[\"因为目前index\",{\"1\":{\"133\":1}}],[\"因为grafana会自动将多个选项格式化为如\",{\"1\":{\"130\":1}}],[\"因此老的数据可能会保留较长的时间\",{\"1\":{\"326\":1}}],[\"因此安装和部署的方式也极为简单\",{\"1\":{\"305\":1}}],[\"因此你甚至可以在不使用prometheus的情况下\",{\"1\":{\"300\":1}}],[\"因此你可以在每个数据中心\",{\"1\":{\"297\":1}}],[\"因此应用程序会与所选择的监控系统进行绑定\",{\"1\":{\"300\":1}}],[\"因此不会有潜在级联故障的风险\",{\"1\":{\"292\":1}}],[\"因此不会出现在结果当中\",{\"1\":{\"250\":1,\"366\":1}}],[\"因此当故障发生后\",{\"1\":{\"290\":1}}],[\"因此当监控规模大到prometheus单台无法有效处理的情况下\",{\"1\":{\"152\":1}}],[\"因此当监控mysql运行状态时\",{\"1\":{\"110\":1}}],[\"因此node\",{\"1\":{\"286\":1}}],[\"因此通过该函数我们可以近似的通过cpu使用时间计算cpu的利用率\",{\"1\":{\"282\":1}}],[\"因此通过正则表达式\",{\"1\":{\"190\":1}}],[\"因此以下两种方式均表示的同一条time\",{\"1\":{\"269\":1}}],[\"因此以下两种方式\",{\"1\":{\"266\":1}}],[\"因此result表示为当前系统时间一个标量的值\",{\"1\":{\"256\":1}}],[\"因此resolution越小可视化的精确性越高\",{\"1\":{\"126\":1}}],[\"因此该表达式的匹配模式为多对一\",{\"1\":{\"251\":1,\"367\":1}}],[\"因此匹配时需要使用ignoring限定匹配的标签为code\",{\"1\":{\"251\":1,\"367\":1}}],[\"因此需要使用ignoring和on修饰符来排除或者限定匹配的标签列表\",{\"1\":{\"251\":1,\"367\":1}}],[\"因此需要通过singlestat\",{\"1\":{\"144\":1}}],[\"因此结果如下\",{\"1\":{\"250\":1,\"366\":1}}],[\"因此阈值通常来说不是固定的\",{\"1\":{\"239\":1}}],[\"因此追踪这些错误的延迟也是非常重要的\",{\"1\":{\"234\":1}}],[\"因此prometheus鼓励用户监控所有的东西\",{\"1\":{\"232\":1}}],[\"因此为了能够监控到某些东西\",{\"1\":{\"285\":1}}],[\"因此为了能够关联default命名空间下的example对象\",{\"1\":{\"217\":1}}],[\"因此为了直接使用这些bucket信息\",{\"1\":{\"141\":1}}],[\"因此可以将blackbox与service相结合\",{\"1\":{\"207\":1}}],[\"因此可以通过minikube找到当前集群虚拟机的ip地址\",{\"1\":{\"181\":1}}],[\"因此还需要支持用户指定采集路径\",{\"1\":{\"201\":1}}],[\"因此直接访问minikube的虚拟机ip加上pod的端口即可访问当前节点上运行的node\",{\"1\":{\"201\":1,\"205\":1}}],[\"因此和获取kubelet监控指标类似\",{\"1\":{\"200\":1}}],[\"因此只要通过ca证书和令牌访问https\",{\"1\":{\"192\":1}}],[\"因此定义该service类型为nodeport\",{\"1\":{\"181\":1}}],[\"因此也需要通过blackbox\",{\"1\":{\"180\":1}}],[\"因此我们希望从这些实例中采集到的监控样本中也可以包含这样一个标签\",{\"1\":{\"310\":1}}],[\"因此我们需要通过prometheus提供的client\",{\"1\":{\"277\":1}}],[\"因此我们需要先手动创建该目录\",{\"1\":{\"273\":1}}],[\"因此我们需要能够有能力\",{\"1\":{\"118\":1}}],[\"因此我们还需要能够监控应用容器的资源使用情况\",{\"1\":{\"180\":1,\"184\":1}}],[\"因此它们之间可以直接通过本地网络\",{\"1\":{\"178\":1}}],[\"因此有两种手段\",{\"1\":{\"160\":1}}],[\"因此用户需要利用prometheus联邦集群的特性\",{\"1\":{\"155\":1}}],[\"因此用于用户应该关注并且设置响应的告警规则\",{\"1\":{\"109\":1}}],[\"因此这些标签不会被写入到样本数据中\",{\"1\":{\"309\":1}}],[\"因此这些dashboard也是非常方便进行共享的\",{\"1\":{\"123\":1}}],[\"因此这类指标的样本数据可增可减\",{\"1\":{\"229\":1}}],[\"因此这里指定了hostnetwork和hostpid\",{\"1\":{\"201\":1,\"205\":1}}],[\"因此这里还需要将默认的\",{\"1\":{\"192\":1}}],[\"因此这种部署方式适合监控规模不大\",{\"1\":{\"153\":1}}],[\"因此如下所示\",{\"1\":{\"148\":1}}],[\"因此则会出现告警通知被不同的alertmanager重复发送多次的问题\",{\"1\":{\"147\":1}}],[\"因此修改stat为current即可\",{\"1\":{\"144\":1}}],[\"因此其天生适合prometheus中的counter和gauge类型的监控指标的可视化\",{\"1\":{\"137\":1}}],[\"因此对于分位数的计算而言\",{\"1\":{\"230\":1}}],[\"因此对于分位数的计算\",{\"1\":{\"95\":1}}],[\"因此对于企业用户而言\",{\"1\":{\"50\":1}}],[\"因此使用\",{\"1\":{\"95\":1}}],[\"因此alertmanager部署完成后\",{\"1\":{\"58\":1}}],[\"因此\",{\"1\":{\"55\":1,\"56\":1,\"111\":2,\"115\":1,\"138\":1,\"154\":1,\"180\":2,\"184\":3,\"187\":1,\"190\":1,\"193\":1,\"202\":1,\"214\":1,\"223\":1,\"238\":2,\"307\":1}}],[\"因此在网络环境的配置上必须要让prometheus\",{\"1\":{\"279\":1}}],[\"因此在大规模监控的情况下\",{\"1\":{\"276\":1}}],[\"因此在长期趋势分析或者告警中更推荐使用rate函数\",{\"1\":{\"238\":1}}],[\"因此在评估kubernetes性能时\",{\"1\":{\"193\":1}}],[\"因此在kubernetes集群本身我们需要评价其自身的服务质量\",{\"1\":{\"180\":1,\"184\":1}}],[\"因此在metrics选项中需要定义format\",{\"1\":{\"142\":1}}],[\"因此在grafana\",{\"1\":{\"139\":1}}],[\"因此在一个dashboard中\",{\"1\":{\"123\":1}}],[\"因此在alertmanager的配置文件的根路由中\",{\"1\":{\"42\":1}}],[\"因此在alertmanager配置中一般会包含以下几个主要部分\",{\"1\":{\"26\":1}}],[\"因此在route中\",{\"1\":{\"40\":1}}],[\"选项下通过promql查询需要可视化的数据\",{\"1\":{\"283\":1}}],[\"选项\",{\"1\":{\"130\":1,\"157\":1}}],[\"选择以当前时间为基准\",{\"1\":{\"261\":1}}],[\"选择当前最新的数据\",{\"1\":{\"261\":1}}],[\"选择只获取包含了标签\",{\"1\":{\"207\":1}}],[\"选择需要repeat的变量即可\",{\"1\":{\"131\":1}}],[\"选择想要创建的面板类型即可\",{\"1\":{\"126\":1}}],[\"选择\",{\"1\":{\"30\":1}}],[\"^ssh\",{\"1\":{\"195\":1}}],[\"^slave\",{\"1\":{\"156\":1}}],[\"^+ok\",{\"1\":{\"195\":1}}],[\"^1$\",{\"1\":{\"156\":1,\"312\":1}}],[\"^\",{\"1\":{\"130\":1,\"159\":1,\"195\":3,\"201\":1,\"207\":1,\"244\":1,\"248\":1,\"268\":1,\"355\":1,\"369\":1,\"378\":1}}],[\"新向量中的元素由vector1中没有与vector2匹配的元素组成\",{\"1\":{\"247\":1,\"364\":1}}],[\"新建query类型的变量\",{\"1\":{\"130\":1}}],[\"新的存储层\",{\"0\":{\"379\":1}}],[\"新的客户端连接都会被直接拒绝\",{\"1\":{\"110\":1}}],[\"新的告警不会发送\",{\"1\":{\"36\":1}}],[\"特别适合于云原生应用以及微服务架构应用的监控和度量\",{\"1\":{\"235\":1}}],[\"特别适用于同一个dashboard展示多个数据源数据的情况\",{\"1\":{\"129\":1}}],[\"特别是在像kubernetes这样的动态集群环境下\",{\"1\":{\"145\":1}}],[\"特别是在云平台或者容器平台中\",{\"1\":{\"5\":1}}],[\"工作方式\",{\"1\":{\"129\":1}}],[\"配合使用promql的标签正则匹配\",{\"1\":{\"128\":1}}],[\"配置prometheus采集主机信息\",{\"0\":{\"377\":1}}],[\"配置主机监控采集任务\",{\"0\":{\"376\":1}}],[\"配置和管理\",{\"1\":{\"290\":1}}],[\"配置和管理复杂的有状态应用程序\",{\"1\":{\"221\":1}}],[\"配置多个match\",{\"1\":{\"169\":1}}],[\"配置文件\",{\"0\":{\"165\":1}}],[\"配置\",{\"1\":{\"138\":1}}],[\"配置项http用于自定义探针的探测方式\",{\"1\":{\"101\":1,\"316\":1}}],[\"配置了一个最简单的http探针\",{\"1\":{\"101\":1,\"316\":1}}],[\"配置方式如下\",{\"1\":{\"100\":1}}],[\"配置模板示例如下\",{\"1\":{\"51\":1}}],[\"变化频繁的时间序列\",{\"1\":{\"326\":1}}],[\"变化趋势\",{\"0\":{\"136\":1},\"1\":{\"9\":1,\"21\":1}}],[\"变量定义\",{\"0\":{\"129\":1}}],[\"变量的值可以支持单选或者多选\",{\"1\":{\"128\":1}}],[\"变量一般包含一个到多个可选值\",{\"1\":{\"128\":1}}],[\"变量\",{\"0\":{\"128\":1}}],[\"要搭建起这样一套中心化的监控系统实施成本和难度是显而易见的\",{\"1\":{\"313\":1}}],[\"要了解prometheus\",{\"1\":{\"222\":1}}],[\"要么使用一些自动化配置管理工具\",{\"1\":{\"313\":1}}],[\"要么直接将agent构建到基础设施镜像当中\",{\"1\":{\"313\":1}}],[\"要么直接为这些主机创建单独的panel\",{\"1\":{\"127\":1}}],[\"要么就在外部创建单独的服务来适配不同的监控系统\",{\"1\":{\"300\":1}}],[\"要么每次手动修改panel中的promql表达式\",{\"1\":{\"127\":1}}],[\"要使用英文的话\",{\"1\":{\"4\":1}}],[\"调度等\",{\"1\":{\"232\":1}}],[\"调度器\",{\"1\":{\"178\":1}}],[\"调试面板\",{\"1\":{\"126\":1}}],[\"调用成功后\",{\"1\":{\"30\":1}}],[\"除此之外还包括一些第三方的client\",{\"1\":{\"347\":1}}],[\"除此以外\",{\"1\":{\"126\":1,\"131\":1,\"199\":1,\"234\":1}}],[\"除法\",{\"1\":{\"244\":1,\"355\":1}}],[\"除非系统发生重置\",{\"1\":{\"228\":1}}],[\"除了gaugemetricfamily以外\",{\"1\":{\"351\":1}}],[\"除了与这些平台级的公有云\",{\"1\":{\"313\":1}}],[\"除了这些默认的标签以外\",{\"1\":{\"309\":1}}],[\"除了这些以外\",{\"1\":{\"286\":1}}],[\"除了通过实现collector接口以外\",{\"1\":{\"352\":1}}],[\"除了通过使用\",{\"1\":{\"280\":1}}],[\"除了通过数字大小反应当前状态以外\",{\"1\":{\"144\":1}}],[\"除了静态配置每一个job的采集instance地址以外\",{\"1\":{\"280\":1}}],[\"除了上文介绍的这些内置函数以外\",{\"1\":{\"242\":1}}],[\"除了上述介绍的不同监控级别以外\",{\"1\":{\"233\":1}}],[\"除了label\",{\"1\":{\"241\":1}}],[\"除了irate以外\",{\"1\":{\"237\":1}}],[\"除了counter和gauge类型的监控指标以外\",{\"1\":{\"230\":1}}],[\"除了需要关注集群中部署应用的运行状态和节点的资源使用情况以外\",{\"1\":{\"191\":1}}],[\"除了直接访问cadvisor监听的端口以外\",{\"1\":{\"190\":1}}],[\"除了直接访问各个节点的cadvisor服务以外\",{\"1\":{\"190\":1}}],[\"除了直接使用promconsole\",{\"1\":{\"135\":1}}],[\"除了直接使用社区提供的exporter程序以外\",{\"1\":{\"114\":1}}],[\"除了直接使用httpserver以外暴露样本数据以外\",{\"1\":{\"86\":1}}],[\"除了prometheus\",{\"1\":{\"185\":1}}],[\"除了panel\",{\"1\":{\"123\":1}}],[\"除了panel以外\",{\"1\":{\"123\":1}}],[\"除了payload以外\",{\"1\":{\"48\":1}}],[\"除了讨论prometheus自身的高可用\",{\"1\":{\"145\":1}}],[\"除了本地存储方面的问题\",{\"1\":{\"145\":1}}],[\"除了以上设置以外\",{\"1\":{\"138\":1}}],[\"除了以上部分以外\",{\"1\":{\"135\":1}}],[\"除了百分比以外\",{\"1\":{\"138\":1}}],[\"除了最基本的node以及expr参数以外\",{\"1\":{\"135\":1}}],[\"除了一些panel的基本信息以外\",{\"1\":{\"126\":1}}],[\"除了\",{\"1\":{\"116\":1}}],[\"除了node\",{\"1\":{\"115\":1}}],[\"除了使用prometheus提供的httpserver以外\",{\"1\":{\"350\":1}}],[\"除了使用prometheus已经提供的大量exporter以外\",{\"1\":{\"347\":1}}],[\"除了使用promql查询时间序列以过滤标签的方式以外\",{\"1\":{\"130\":1}}],[\"除了使用replace以外\",{\"1\":{\"310\":1}}],[\"除了使用dns的方式以外\",{\"1\":{\"305\":1}}],[\"除了使用监控指标作为查询关键字以为\",{\"1\":{\"282\":1}}],[\"除了使用<metric\",{\"1\":{\"266\":1}}],[\"除了使用瞬时向量表达式和区间向量表达式以外\",{\"1\":{\"263\":1}}],[\"除了使用m表示分钟以外\",{\"1\":{\"260\":1}}],[\"除了使用完全匹配的方式对时间序列进行过滤以外\",{\"1\":{\"259\":1}}],[\"除了使用increase函数以外\",{\"1\":{\"238\":1}}],[\"除了使用命令以外\",{\"1\":{\"104\":1}}],[\"除了使用timer进行计时以外\",{\"1\":{\"90\":1}}],[\"除了支持对http协议进行网络探测以外\",{\"1\":{\"103\":1}}],[\"除了基于http状态码\",{\"1\":{\"103\":1,\"318\":1}}],[\"除了基于抑制机制可以控制告警通知的行为以外\",{\"1\":{\"37\":1,\"39\":1}}],[\"除了能够在服务出现异常的时候及时报警\",{\"1\":{\"101\":1,\"316\":1}}],[\"除了大量的应用白盒监控以外\",{\"1\":{\"98\":1}}],[\"除了在metrics设置图例的显示名称以外\",{\"1\":{\"138\":1}}],[\"除了在拦截器中使用prometheus提供的counter\",{\"1\":{\"96\":1}}],[\"除了在第一次出现的时候给出对应的中文\",{\"1\":{\"4\":1}}],[\"除了获取应用jvm相关的状态以外\",{\"1\":{\"94\":1}}],[\"除了之前自定义的监控指标以外\",{\"1\":{\"87\":1}}],[\"除了提供接口规范以外\",{\"1\":{\"87\":1}}],[\"除了发送纯文本以外\",{\"1\":{\"48\":1}}],[\"除了用于支持额外的通知方式\",{\"1\":{\"27\":1}}],[\"度量指标\",{\"1\":{\"126\":1}}],[\"认识面板\",{\"0\":{\"126\":1}}],[\"认识slack\",{\"0\":{\"47\":1}}],[\"部分即可\",{\"1\":{\"134\":1}}],[\"部分\",{\"1\":{\"125\":1}}],[\"部署测试应用\",{\"1\":{\"393\":1}}],[\"部署exporters\",{\"1\":{\"393\":1}}],[\"部署完成后\",{\"1\":{\"181\":1}}],[\"部署mysqld\",{\"0\":{\"108\":1}}],[\"部署alertmanager\",{\"0\":{\"52\":1},\"1\":{\"8\":1,\"20\":1}}],[\"部署prometheus\",{\"1\":{\"3\":1,\"10\":1,\"22\":1,\"201\":1,\"205\":1,\"393\":1}}],[\"组织\",{\"1\":{\"124\":1}}],[\"组织和用户\",{\"0\":{\"124\":1}}],[\"行\",{\"1\":{\"123\":1}}],[\"热力图的形式展示可视化数据\",{\"1\":{\"123\":1}}],[\"仪表盘\",{\"0\":{\"123\":1},\"1\":{\"227\":1}}],[\"\\b下面列举一些常用的监控维度\",{\"1\":{\"232\":1}}],[\"\\b我们就能大概理解\",{\"1\":{\"207\":1}}],[\"\\b其中matser组件提供了集群层面的管理功能\",{\"1\":{\"183\":1}}],[\"\\b上图中设置的scale为log\",{\"1\":{\"142\":1}}],[\"\\b默认的bucket范围支持包括\",{\"1\":{\"142\":1}}],[\"\\b需要设置format\",{\"1\":{\"141\":1}}],[\"\\bcpu使用率的变化趋势天然适用于使用grapn面板来进行展示\",{\"1\":{\"138\":1}}],[\"\\b对于grafana而言\",{\"1\":{\"122\":1}}],[\"\\btable\",{\"1\":{\"77\":1}}],[\"意味着grafana不仅仅适用于展示prometheus下的监控数据\",{\"1\":{\"121\":1}}],[\"构建出不同的可视化报表页面\",{\"1\":{\"118\":1}}],[\"具有相同metric\",{\"1\":{\"116\":1}}],[\"具体配置参考如下\",{\"1\":{\"51\":1}}],[\"返回瞬时样本值满足条件比较条件\",{\"1\":{\"360\":1}}],[\"返回一组新的瞬时向量\",{\"1\":{\"358\":1}}],[\"返回结果\",{\"1\":{\"357\":1}}],[\"返回结果一定是一个区间向量\",{\"1\":{\"257\":1}}],[\"返回的数据类型\",{\"1\":{\"264\":1}}],[\"返回当前样本值前n位\",{\"1\":{\"226\":1,\"368\":1}}],[\"返回prometheus查询语句的查询结果\",{\"1\":{\"130\":1}}],[\"返回prometheus所有监控指标metric中\",{\"1\":{\"130\":1}}],[\"返回prometheus所有监控指标中\",{\"1\":{\"130\":1}}],[\"返回所有指标名称满足metric定义正则表达式的\\b指标名称\",{\"1\":{\"130\":1}}],[\"返回监控的样本数据\",{\"1\":{\"116\":1}}],[\"返回需要的业务相关的指标\",{\"1\":{\"96\":1}}],[\"适合于一些需要更多自定义监控指标需求的项目\",{\"1\":{\"115\":1}}],[\"独立使用的\",{\"1\":{\"115\":1}}],[\"存储并且对外提供数据查询支持\",{\"1\":{\"285\":1}}],[\"存储以及查询\",{\"1\":{\"276\":1}}],[\"存储空间的增长速率提升了好几倍\",{\"1\":{\"239\":1}}],[\"存储空间以及网络吞吐等监控指标\",{\"1\":{\"180\":1,\"184\":1}}],[\"存储服务\",{\"1\":{\"167\":1}}],[\"存储\",{\"0\":{\"326\":1,\"330\":1,\"336\":1},\"1\":{\"114\":1,\"313\":1,\"324\":1}}],[\"硬件\",{\"1\":{\"114\":1}}],[\"范围查询\",{\"0\":{\"260\":1}}],[\"范围\",{\"0\":{\"324\":1,\"329\":1,\"334\":1,\"339\":1,\"343\":1},\"1\":{\"114\":1}}],[\"涵盖了从基础设施\",{\"1\":{\"114\":1}}],[\"社区提供的\",{\"1\":{\"114\":1}}],[\"广义上讲\",{\"1\":{\"113\":1}}],[\"导致磁盘i\",{\"1\":{\"111\":1}}],[\"导入simpleclient\",{\"1\":{\"87\":1}}],[\"允许用户指定数据源以及查询表达式\",{\"1\":{\"130\":1}}],[\"允许用户指定要附加到告警上的一组附加标签\",{\"1\":{\"66\":1}}],[\"允许用户动态切换当前dashboard的数据源\",{\"1\":{\"129\":1}}],[\"允许用户通过datasource查询表达式的返回值动态生成变量的可选值\",{\"1\":{\"129\":1}}],[\"允许的最大连接数\",{\"1\":{\"110\":1}}],[\"说明客户端尝试连接到mysql都失败了\",{\"1\":{\"110\":1}}],[\"改\",{\"1\":{\"109\":1}}],[\"删除\",{\"1\":{\"305\":1}}],[\"删除的动作都会被转换为事件\",{\"1\":{\"221\":1}}],[\"删除记录也会保存在单独的逻辑文件当中\",{\"1\":{\"159\":1}}],[\"删\",{\"1\":{\"109\":1}}],[\"增加对mysqld\",{\"1\":{\"108\":1}}],[\"字节\",{\"1\":{\"105\":8,\"106\":9}}],[\"字符串类型的响应内容格式和标量相同\",{\"1\":{\"256\":1}}],[\"字符串\",{\"0\":{\"265\":1},\"1\":{\"256\":1}}],[\"字符串匹配或者正则匹配\",{\"1\":{\"37\":1,\"39\":1}}],[\"字符串或者正则表达式\",{\"1\":{\"37\":1,\"39\":1}}],[\"指标的名称\",{\"1\":{\"269\":1}}],[\"指标\",{\"0\":{\"269\":1},\"1\":{\"268\":1}}],[\"指标prometheus\",{\"1\":{\"230\":1}}],[\"指标apiserver\",{\"1\":{\"193\":1}}],[\"指标名称只能由ascii字符\",{\"1\":{\"269\":1}}],[\"指标名称反映了监控样本的基本标识\",{\"1\":{\"258\":1}}],[\"指标名称\",{\"1\":{\"105\":1}}],[\"指定数据源类型为prometheus并且设置prometheus的访问地址即可\",{\"1\":{\"283\":1}}],[\"指定了selector选择器\",{\"1\":{\"206\":1}}],[\"指定serviceaccount创建的pod实例中\",{\"1\":{\"186\":1}}],[\"指定样本格式的版本\",{\"0\":{\"117\":1}}],[\"指定一组告警规则文件的访问路径\",{\"1\":{\"66\":1}}],[\"61a0\",{\"1\":{\"305\":1}}],[\"66\",{\"1\":{\"305\":1}}],[\"653d\",{\"1\":{\"305\":1}}],[\"650\",{\"1\":{\"273\":1}}],[\"6543bc1\",{\"1\":{\"150\":1}}],[\"624\",{\"1\":{\"273\":1}}],[\"62144e+07\",{\"1\":{\"230\":1}}],[\"600\",{\"1\":{\"250\":2,\"251\":2,\"366\":2,\"367\":2}}],[\"6384e+06\",{\"1\":{\"230\":1}}],[\"6db8dbb7dd\",{\"1\":{\"216\":1,\"223\":1}}],[\"6d8f46cfb7\",{\"1\":{\"181\":7}}],[\"6s\",{\"1\":{\"186\":1}}],[\"69f9ddb588\",{\"1\":{\"186\":2,\"187\":5}}],[\"6400\",{\"1\":{\"230\":1}}],[\"64\",{\"1\":{\"139\":1}}],[\"6\",{\"1\":{\"103\":1,\"230\":1,\"240\":1,\"250\":2,\"251\":1,\"280\":1,\"305\":3,\"310\":1,\"318\":1,\"366\":2,\"367\":1}}],[\"也是通过labelset进行唯一命名的\",{\"1\":{\"227\":1}}],[\"也是一个相对类似的过程\",{\"1\":{\"203\":1}}],[\"也要支持从这些应用程序中采集内部的监控指标\",{\"1\":{\"180\":1,\"184\":1}}],[\"也通过了一个适配器实现\",{\"1\":{\"164\":1}}],[\"也无法进行动态的扩展\",{\"1\":{\"153\":1}}],[\"也只有一个告警通知被发送给receiver\",{\"1\":{\"147\":1}}],[\"也会同时将时间序列中的数据以趋势图的形式进行展示\",{\"1\":{\"144\":1}}],[\"也会通过指标probe\",{\"1\":{\"103\":1,\"318\":1}}],[\"也同样适用于一些其他的数据可视化需求\",{\"1\":{\"121\":1}}],[\"也可能来源于的你的环境定义\",{\"1\":{\"294\":1}}],[\"也可能是探针本身的验证行为\",{\"1\":{\"99\":1}}],[\"也可能是探测时需要的一些tsl配置\",{\"1\":{\"99\":1}}],[\"也可能使用过像java\",{\"1\":{\"5\":1}}],[\"也可以输出支持其它监控系统的格式化数据\",{\"1\":{\"300\":1}}],[\"也可以配合使用service\",{\"1\":{\"276\":1}}],[\"也可以非常方便的用于评判当前监控指标的服务水平\",{\"1\":{\"240\":1}}],[\"也可以指定\",{\"1\":{\"201\":1,\"205\":1}}],[\"也可以是直接内置在监控目标中\",{\"1\":{\"285\":1}}],[\"也可以是消息队列等任意形式\",{\"1\":{\"163\":1}}],[\"也可以是其它的客户端程序\",{\"1\":{\"60\":1}}],[\"也可以通过webhook自定义告警处理方式\",{\"1\":{\"278\":1}}],[\"也可以通过以下promql计算2分钟内磁盘读取请求次数的增长率的变化情况\",{\"1\":{\"111\":1}}],[\"也可以通过com\",{\"1\":{\"109\":1}}],[\"也可以直接在业务系统中集成对prometheus的支持\",{\"1\":{\"348\":1}}],[\"也可以直接内置于特定的系统当中\",{\"1\":{\"83\":1}}],[\"也可以直接展示时间序列并且对样本数据进行统计聚合\",{\"1\":{\"76\":1}}],[\"也可以在我们的项目源码中集成client\",{\"1\":{\"84\":1}}],[\"也可以在slack\",{\"1\":{\"49\":1}}],[\"也可以在每个receiver中单独定义自己的slack\",{\"1\":{\"49\":1}}],[\"有状态应用\",{\"1\":{\"178\":1}}],[\"有时候我们想要动态修改变量查询结果\",{\"1\":{\"130\":1}}],[\"有些可能只是一些简单的用户应用\",{\"1\":{\"201\":1}}],[\"有些可能就是一些简单的网页\",{\"1\":{\"102\":1,\"317\":1}}],[\"有些开源项目如kubernetes\",{\"1\":{\"115\":1}}],[\"有的时候为了能够一次性收集和发送更多的相关信息时\",{\"1\":{\"42\":1}}],[\"表达式node\",{\"1\":{\"358\":2}}],[\"表达式查询当前所有instance的状态以外\",{\"1\":{\"280\":1}}],[\"表情\",{\"1\":{\"144\":1}}],[\"表明当前的协议使用情况\",{\"1\":{\"103\":1,\"318\":1}}],[\"表示维度的标签可能来源于你的监控对象的状态\",{\"1\":{\"294\":1}}],[\"表示未知错误\",{\"1\":{\"290\":1}}],[\"表示错误\",{\"1\":{\"290\":1}}],[\"表示警告\",{\"1\":{\"290\":1}}],[\"表示正常\",{\"1\":{\"287\":1,\"290\":1}}],[\"表示当前系统接收到的http请求总量\",{\"1\":{\"269\":1}}],[\"表示当前prometheus共进行了36次数据压缩\",{\"1\":{\"139\":1}}],[\"表示需要计算的分位数\",{\"1\":{\"240\":1}}],[\"表示使用当前时间序列中的instance标签的值作为图例名称\",{\"1\":{\"126\":1}}],[\"表示\",{\"1\":{\"116\":2}}],[\"表示如果站点启用了ssl则探针失败\",{\"1\":{\"103\":1,\"318\":1}}],[\"表示完全使用http探针的默认配置\",{\"1\":{\"101\":1,\"316\":1}}],[\"表格\",{\"0\":{\"76\":1}}],[\"复写target实例的\",{\"1\":{\"100\":1}}],[\"复杂类型summary和histogram\",{\"0\":{\"90\":1}}],[\"小时\",{\"1\":{\"260\":1}}],[\"小于等于\",{\"1\":{\"245\":1,\"359\":1}}],[\"小于\",{\"1\":{\"245\":1,\"359\":1}}],[\"小节中的示例中\",{\"1\":{\"309\":1}}],[\"小节中\",{\"1\":{\"139\":1,\"188\":1,\"312\":1}}],[\"小节\",{\"1\":{\"100\":1,\"201\":1,\"204\":1,\"205\":1}}],[\"小结中详细介绍\",{\"1\":{\"126\":1}}],[\"小结\",{\"0\":{\"25\":1,\"83\":1,\"119\":1,\"146\":1,\"172\":1,\"209\":1,\"225\":1,\"303\":1},\"1\":{\"8\":3,\"9\":4,\"10\":2,\"20\":3,\"21\":4,\"22\":2}}],[\"假如我们有n个目标站点且都需要m种探测方式\",{\"1\":{\"100\":1}}],[\"假如此时发生了网络故障\",{\"1\":{\"62\":1}}],[\"站点响应时间\",{\"1\":{\"99\":1}}],[\"包含镜像下载时间\",{\"1\":{\"193\":1,\"199\":1}}],[\"包含node\",{\"1\":{\"179\":1,\"183\":1}}],[\"包含两个http探针配置项\",{\"1\":{\"99\":1}}],[\"包括jvm中gc\",{\"1\":{\"349\":1}}],[\"包括内置的数据采集\",{\"1\":{\"324\":1}}],[\"包括高效的数据能力\",{\"1\":{\"302\":1}}],[\"包括对数据查询\",{\"1\":{\"258\":1}}],[\"包括library\",{\"1\":{\"232\":1}}],[\"包括prometheus的动态扩展\",{\"1\":{\"152\":1}}],[\"包括\",{\"1\":{\"102\":1,\"178\":1,\"256\":1,\"283\":1,\"317\":1}}],[\"包括其本身的可用性\",{\"1\":{\"101\":1,\"316\":1}}],[\"包括探针类型\",{\"1\":{\"99\":1}}],[\"包括如何监控容器运行状态\",{\"1\":{\"92\":1}}],[\"包括预先定义的抑制机制和临时定义的静默规则\",{\"1\":{\"35\":1}}],[\"包括社区提供的已经实现的exporter的使用场景以及方法\",{\"1\":{\"1\":1}}],[\"下图描述了一下通过prometheus\",{\"1\":{\"350\":1}}],[\"下图展示prometheus的基本架构\",{\"1\":{\"275\":1}}],[\"下图展示了kubernetes的应用管理模型\",{\"1\":{\"178\":1}}],[\"下载并且导入这些json文件\",{\"1\":{\"283\":1}}],[\"下划线以及冒号组成并必须符合正则表达式\",{\"1\":{\"269\":1}}],[\"下表中\",{\"1\":{\"198\":1}}],[\"下表展示了prometheus和高可用有关3个选项各自解决的问题\",{\"1\":{\"157\":1}}],[\"下表列举一些社区中常用的exporter\",{\"1\":{\"114\":1}}],[\"下面是一个更完整的采集任务配置如下所示\",{\"1\":{\"207\":1}}],[\"下面是一个简化的探针配置文件blockbox\",{\"1\":{\"99\":1}}],[\"下面给出了一个完整prometheus配置的示例\",{\"1\":{\"187\":1}}],[\"下面列举了与mysql连接相关的监控指标\",{\"1\":{\"110\":1}}],[\"下面表格中列举了一些cadvisor中获取到的典型监控指标\",{\"1\":{\"105\":1}}],[\"下创建告警文件hoststats\",{\"1\":{\"69\":1}}],[\"探测ingress可用性\",{\"0\":{\"197\":1}}],[\"探测service可用性\",{\"0\":{\"196\":1}}],[\"探针的探测结果通过metrics的形式返回\",{\"1\":{\"99\":1}}],[\"探针的详细配置\",{\"1\":{\"99\":1}}],[\"探针类型\",{\"1\":{\"99\":1}}],[\"探索promql\",{\"0\":{\"224\":1},\"1\":{\"8\":1,\"20\":1}}],[\"验证结果\",{\"0\":{\"378\":1}}],[\"验证访问超时时间\",{\"1\":{\"99\":1}}],[\"验证prometheus的告警流程\",{\"1\":{\"69\":1}}],[\"黑盒监控\",{\"1\":{\"198\":2}}],[\"黑盒监控侧重于从用户角度来测试服务的可用性\",{\"1\":{\"194\":1}}],[\"黑盒监控和白盒监控\",{\"1\":{\"98\":1}}],[\"黑盒监控能快速发现故障\",{\"1\":{\"98\":1}}],[\"黑盒监控相较于白盒监控最大的不同在于黑盒监控是以故障为导向当故障发生时\",{\"1\":{\"98\":1}}],[\"黑盒监控即以用户的身份测试服务的外部可见性\",{\"1\":{\"98\":1}}],[\"设置环境变量指向gopath的bin目录\",{\"1\":{\"150\":1}}],[\"设置该选项后heatmap\",{\"1\":{\"142\":1}}],[\"设置指标的label以及value\",{\"1\":{\"96\":1}}],[\"设置当前聊天机器人的名称\",{\"1\":{\"48\":1}}],[\"含义\",{\"1\":{\"95\":4,\"105\":1,\"160\":1}}],[\"相较于push模式\",{\"1\":{\"313\":1}}],[\"相似的kubernetes是从google的brog系统演变而来\",{\"1\":{\"288\":1}}],[\"相信读者通过本章能够对prometheus有一个直观的认识\",{\"1\":{\"271\":1}}],[\"相信读者能够对prometheus有一个全面的认识\",{\"1\":{\"1\":1}}],[\"相等\",{\"1\":{\"245\":1,\"359\":1}}],[\"相比于直接使用静态配置\",{\"1\":{\"303\":1}}],[\"相比于传统监控系统prometheus具有以下优点\",{\"1\":{\"291\":1}}],[\"相比于protocol\",{\"1\":{\"116\":1}}],[\"相比于使用docker命令行工具\",{\"1\":{\"105\":1}}],[\"相应的\",{\"1\":{\"109\":1}}],[\"相对的对于客户端而言histogram消耗的资源更少\",{\"1\":{\"95\":1}}],[\"都可以完成对事件发生次数或者大小分布情况的统计\",{\"1\":{\"352\":1}}],[\"都可以统计事件发生的次数或者发小\",{\"1\":{\"95\":1}}],[\"都在动态的变化\",{\"1\":{\"313\":1}}],[\"都包含一些默认的metadata标签信息\",{\"1\":{\"309\":1}}],[\"都直接内置了用于向prometheus暴露监控数据的端点\",{\"1\":{\"277\":1}}],[\"都通过如下格式标示\",{\"1\":{\"269\":1}}],[\"都通过global\",{\"1\":{\"72\":1}}],[\"都是以当前时间为基准\",{\"1\":{\"261\":1}}],[\"都是gauge类型的监控指标\",{\"1\":{\"229\":1}}],[\"都不够直观\",{\"1\":{\"141\":1}}],[\"事件产生的值的分布情况\",{\"1\":{\"95\":1}}],[\"事件产生的值的总和\",{\"1\":{\"95\":1}}],[\"事件产生的值分布在bucket中的次数\",{\"1\":{\"95\":1}}],[\"事件发生总的次数\",{\"1\":{\"95\":1}}],[\"事件发生总次数\",{\"1\":{\"95\":1}}],[\"秒\",{\"1\":{\"95\":6,\"105\":3,\"106\":8,\"260\":1}}],[\"发生的2次http请求总的响应时间为13\",{\"1\":{\"95\":1}}],[\"主备ha\",{\"1\":{\"157\":1}}],[\"主机监控指标\",{\"1\":{\"286\":1}}],[\"主机负载情况\",{\"1\":{\"282\":1}}],[\"主机\",{\"1\":{\"232\":1,\"280\":1}}],[\"主机当前空闲的内存大小\",{\"1\":{\"229\":1}}],[\"主机当前空闲的内容大小\",{\"1\":{\"95\":1}}],[\"主机cpu使用率\",{\"1\":{\"127\":1}}],[\"主要用于在指定分布范围内\",{\"1\":{\"352\":1}}],[\"主要用于分析系统性能问题\",{\"1\":{\"236\":1}}],[\"主要针对系统服务和资源的状态以及应用程序的可用性\",{\"1\":{\"290\":1}}],[\"主要强调最能影响服务状态的受限制的资源\",{\"1\":{\"234\":1}}],[\"主要关注以下三种关键指标\",{\"1\":{\"235\":1}}],[\"主要关注与以下四种类型的指标\",{\"1\":{\"234\":1}}],[\"主要关注在kubernetes的api响应时间\",{\"1\":{\"180\":1,\"184\":1}}],[\"主要包含5类配置选项\",{\"1\":{\"141\":1}}],[\"主要由三个部分组成\",{\"1\":{\"116\":1}}],[\"主要分为两类\",{\"1\":{\"114\":1}}],[\"主要通过一个实际的案例介绍了prometheus的是什么\",{\"1\":{\"1\":1}}],[\"请求\",{\"1\":{\"235\":3}}],[\"请求参数等\",{\"1\":{\"102\":1,\"317\":1}}],[\"请求方法以及状态码\",{\"1\":{\"95\":1}}],[\"请求内容如下\",{\"1\":{\"27\":1}}],[\"等同于\",{\"1\":{\"259\":1,\"269\":1}}],[\"等同于params的设置\",{\"1\":{\"100\":1}}],[\"等价于\",{\"1\":{\"226\":1,\"368\":1}}],[\"等待prometheus\",{\"1\":{\"219\":1}}],[\"等待prometheus重新加载后\",{\"1\":{\"214\":1}}],[\"等待prometheus告警进行触发状态\",{\"1\":{\"58\":1}}],[\"等待index\",{\"1\":{\"148\":1}}],[\"等\",{\"1\":{\"95\":1,\"142\":1,\"178\":1}}],[\"计数\",{\"1\":{\"226\":1,\"368\":1}}],[\"计数器就会+1\",{\"1\":{\"112\":1}}],[\"计数器\",{\"1\":{\"95\":1,\"227\":1}}],[\"计数器+1\",{\"1\":{\"95\":2}}],[\"计数器可以用于记录只会增加不会减少的指标类型\",{\"1\":{\"95\":1}}],[\"计算\",{\"1\":{\"313\":1}}],[\"计算hash值\",{\"1\":{\"312\":1}}],[\"计算source\",{\"1\":{\"312\":1}}],[\"计算counter指标增长率\",{\"0\":{\"238\":1}}],[\"计算cpu温度在两个小时内的差异\",{\"1\":{\"229\":1}}],[\"计算样本的线性回归模型\",{\"1\":{\"229\":1}}],[\"计算各个bucket桶内的分布\",{\"1\":{\"141\":1}}],[\"计算等操作\",{\"1\":{\"282\":1}}],[\"计算等\",{\"1\":{\"5\":1}}],[\"继承webmvcconfigureradapter类并复写addinterceptors方法\",{\"1\":{\"94\":1}}],[\"介绍如何在应用代码中集成client\",{\"1\":{\"93\":1}}],[\"介绍prometheus中一些常用的exporter的使用场景以及使用方法\",{\"1\":{\"5\":1}}],[\"76\",{\"1\":{\"285\":1}}],[\"7675\",{\"1\":{\"111\":1}}],[\"781\",{\"1\":{\"255\":2,\"257\":6}}],[\"781z\",{\"1\":{\"255\":1,\"257\":2}}],[\"781z的计算结果\",{\"1\":{\"255\":1}}],[\"780\",{\"1\":{\"230\":4}}],[\"7890625\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"286\":1}}],[\"7fe1c063\",{\"1\":{\"207\":1}}],[\"72bl5\",{\"1\":{\"203\":1}}],[\"7xs6z\",{\"1\":{\"181\":1}}],[\"77\",{\"1\":{\"169\":3}}],[\"795d0ead87a1\",{\"1\":{\"167\":2}}],[\"797023\",{\"1\":{\"111\":1}}],[\"7d698ac\",{\"1\":{\"151\":3}}],[\"736711\",{\"1\":{\"111\":1}}],[\"7\",{\"1\":{\"90\":1,\"95\":1,\"108\":1,\"181\":2,\"280\":1,\"305\":3,\"352\":1}}],[\"7560473e+07\",{\"1\":{\"116\":1}}],[\"75\",{\"1\":{\"90\":1,\"95\":1,\"352\":1}}],[\"93\",{\"1\":{\"325\":1}}],[\"93970\",{\"1\":{\"310\":2}}],[\"95\",{\"1\":{\"245\":1}}],[\"9分位数\",{\"1\":{\"230\":1}}],[\"9分位数等等\",{\"1\":{\"95\":1}}],[\"94334\",{\"1\":{\"268\":1}}],[\"94355\",{\"1\":{\"268\":1}}],[\"94c8bc8\",{\"1\":{\"217\":3}}],[\"945687812z\",{\"1\":{\"151\":1}}],[\"945534548z\",{\"1\":{\"151\":1}}],[\"945493505z\",{\"1\":{\"151\":1}}],[\"9h56z\",{\"1\":{\"201\":1,\"205\":1}}],[\"9ppb8\",{\"1\":{\"181\":2}}],[\"99\",{\"1\":{\"181\":1,\"187\":3,\"189\":3,\"193\":2,\"199\":5,\"201\":2,\"205\":2,\"206\":4,\"207\":3,\"230\":1,\"396\":2}}],[\"99范围内则显示为health\",{\"1\":{\"144\":1}}],[\"96\",{\"1\":{\"175\":1,\"181\":2,\"192\":1,\"202\":1}}],[\"9201\",{\"1\":{\"167\":2}}],[\"9100|localhost\",{\"1\":{\"130\":1}}],[\"9100\",{\"1\":{\"130\":5,\"144\":1,\"151\":2,\"201\":5,\"205\":4,\"206\":5,\"207\":2,\"241\":2,\"244\":2,\"255\":1,\"280\":3,\"285\":2,\"286\":1,\"287\":2,\"305\":2,\"307\":1,\"309\":1,\"310\":3,\"358\":8,\"360\":1,\"375\":1,\"377\":3}}],[\"9104访问mysqld\",{\"1\":{\"108\":1}}],[\"9104\",{\"1\":{\"108\":3,\"307\":1}}],[\"9115\",{\"1\":{\"99\":1,\"100\":3,\"195\":1,\"196\":1,\"197\":1,\"203\":5}}],[\"9a1648bec3b2\",{\"1\":{\"104\":1}}],[\"9\",{\"1\":{\"90\":1,\"95\":2,\"105\":1,\"181\":2,\"187\":1,\"230\":2,\"269\":2,\"305\":2,\"352\":2}}],[\"9095\",{\"1\":{\"150\":3,\"151\":2}}],[\"9094\",{\"1\":{\"149\":1,\"150\":2,\"151\":2}}],[\"9091\",{\"1\":{\"91\":1,\"151\":1,\"210\":1,\"257\":1}}],[\"9090访问prometheus的ui界面\",{\"1\":{\"274\":1}}],[\"9090的时间序列\",{\"1\":{\"259\":1}}],[\"9090可以在本地直接打开prometheus\",{\"1\":{\"216\":1}}],[\"9090\",{\"1\":{\"58\":1,\"69\":2,\"151\":2,\"156\":4,\"169\":3,\"174\":1,\"175\":4,\"210\":1,\"216\":2,\"241\":2,\"246\":2,\"255\":2,\"257\":2,\"259\":5,\"260\":2,\"273\":2,\"274\":2,\"280\":2,\"287\":3,\"357\":4,\"360\":2,\"361\":2,\"377\":1,\"378\":1}}],[\"9093\",{\"1\":{\"57\":1,\"58\":1,\"149\":1,\"150\":4,\"151\":2,\"214\":3,\"273\":1}}],[\"类加载\",{\"1\":{\"87\":1}}],[\"类型为summary或者histogram的指标x\",{\"1\":{\"116\":2}}],[\"类型\",{\"1\":{\"85\":1,\"105\":1,\"129\":1}}],[\"会返回\",{\"1\":{\"358\":1}}],[\"会返回多条满足这些特征维度的时间序列\",{\"1\":{\"262\":1}}],[\"会将该collector自己注册到collectorregistry\",{\"1\":{\"350\":1}}],[\"会将该实例保存到collectorregistry当中\",{\"1\":{\"86\":1}}],[\"会有不同的东西扮演代理人\",{\"1\":{\"313\":1}}],[\"会移除那些不匹配regex定义的所有标签\",{\"1\":{\"310\":1}}],[\"会提示连接成功的信息\",{\"1\":{\"283\":1}}],[\"会选择出所有属于该度量指标的时序的当前采样值\",{\"1\":{\"260\":1}}],[\"会在下一节详细介绍\",{\"1\":{\"248\":1,\"369\":1}}],[\"会产生一个新的向量\",{\"1\":{\"247\":2,\"364\":2}}],[\"会产生一个由vector1的元素组成的新的向量\",{\"1\":{\"247\":1,\"364\":1}}],[\"会针对服务器的资源设置相应的告警阈值\",{\"1\":{\"239\":1}}],[\"会通过alertmanager\",{\"1\":{\"214\":1}}],[\"会自动将用于访问kubernetes\",{\"1\":{\"186\":1}}],[\"会自动创建多个时间序列\",{\"1\":{\"95\":1}}],[\"会从集群中找到满足条件的节点运行它\",{\"1\":{\"178\":1}}],[\"会从collectorregistry中拿到所有的collector实例\",{\"1\":{\"86\":1}}],[\"会按照以下流程对告警进行处理\",{\"1\":{\"148\":1}}],[\"会导致dashboard配置的频繁变更\",{\"1\":{\"131\":1}}],[\"会要求用户设置该常量的值\",{\"1\":{\"129\":1}}],[\"会显示如下界面\",{\"1\":{\"126\":1}}],[\"会出现\",{\"1\":{\"110\":1}}],[\"否则返回0\",{\"1\":{\"246\":1,\"361\":1}}],[\"否则进入下一阶段send对外发送告警通知\",{\"1\":{\"148\":1}}],[\"否则中断流水线不发送通知\",{\"1\":{\"148\":1}}],[\"否则显示为unhealth\",{\"1\":{\"144\":1}}],[\"否则页面中会提示\",{\"1\":{\"144\":1}}],[\"否则失败\",{\"1\":{\"101\":1,\"316\":1}}],[\"否则httpserver是找不到任何的collector实例的\",{\"1\":{\"86\":1}}],[\"否则生成的数据将无法符合prometheus的规范\",{\"1\":{\"85\":1}}],[\"别忘记调用collector的register\",{\"1\":{\"86\":1}}],[\"它基于简单线性回归的方式\",{\"1\":{\"239\":1}}],[\"它记录了prometheus\",{\"1\":{\"230\":1}}],[\"它是一个持续增大的值\",{\"1\":{\"227\":1}}],[\"它对外暴露一个唯一访问地址\",{\"1\":{\"206\":1}}],[\"它能够与通过与\",{\"1\":{\"185\":1}}],[\"它们的组合与prometheus与alertmanager解决了相同的问题\",{\"1\":{\"328\":1}}],[\"它们负责响应用户请求\",{\"1\":{\"183\":1}}],[\"它们负责响应用户请求并且对集群资源进行统一的调度和管理\",{\"1\":{\"179\":1}}],[\"它们负责管理和维护节点中运行的pod\",{\"1\":{\"179\":1,\"183\":1}}],[\"它们一起工作\",{\"1\":{\"178\":1,\"180\":1}}],[\"它们分别代表了云原生模式下容器编排以及监控的事实标准\",{\"1\":{\"172\":1}}],[\"它们具有完全相同的配置包括job配置\",{\"1\":{\"147\":1}}],[\"它们与特定的数据源无关\",{\"1\":{\"126\":1}}],[\"它允许用户通过go模板语言创建任意的控制台界面\",{\"1\":{\"132\":1}}],[\"它会自动调用所有collector的collect\",{\"1\":{\"86\":1}}],[\"它可以是一个邮箱也可以是微信\",{\"1\":{\"26\":1}}],[\"标量与瞬时向量\",{\"0\":{\"357\":1}}],[\"标量与标量\",{\"0\":{\"356\":1}}],[\"标量和瞬时向量之间进行数学运算\",{\"1\":{\"357\":1}}],[\"标量和标量之间进行比较时\",{\"1\":{\"362\":1}}],[\"标量和标量之间进行比较运算\",{\"1\":{\"362\":1}}],[\"标量和标量之间进行数学运算\",{\"1\":{\"356\":1}}],[\"标量和标量\",{\"0\":{\"362\":1},\"1\":{\"355\":1,\"359\":1}}],[\"标量和字符串\",{\"0\":{\"263\":1}}],[\"标量只有一个数字\",{\"1\":{\"264\":1}}],[\"标量\",{\"0\":{\"264\":1},\"1\":{\"256\":1}}],[\"标准方差\",{\"1\":{\"226\":1}}],[\"标准差异\",{\"1\":{\"368\":1}}],[\"标准差\",{\"1\":{\"226\":1,\"368\":1}}],[\"标签的键值对完全相等则表示匹配成功\",{\"1\":{\"358\":1}}],[\"标签的值则可以包含任何unicode编码的字符\",{\"1\":{\"269\":1}}],[\"标签的名称只能由ascii字符\",{\"1\":{\"269\":1}}],[\"标签\",{\"1\":{\"269\":1}}],[\"标签来指定监控指标名称\",{\"1\":{\"266\":1}}],[\"标签完全一致\",{\"1\":{\"244\":1,\"245\":1,\"249\":1,\"250\":1,\"365\":1,\"366\":1}}],[\"标签选择器\",{\"1\":{\"178\":1}}],[\"标签名为label的所有可选值\",{\"1\":{\"130\":2}}],[\"标签名数组\",{\"1\":{\"85\":1}}],[\"标签值为blockbox\",{\"1\":{\"100\":1}}],[\"标签值数组以及样本数据的值\",{\"1\":{\"85\":1}}],[\"标点符号是否使用正确\",{\"1\":{\"4\":1}}],[\"消息队列\",{\"1\":{\"114\":1}}],[\"消息中间件等\",{\"1\":{\"82\":1}}],[\"消息发送的目标channel\",{\"1\":{\"48\":1}}],[\"按主机查询各个磁盘的io状态\",{\"1\":{\"378\":1}}],[\"按主机查询主机内存使用量\",{\"1\":{\"378\":1}}],[\"按cpu模式查询主机的cpu使用率\",{\"1\":{\"378\":1}}],[\"按需使用就意味着资源的动态性\",{\"1\":{\"313\":1}}],[\"按照不同的环境dev\",{\"1\":{\"308\":1}}],[\"按照主机查询各个主机的cpu使用率\",{\"1\":{\"262\":1}}],[\"按照mode计算主机cpu的平均使用时间\",{\"1\":{\"262\":1}}],[\"按照两个小时为一个时间窗口\",{\"1\":{\"159\":1}}],[\"按照实例进行功能分区\",{\"0\":{\"156\":1}}],[\"按列显示时间序列\",{\"0\":{\"80\":1}}],[\"按行显示时间序列\",{\"0\":{\"79\":1}}],[\"按钮\",{\"1\":{\"126\":1,\"141\":1,\"283\":1}}],[\"按钮使当前规则过期\",{\"1\":{\"37\":1,\"39\":1}}],[\"按钮即可\",{\"1\":{\"37\":1,\"39\":1}}],[\"共享dashboard\",{\"0\":{\"74\":1}}],[\"8600\",{\"1\":{\"305\":5}}],[\"864551424\",{\"1\":{\"244\":1,\"358\":1}}],[\"888716127000002s\",{\"1\":{\"230\":1}}],[\"888716127000002\",{\"1\":{\"230\":1}}],[\"8443\",{\"1\":{\"192\":1,\"202\":1}}],[\"8fjm6\",{\"1\":{\"181\":1}}],[\"894923811z\",{\"1\":{\"150\":1}}],[\"8919e\",{\"1\":{\"99\":1}}],[\"8302\",{\"1\":{\"305\":1}}],[\"8301\",{\"1\":{\"305\":2}}],[\"83\",{\"1\":{\"206\":1}}],[\"8320f0a\",{\"1\":{\"150\":2}}],[\"8376\",{\"1\":{\"93\":1}}],[\"871180749z\",{\"1\":{\"150\":1}}],[\"807\",{\"1\":{\"244\":4,\"358\":10}}],[\"80\",{\"1\":{\"181\":5}}],[\"8086\",{\"1\":{\"167\":5}}],[\"8080可以查看\",{\"1\":{\"105\":1}}],[\"8080\",{\"1\":{\"34\":1,\"93\":1,\"100\":2,\"105\":2,\"106\":1,\"217\":5,\"241\":2,\"307\":1}}],[\"8003\",{\"1\":{\"150\":1}}],[\"8002\",{\"1\":{\"149\":1,\"150\":1}}],[\"8001\",{\"1\":{\"149\":3,\"150\":3}}],[\"8203125\",{\"1\":{\"310\":2}}],[\"827kb\",{\"1\":{\"104\":1}}],[\"828b\",{\"1\":{\"104\":1}}],[\"8191\",{\"1\":{\"111\":1}}],[\"8192\",{\"1\":{\"87\":1,\"349\":1}}],[\"81\",{\"1\":{\"99\":1}}],[\"8\",{\"1\":{\"90\":2,\"95\":1,\"139\":1,\"142\":1,\"187\":1,\"280\":1,\"349\":1}}],[\"8500\",{\"1\":{\"305\":3,\"306\":1,\"310\":1,\"311\":1}}],[\"8556\",{\"1\":{\"151\":1}}],[\"855gib\",{\"1\":{\"104\":1}}],[\"853370185z\",{\"1\":{\"150\":1}}],[\"85\",{\"1\":{\"69\":4,\"151\":2}}],[\"实际上根据不同的系统类型和目标\",{\"1\":{\"233\":1}}],[\"实际上prometheus\",{\"1\":{\"210\":1}}],[\"实际含义\",{\"1\":{\"95\":2}}],[\"实例的metadata信息\",{\"1\":{\"309\":1}}],[\"实例级别功能分区\",{\"1\":{\"156\":1}}],[\"实例\",{\"0\":{\"69\":1}}],[\"实现collector后通过register\",{\"1\":{\"351\":1}}],[\"实现对主机监控的支持\",{\"1\":{\"370\":1}}],[\"实现对数据的查询以及分析\",{\"1\":{\"276\":1}}],[\"实现对kubernetes集群以及其中部署的各类资源的自动化监控\",{\"1\":{\"198\":1}}],[\"实现对kubernetes集群的全面监控\",{\"1\":{\"187\":1}}],[\"实现对监控样本收集\",{\"1\":{\"85\":1}}],[\"实现了对应用生命周期管理从自动化到自主化的跨越\",{\"1\":{\"181\":1}}],[\"实现自定义remote\",{\"1\":{\"166\":1}}],[\"实现自动化的信息同步\",{\"1\":{\"29\":1}}],[\"实现告警通知\",{\"1\":{\"70\":1}}],[\"实现项目信息同步\",{\"1\":{\"29\":1}}],[\"实现源码更新同步\",{\"1\":{\"29\":1}}],[\"静默设置需要在alertmanager的web页面上进行设置\",{\"1\":{\"64\":1}}],[\"静默提供了一个简单的机制可以快速根据标签对告警进行静默处理\",{\"1\":{\"64\":1}}],[\"静默\",{\"0\":{\"64\":1}}],[\"静默规则创建成功后\",{\"1\":{\"37\":1,\"39\":1}}],[\"分钟\",{\"1\":{\"260\":1}}],[\"分位数\",{\"1\":{\"226\":1}}],[\"分位数quantiles\",{\"1\":{\"95\":1}}],[\"分别监听9090和9091端口\",{\"1\":{\"151\":1}}],[\"分别用于table面板\",{\"1\":{\"126\":1}}],[\"分别用于计数器+1和\",{\"1\":{\"89\":1}}],[\"分别是\",{\"1\":{\"126\":1,\"141\":1,\"187\":1}}],[\"分别为\",{\"1\":{\"95\":1}}],[\"分组机制可以将详细的告警信息合并成一个通知\",{\"1\":{\"62\":1}}],[\"分组\",{\"0\":{\"62\":1},\"1\":{\"61\":1,\"325\":1}}],[\"分布统计\",{\"0\":{\"140\":1},\"1\":{\"9\":1,\"21\":1,\"368\":1}}],[\"还支持时间序列之间进行逻辑和数学运算\",{\"1\":{\"354\":1}}],[\"还支持keep\",{\"1\":{\"311\":1}}],[\"还能支持graphite这些其他的监控工具\",{\"1\":{\"298\":1}}],[\"还能帮助系统管理员分析和优化网站体验\",{\"1\":{\"101\":1,\"316\":1}}],[\"还包含一组用于描述该样本特征的标签\",{\"1\":{\"294\":1}}],[\"还内置了大量的函数\",{\"1\":{\"282\":1}}],[\"还需要用户通过注解指定用户提供监控指标的采集端口\",{\"1\":{\"201\":1}}],[\"还需要充分了解应用程序以及kubernetes集群服务运行质量如何\",{\"1\":{\"180\":1,\"182\":1}}],[\"还提供了面向企业的组织级管理能力\",{\"1\":{\"124\":1}}],[\"还可以定义action的配置为labelmap\",{\"1\":{\"310\":1}}],[\"还可以使用prometheus服务发现\",{\"1\":{\"292\":1}}],[\"还可以使用deriv\",{\"1\":{\"229\":1}}],[\"还可以扩展出更多的玩法\",{\"1\":{\"207\":1}}],[\"还可以体现出kubelet与当前节点的docker服务的调用情况\",{\"1\":{\"199\":1}}],[\"还可以匹配http服务的响应内容\",{\"1\":{\"103\":1,\"318\":1}}],[\"还可以通过prometheus社区提供的client\",{\"1\":{\"347\":1}}],[\"还可以通过prometheus\",{\"1\":{\"280\":1}}],[\"还可以通过headers定义相关的请求头信息\",{\"1\":{\"102\":1,\"317\":1}}],[\"还可以通过group\",{\"1\":{\"60\":1}}],[\"还应该添加适当的黑盒监控\",{\"1\":{\"98\":1}}],[\"还直接提供了对prometheus中4种监控类型的实现分别是\",{\"1\":{\"88\":1}}],[\"还实现了对hibernate\",{\"1\":{\"87\":1}}],[\"还主要提供了如\",{\"1\":{\"61\":1}}],[\"后n条时序\",{\"1\":{\"226\":1,\"368\":1}}],[\"后端则通过endpoint指向多个pod实例\",{\"1\":{\"206\":1}}],[\"后续用户就可以通过$variable\",{\"1\":{\"129\":1}}],[\"后出发告警\",{\"1\":{\"60\":1}}],[\"后面就应该一直使用label这个词\",{\"1\":{\"4\":1}}],[\"后面就可以直接使用中文\",{\"1\":{\"4\":1}}],[\"查\",{\"1\":{\"109\":1}}],[\"查询出一组时间序列的瞬时样本数据\",{\"1\":{\"357\":1}}],[\"查询\",{\"1\":{\"324\":1}}],[\"查询主机cpu总体使用率\",{\"1\":{\"378\":1}}],[\"查询主机负载变化情况\",{\"1\":{\"282\":1}}],[\"查询主机的cpu使用率\",{\"1\":{\"248\":1,\"369\":1}}],[\"查询系统所有http请求的总量\",{\"1\":{\"262\":1}}],[\"查询时间序列\",{\"0\":{\"259\":1}}],[\"查询步长\",{\"1\":{\"257\":1}}],[\"查询当前系统中\",{\"1\":{\"228\":1}}],[\"查询当前应用请求量top\",{\"1\":{\"95\":1}}],[\"查询编辑器\",{\"1\":{\"123\":1}}],[\"查询性能\",{\"0\":{\"112\":1}}],[\"查询数量的突变往往暗示着可能发生了某些严重的问题\",{\"1\":{\"109\":1}}],[\"查询吞吐量\",{\"1\":{\"108\":1}}],[\"查询容器文件系统写入速率\",{\"1\":{\"106\":1}}],[\"查询容器文件系统读取速率\",{\"1\":{\"106\":1}}],[\"查询容器网络传输量速率\",{\"1\":{\"106\":1}}],[\"查询容器网络接收量速率\",{\"1\":{\"106\":1}}],[\"查询容器内存使用量\",{\"1\":{\"106\":1}}],[\"查询每秒http请求量\",{\"1\":{\"95\":1}}],[\"查询应用的请求总量\",{\"1\":{\"95\":1}}],[\"查询告警实例\",{\"1\":{\"68\":1}}],[\"查询结果持续多长时间\",{\"1\":{\"60\":1}}],[\"查看target实例的标签信息\",{\"1\":{\"312\":1}}],[\"查看prometheus\",{\"1\":{\"223\":1}}],[\"查看prometheus的pod实例日志\",{\"1\":{\"218\":1}}],[\"查看pod实例\",{\"1\":{\"216\":1}}],[\"查看pod的情况如下所示\",{\"1\":{\"214\":1}}],[\"查看配置信息\",{\"1\":{\"216\":1}}],[\"查看monitoring命名空间下的statefulsets资源\",{\"1\":{\"216\":1}}],[\"查看当前alertmanager\",{\"1\":{\"214\":1}}],[\"查看defaultexports\",{\"1\":{\"350\":1}}],[\"查看deployment的运行状态\",{\"1\":{\"181\":1}}],[\"查看daemonset以及pod的运行状态\",{\"1\":{\"201\":1,\"205\":1}}],[\"查看kubernetes\",{\"1\":{\"199\":1}}],[\"查看运行的pod实例\",{\"1\":{\"181\":1}}],[\"查看运行状态\",{\"0\":{\"57\":1}}],[\"查看webhook日志只接收到一个告警通知\",{\"1\":{\"150\":1}}],[\"查看告警状态\",{\"0\":{\"68\":1}}],[\"查看alertmanager输出日志\",{\"1\":{\"151\":1}}],[\"查看alertmanager日志\",{\"1\":{\"150\":1}}],[\"查看alertmanager\",{\"1\":{\"58\":1}}],[\"接下来我们将在本地部署并运行一个prometheus\",{\"1\":{\"281\":1}}],[\"接下来我们将从prometheus的架构角度详细介绍prometheus生态中的各个组件\",{\"1\":{\"275\":1}}],[\"接下来我们将详细介绍alertmanager是如何处理这些接收到的告警信息的\",{\"1\":{\"59\":1}}],[\"接下来将介绍在promql中有两种典型的匹配模式\",{\"1\":{\"249\":1,\"365\":1}}],[\"接下来需要解决如何使用这些部署在kubernetes集群中的应用\",{\"1\":{\"178\":1}}],[\"接下来\",{\"0\":{\"59\":1,\"70\":1},\"1\":{\"70\":1,\"100\":2,\"125\":1,\"187\":1,\"201\":1,\"214\":2,\"300\":1,\"308\":1,\"352\":1,\"370\":1}}],[\"接收器可以关联邮件\",{\"1\":{\"55\":1}}],[\"接收到的告警通知结构体指针\",{\"1\":{\"32\":1}}],[\"接收人一般配合告警路由使用\",{\"1\":{\"26\":1}}],[\"接收人是一个抽象的概念\",{\"1\":{\"26\":1}}],[\"接收人\",{\"1\":{\"26\":1}}],[\"z0\",{\"1\":{\"269\":2}}],[\"z\",{\"1\":{\"269\":2}}],[\"zabbix的用户而言\",{\"1\":{\"290\":1}}],[\"za\",{\"1\":{\"269\":4}}],[\"zeus\",{\"1\":{\"229\":1}}],[\"zero>\",{\"1\":{\"58\":1,\"69\":1,\"151\":1}}],[\"z2xvymfsogogihnjcmfwzv9pbnrlcnzhbdogmtbzciagc2nyyxblx3rpbwvvdxq6idewcwogigv2ywx1yxrpb25faw50zxj2yww6idewcw==\",{\"1\":{\"210\":2}}],[\"zheng\",{\"1\":{\"34\":1}}],[\"zhaowenbo168\",{\"1\":{\"18\":1}}],[\"成功后\",{\"1\":{\"58\":1}}],[\"成为\",{\"1\":{\"4\":1}}],[\"关注系统资源的使用情况\",{\"1\":{\"236\":1}}],[\"关注的指标也不一样\",{\"1\":{\"118\":1}}],[\"关联promethues与servicemonitor\",{\"0\":{\"218\":1}}],[\"关联prometheus与alertmanager\",{\"0\":{\"58\":1}}],[\"关于内置函数的部分\",{\"1\":{\"248\":1,\"369\":1}}],[\"关于heatmap面板的使用将会在接下来的部分介绍\",{\"1\":{\"139\":1}}],[\"关于alert的使用会在后续部分\",{\"1\":{\"138\":1}}],[\"关于路由的详细内容会在后续进行详细介绍\",{\"1\":{\"55\":1}}],[\"关于接收器的详细介绍会在后续章节介绍\",{\"1\":{\"55\":1}}],[\"关于术语的表述一定要统一\",{\"1\":{\"4\":1}}],[\"37131\",{\"1\":{\"360\":1}}],[\"37s\",{\"1\":{\"214\":1}}],[\"31\",{\"1\":{\"325\":1}}],[\"31017077500001ms\",{\"1\":{\"139\":1}}],[\"31017077500001\",{\"1\":{\"139\":1}}],[\"3102\",{\"1\":{\"116\":1}}],[\"397\",{\"1\":{\"273\":1}}],[\"399166371z\",{\"1\":{\"150\":1}}],[\"38544\",{\"1\":{\"268\":1}}],[\"38473\",{\"1\":{\"268\":1}}],[\"38m\",{\"1\":{\"186\":1}}],[\"34\",{\"1\":{\"250\":1,\"325\":1,\"366\":1}}],[\"346\",{\"1\":{\"150\":2}}],[\"3m\",{\"1\":{\"203\":1}}],[\"3a82\",{\"1\":{\"305\":2}}],[\"3a\",{\"1\":{\"169\":1}}],[\"3d~\",{\"1\":{\"169\":2}}],[\"3d\",{\"1\":{\"169\":1}}],[\"3个alertmanager实例分别接收到来自不同prometheus实例的告警信息\",{\"1\":{\"151\":1}}],[\"3个alertmanager实例分别接收到模拟的告警信息\",{\"1\":{\"150\":1}}],[\"3版本以后新添加的可视化面板\",{\"1\":{\"140\":1}}],[\"325\",{\"1\":{\"260\":2}}],[\"32584\",{\"1\":{\"175\":1}}],[\"326\",{\"1\":{\"259\":2,\"260\":10}}],[\"32s\",{\"1\":{\"214\":1}}],[\"32022\",{\"1\":{\"181\":1}}],[\"32的对数\",{\"1\":{\"142\":1}}],[\"32\",{\"1\":{\"139\":1,\"142\":1}}],[\"3272\",{\"1\":{\"116\":1}}],[\"36733\",{\"1\":{\"360\":1}}],[\"3600\",{\"1\":{\"229\":1,\"239\":1}}],[\"36h\",{\"1\":{\"160\":1}}],[\"36\",{\"1\":{\"139\":11,\"150\":6}}],[\"362812\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"286\":1}}],[\"308\",{\"1\":{\"357\":4}}],[\"30500\",{\"1\":{\"214\":1}}],[\"30\",{\"1\":{\"104\":1,\"250\":1,\"251\":1,\"257\":1,\"366\":1,\"367\":1}}],[\"3000就可以进入到grafana的界面中\",{\"1\":{\"283\":1}}],[\"3000\",{\"1\":{\"283\":2}}],[\"30000\",{\"1\":{\"181\":1}}],[\"300\",{\"1\":{\"103\":1,\"218\":1,\"318\":1}}],[\"30s\",{\"1\":{\"40\":1,\"42\":1,\"51\":1,\"165\":2,\"214\":1,\"218\":3}}],[\"3\",{\"1\":{\"85\":2,\"86\":2,\"87\":1,\"91\":1,\"95\":1,\"99\":1,\"104\":1,\"105\":1,\"108\":1,\"116\":1,\"159\":1,\"166\":1,\"167\":6,\"181\":5,\"197\":1,\"203\":1,\"214\":1,\"216\":2,\"217\":2,\"240\":5,\"250\":1,\"267\":1,\"273\":1,\"280\":1,\"286\":1,\"290\":1,\"349\":4,\"350\":1,\"366\":1}}],[\"33444\",{\"1\":{\"116\":1}}],[\"3306\",{\"1\":{\"108\":3,\"206\":2}}],[\"33\",{\"1\":{\"57\":1,\"58\":1,\"280\":1,\"375\":1,\"378\":1}}],[\"默认返回的\",{\"1\":{\"190\":1}}],[\"默认获取到的target地址为\",{\"1\":{\"190\":1}}],[\"默认为当前节点上运行的kubelet的访问地址\",{\"1\":{\"189\":1}}],[\"默认值\",{\"1\":{\"160\":1}}],[\"默认其应该是定义在prom\",{\"1\":{\"134\":1}}],[\"默认使用最新格式规范的版本\",{\"1\":{\"117\":1}}],[\"默认的buckets范围为\",{\"1\":{\"352\":1}}],[\"默认的action行为为replace\",{\"1\":{\"310\":1}}],[\"默认的head组件\",{\"1\":{\"134\":1}}],[\"默认的分布桶为\",{\"1\":{\"90\":1}}],[\"默认的存储路径为data\",{\"1\":{\"56\":1,\"273\":1}}],[\"默认情况下比较运算符的默认行为是对时序数据进行过滤\",{\"1\":{\"361\":1}}],[\"默认情况下使用账户admin\",{\"1\":{\"283\":1}}],[\"默认情况下使用\",{\"1\":{\"255\":1,\"257\":1}}],[\"默认情况下使用当前系统时间\",{\"1\":{\"255\":1}}],[\"默认情况下servicemonitor和监控对象必须是在相同namespace下的\",{\"1\":{\"217\":1}}],[\"默认情况下其分别指向prometheus当前安装路径的console\",{\"1\":{\"133\":1}}],[\"默认情况下http探针会走ipv6的协议\",{\"1\":{\"103\":1,\"318\":1}}],[\"默认情况下prometheus暴露的metrics\",{\"1\":{\"93\":1}}],[\"默认情况下prometheus会每分钟对这些告警规则进行计算\",{\"1\":{\"66\":1}}],[\"默认情况下样本值不带任何的单位\",{\"1\":{\"77\":1}}],[\"默认情况下alertmanager使用了系统自带的默认通知模板\",{\"1\":{\"45\":1}}],[\"默认情况下所有的告警都会发送给集群管理员default\",{\"1\":{\"42\":1}}],[\"默认情况下\",{\"1\":{\"41\":1,\"65\":1,\"103\":1,\"138\":1,\"141\":1,\"144\":1,\"181\":1,\"250\":1,\"305\":1,\"309\":1,\"318\":1,\"363\":1,\"366\":1}}],[\"恢复时间\",{\"1\":{\"51\":1}}],[\"故障分析与定位\",{\"1\":{\"289\":1}}],[\"故障pod名称\",{\"1\":{\"51\":2}}],[\"故障物理机ip\",{\"1\":{\"51\":2}}],[\"故障实例所在namespace\",{\"1\":{\"51\":2}}],[\"故障实例ip\",{\"1\":{\"51\":2}}],[\"故障时间\",{\"1\":{\"51\":2}}],[\"企业id\",{\"1\":{\"51\":2}}],[\"企业微信相关概念说明请参考企业微信api说明\",{\"1\":{\"51\":1}}],[\"由default修改为monitoring\",{\"1\":{\"223\":1}}],[\"由瑞典mysql\",{\"1\":{\"107\":1}}],[\"由企业微信来做接收成员的划分\",{\"1\":{\"51\":1}}],[\"由于这些平台自身掌握着所有资源的信息\",{\"1\":{\"313\":1}}],[\"由于这里没有指定namespace\",{\"1\":{\"181\":1}}],[\"由于这里没有定义group\",{\"1\":{\"42\":1}}],[\"由于这里customexporter存在于spring的ioc容器当中\",{\"1\":{\"96\":1}}],[\"由于标量不存在时间序列一说\",{\"1\":{\"256\":1}}],[\"由于需要对prometheus\",{\"1\":{\"223\":1}}],[\"由于默认创建的prometheus实例使用的是monitoring命名空间下的default账号\",{\"1\":{\"219\":1}}],[\"由于该endpoint属于特定的servie\",{\"1\":{\"207\":1}}],[\"由于service中指定了标签选择器\",{\"1\":{\"206\":1}}],[\"由于kubernetes中pod可能会包含多个容器\",{\"1\":{\"201\":1}}],[\"由于kubernetes中并非所有的pod都提供了对prometheus的支持\",{\"1\":{\"201\":1}}],[\"由于node\",{\"1\":{\"201\":2,\"205\":2}}],[\"由于基于serviceaccount提供的ca证书中\",{\"1\":{\"192\":1}}],[\"由于gossip机制的实现\",{\"1\":{\"151\":1}}],[\"由于goreman不保证进程之间的启动顺序\",{\"1\":{\"150\":1}}],[\"由于prometheus数据采集基于pull模型进行设计\",{\"1\":{\"279\":1}}],[\"由于prometheus的pull机制的设计\",{\"1\":{\"153\":1}}],[\"由于prometheus的采集任务配置可能随时发生变更\",{\"1\":{\"131\":1}}],[\"由于prometheus基于pull模型\",{\"1\":{\"145\":1}}],[\"由于其监控样本中并不包含bucket相关信息\",{\"1\":{\"142\":1}}],[\"由于当前使用的promql的数据范围为0~1表示cpu的使用率\",{\"1\":{\"138\":1}}],[\"由于每个panel是完全独立的\",{\"1\":{\"123\":1}}],[\"由于操作系统本身并不直接支持prometheus\",{\"1\":{\"115\":1}}],[\"由于系统内部导致的错误\",{\"1\":{\"110\":1}}],[\"由于超出最大连接数导致的错误\",{\"1\":{\"110\":1}}],[\"由于告警规则中设置了1m的等待时间\",{\"1\":{\"69\":1}}],[\"由于主机异常宕机\",{\"1\":{\"36\":1}}],[\"使得prometheus相比于其他传统监控解决方案更适用于云以及容器环境下的监控需求\",{\"1\":{\"303\":1}}],[\"使得将监控指标与实际业务进行关联成为可能\",{\"1\":{\"225\":1}}],[\"使得监控样本数据满足告警触发条件\",{\"1\":{\"50\":1}}],[\"使用自定义collector监控第三方监控指标\",{\"1\":{\"351\":1}}],[\"使用中心化的服务发现注册中心时\",{\"1\":{\"311\":1}}],[\"使用keep\",{\"0\":{\"311\":1}}],[\"使用kubectl命令行工具\",{\"1\":{\"174\":1}}],[\"使用容器安装\",{\"0\":{\"274\":1}}],[\"使用聚合操作\",{\"0\":{\"262\":1}}],[\"使用聚合操作的语法如下\",{\"1\":{\"226\":1,\"368\":1}}],[\"使用label=~regx表示选择那些标签符合正则表达式定义的时间序列\",{\"1\":{\"259\":1}}],[\"使用legend\",{\"1\":{\"138\":1}}],[\"使用query\",{\"1\":{\"257\":1}}],[\"使用query类型的变量能够根据允许用户能够根据时间序列的特征维度对数据进行过滤\",{\"1\":{\"130\":1}}],[\"使用ignoreing可以在匹配时忽略某些便签\",{\"1\":{\"366\":1}}],[\"使用ignoreing可以在匹配时忽略某些标签\",{\"1\":{\"250\":1}}],[\"使用influxdb作为remote\",{\"0\":{\"167\":1}}],[\"使用inhibit\",{\"1\":{\"36\":1}}],[\"使用表达式获取当前正常的任务状态\",{\"1\":{\"363\":1}}],[\"使用表达式\",{\"1\":{\"250\":1,\"251\":1,\"366\":1,\"367\":1}}],[\"使用瞬时向量表达式能够获取到一个包含多个时间序列的集合\",{\"1\":{\"247\":1}}],[\"使用集合运算符\",{\"0\":{\"247\":1}}],[\"使用布尔运算过滤时间序列\",{\"0\":{\"245\":1}}],[\"使用如下表达式\",{\"1\":{\"240\":1}}],[\"使用率\",{\"1\":{\"236\":2}}],[\"使用port\",{\"1\":{\"214\":1}}],[\"使用promql表达式\",{\"1\":{\"250\":1,\"366\":1}}],[\"使用promql除了能够方便的按照查询和过滤时间序列以外\",{\"1\":{\"243\":1}}],[\"使用promql查询到时间序列后\",{\"1\":{\"241\":1}}],[\"使用promql查询当前mysql实例连接拒绝数\",{\"1\":{\"110\":1}}],[\"使用promql查询监控数据\",{\"0\":{\"282\":1},\"1\":{\"8\":1,\"20\":1}}],[\"使用prometheus的client\",{\"1\":{\"300\":1}}],[\"使用prometheus可以快速搭建监控服务\",{\"1\":{\"298\":1}}],[\"使用prometheus监控rabbitmq\",{\"0\":{\"390\":1}}],[\"使用prometheus监控rancher集群\",{\"0\":{\"301\":1}}],[\"使用prometheus监控nginx状态\",{\"0\":{\"386\":1}}],[\"使用prometheus监控主机\",{\"1\":{\"270\":1}}],[\"使用prometheus监控kubernetes集群\",{\"0\":{\"198\":1}}],[\"使用prometheusrule定义告警规则\",{\"0\":{\"213\":1}}],[\"使用prometheus采集api\",{\"0\":{\"192\":1}}],[\"使用prometheus采集主机的监控数据\",{\"1\":{\"5\":1}}],[\"使用prometheus构建联邦集群\",{\"0\":{\"75\":1}}],[\"使用api\",{\"1\":{\"200\":1}}],[\"使用replace\",{\"0\":{\"310\":1}}],[\"使用relabeling修改采集任务\",{\"0\":{\"190\":1}}],[\"使用recoding\",{\"0\":{\"71\":1},\"1\":{\"8\":1,\"20\":1}}],[\"使用receiver接收告警信息\",{\"1\":{\"8\":1,\"20\":1}}],[\"使用联邦集群\",{\"0\":{\"169\":1}}],[\"使用以下命令创建资源\",{\"1\":{\"175\":1}}],[\"使用以下命令可以在本地安装goreman命令行工具\",{\"1\":{\"149\":1}}],[\"使用以上参数发送一条更有趣的消息\",{\"1\":{\"48\":1}}],[\"使用本地存储可以降低prometheus部署和管理的复杂度\",{\"1\":{\"145\":1}}],[\"使用simpleclient\",{\"1\":{\"349\":1}}],[\"使用singlestat\",{\"0\":{\"144\":1}}],[\"使用service\",{\"1\":{\"221\":1}}],[\"使用servicemonitor管理监控配置\",{\"0\":{\"217\":1}}],[\"使用summary指标\",{\"1\":{\"95\":1}}],[\"使用hashmod计算source\",{\"0\":{\"312\":1}}],[\"使用histogram和summary分析数据分布情况\",{\"0\":{\"230\":1}}],[\"使用heatmap可视化其它类型样本分布情况\",{\"0\":{\"142\":1}}],[\"使用heatmap可视化histogram样本分布情况\",{\"0\":{\"141\":1}}],[\"使用http\",{\"0\":{\"86\":1}}],[\"使用变量获取当前所有可选任务\",{\"1\":{\"131\":1}}],[\"使用变量动态创建panel和row\",{\"0\":{\"131\":1}}],[\"使用变量过滤时间序列\",{\"0\":{\"130\":1}}],[\"使用\",{\"1\":{\"126\":1}}],[\"使用daemonset部署node\",{\"0\":{\"205\":1}}],[\"使用deployment部署prometheus\",{\"0\":{\"175\":1}}],[\"使用docker\",{\"1\":{\"108\":1}}],[\"使用dingtalk扩展\",{\"0\":{\"34\":1}}],[\"使用fail\",{\"1\":{\"103\":1,\"318\":1}}],[\"使用bool改变比较运算的默认行为\",{\"0\":{\"361\":1}}],[\"使用bool修改比较运算的默认行为之后\",{\"1\":{\"361\":1}}],[\"使用bool修改符后\",{\"1\":{\"246\":1}}],[\"使用bool修饰符改变布尔运算符的行为\",{\"0\":{\"246\":1}}],[\"使用body定义请求内容\",{\"1\":{\"102\":1,\"317\":1}}],[\"使用blackbox\",{\"0\":{\"99\":1}}],[\"使用goreman启动多节点prometheus\",{\"1\":{\"151\":1}}],[\"使用golang创建webhook服务\",{\"0\":{\"28\":1}}],[\"使用grafana创建可视化dashboard\",{\"0\":{\"283\":1}}],[\"使用grafana创建更精美的数据仪表盘\",{\"1\":{\"118\":1}}],[\"使用graph面板可视化histogram\",{\"0\":{\"139\":1}}],[\"使用graph面板可视化counter\",{\"0\":{\"138\":1}}],[\"使用gauge可以反映应用的\",{\"1\":{\"95\":1}}],[\"使用内置的collector\",{\"0\":{\"87\":1}}],[\"使用endpoint发现node\",{\"0\":{\"207\":1}}],[\"使用exporter\",{\"0\":{\"82\":1}}],[\"使用emoji作为聊天机器人的头像\",{\"1\":{\"48\":1}}],[\"使用table可视化时间序列\",{\"0\":{\"78\":1}}],[\"使用二进制包部署alertmanager\",{\"0\":{\"53\":1}}],[\"使用webhook扩展alertmanager\",{\"0\":{\"27\":1}}],[\"使用operator管理alertmanager实例\",{\"0\":{\"214\":1}}],[\"使用operator管理告警\",{\"0\":{\"212\":1}}],[\"使用operator管理监控配置\",{\"1\":{\"10\":1,\"22\":1}}],[\"使用operator管理prometheus\",{\"0\":{\"215\":1},\"1\":{\"10\":1,\"22\":1}}],[\"使用cadvisor\",{\"0\":{\"105\":1}}],[\"使用configmap和secret来管理应用配置\",{\"1\":{\"221\":1}}],[\"使用configmaps管理应用配置\",{\"0\":{\"174\":1}}],[\"使用console\",{\"0\":{\"132\":1},\"1\":{\"9\":1,\"21\":1,\"118\":1}}],[\"使用collector暴露其它指标\",{\"0\":{\"96\":1}}],[\"使用counter\",{\"1\":{\"95\":1}}],[\"使用client\",{\"0\":{\"84\":1},\"1\":{\"9\":1,\"21\":1}}],[\"使用java自定义exporter\",{\"0\":{\"97\":1},\"1\":{\"9\":1,\"21\":1}}],[\"使用nodeexporter监控主机\",{\"0\":{\"370\":1}}],[\"使用nodeexporter监控集群资源使用情况\",{\"0\":{\"201\":1}}],[\"使用node\",{\"0\":{\"284\":1},\"1\":{\"8\":1,\"20\":1}}],[\"应该关注mysql缓冲池的资源使用情况\",{\"1\":{\"111\":1}}],[\"应该有图号\",{\"1\":{\"4\":1}}],[\"应用延迟时间的分布范围\",{\"1\":{\"295\":1}}],[\"应用重启\",{\"1\":{\"238\":1}}],[\"应用\",{\"1\":{\"232\":1,\"313\":1}}],[\"应用容器监控\",{\"0\":{\"188\":1}}],[\"应用容器等全面的监控体系\",{\"1\":{\"180\":1}}],[\"应用的agentid\",{\"1\":{\"51\":1}}],[\"应用的secret\",{\"1\":{\"51\":2}}],[\"应用专有密码\",{\"1\":{\"50\":1}}],[\"每秒处理数十万的数据点\",{\"1\":{\"296\":1}}],[\"每秒失败的请求数\",{\"1\":{\"235\":1}}],[\"每条时间序列按照时间的先后顺序存储一系列的样本值\",{\"1\":{\"294\":1}}],[\"每条time\",{\"1\":{\"268\":1}}],[\"每次对prometheus配置文件进行升级时\",{\"1\":{\"220\":1}}],[\"每个服务器节点上运行一个node\",{\"1\":{\"308\":1}}],[\"每个团队运行独立的prometheus\",{\"1\":{\"297\":1}}],[\"每个请求的耗时\",{\"1\":{\"235\":1}}],[\"每个promql表达式都可能返回多条时间序列\",{\"1\":{\"126\":1}}],[\"每个应用对应不同的报警分组\",{\"1\":{\"51\":1}}],[\"每个email\",{\"1\":{\"50\":1}}],[\"每一条时间序列存储在单独的文件当中\",{\"1\":{\"326\":1}}],[\"每一条时间序列由指标名称\",{\"1\":{\"294\":1}}],[\"每一条抑制规则的具体配置如下\",{\"1\":{\"36\":1}}],[\"每一台被监控的硬件主机或者服务都需要运行一个与监控中心服务器进行通信的nagios软件后台程序\",{\"1\":{\"290\":1}}],[\"每一台主机都会有一条单独的曲线用于体现其cpu使用率的变化情况\",{\"1\":{\"127\":1}}],[\"每一种类型的面板都提供了相应的查询编辑器\",{\"1\":{\"126\":1}}],[\"每一行样本需要满足以下格式规范\",{\"1\":{\"116\":1}}],[\"每一个监控指标拥有对个基于key\",{\"1\":{\"325\":1}}],[\"每一个监控指标之前都会有一段类似于如下形式的信息\",{\"1\":{\"286\":1}}],[\"每一个target实例都包含了一个新的tmp\",{\"1\":{\"312\":1}}],[\"每一个集群运行多个主机节点\",{\"1\":{\"308\":1}}],[\"每一个暴露监控样本数据的http服务称为一个实例\",{\"1\":{\"280\":1}}],[\"每一个prometheus\",{\"1\":{\"170\":1}}],[\"每一个块中包含该时间窗口内的所有样本数据\",{\"1\":{\"159\":1}}],[\"每一个分布需要使用x\",{\"1\":{\"116\":1}}],[\"每一个module主要包含以下配置内容\",{\"1\":{\"99\":1}}],[\"每一个规则文件通过以下格式进行定义\",{\"1\":{\"72\":1}}],[\"每一个receiver具有一个全局唯一的名称\",{\"1\":{\"43\":1}}],[\"每一个路由都可以定义自己的接受人以及匹配规则\",{\"1\":{\"41\":1}}],[\"每一个告警都会从配置文件中顶级的route进入路由树\",{\"1\":{\"41\":1}}],[\"每一项webhook\",{\"1\":{\"27\":1}}],[\"完全匹配和正则匹配\",{\"1\":{\"259\":1}}],[\"完成\",{\"1\":{\"181\":1}}],[\"完成全局smtp之后\",{\"1\":{\"50\":1}}],[\"完整的prometheus配置文件\",{\"1\":{\"377\":1}}],[\"完整的relabel\",{\"1\":{\"310\":1}}],[\"完整的示例代码可以从github仓库https\",{\"1\":{\"29\":1}}],[\"完整内容如下\",{\"1\":{\"151\":1}}],[\"邮箱应该是目前企业最常用的告警通知方式\",{\"1\":{\"50\":1}}],[\"邮件通知模板等信息即可\",{\"1\":{\"50\":1}}],[\"邮件\",{\"1\":{\"43\":1}}],[\"邮件模板等\",{\"1\":{\"26\":1}}],[\"直方图\",{\"1\":{\"227\":1}}],[\"直到pod的运行状态满足controller中定义的预期状态为止\",{\"1\":{\"178\":1}}],[\"直到传播到集群中的所有节点\",{\"1\":{\"148\":1}}],[\"直到找到最深的匹配route\",{\"1\":{\"41\":1}}],[\"直接采集\",{\"1\":{\"277\":1}}],[\"直接采集kubelet监控指标\",{\"1\":{\"199\":1}}],[\"直接通过类似于promql表达式http\",{\"1\":{\"260\":1}}],[\"直接访问kubelet\",{\"1\":{\"200\":1}}],[\"直接访问kubelet的\",{\"1\":{\"200\":1}}],[\"直接丢弃该块即可\",{\"1\":{\"159\":1}}],[\"直接引用以下模板即可\",{\"1\":{\"135\":1}}],[\"直接在代码中集成\",{\"0\":{\"352\":1}}],[\"直接在head组件中移除\",{\"1\":{\"134\":1}}],[\"直接在应用程序层面提供对prometheus的支持\",{\"1\":{\"97\":1}}],[\"直接运行一下命令即可\",{\"1\":{\"105\":1}}],[\"直接统计其样本的分布情况\",{\"1\":{\"90\":1}}],[\"直接使用prometheus的镜像即可启动prometheus\",{\"1\":{\"274\":1}}],[\"直接使用promql可能会导致prometheus响应超时的情况\",{\"1\":{\"71\":1}}],[\"直接使用字符串\",{\"1\":{\"265\":1}}],[\"直接使用时间序列中返回的bucket即可\",{\"1\":{\"141\":1}}],[\"直接使用metricfamilysamples\",{\"1\":{\"85\":1}}],[\"直接使用go\",{\"1\":{\"49\":1}}],[\"示例应用会通过deployment创建3个pod实例\",{\"1\":{\"217\":1}}],[\"示例结构如下所示\",{\"1\":{\"150\":1}}],[\"示例\",{\"1\":{\"48\":1}}],[\"参数必须是一个瞬时向量选择器\",{\"1\":{\"169\":1}}],[\"参数指定我们可以指定需要获取的时间序列\",{\"1\":{\"169\":1}}],[\"参数名称\",{\"1\":{\"135\":1}}],[\"参数\",{\"1\":{\"48\":1,\"169\":1}}],[\"参考资料\",{\"0\":{\"12\":1},\"1\":{\"10\":1,\"22\":1}}],[\"为将这些节点上定义的标签写入到样本中时\",{\"1\":{\"310\":1}}],[\"为target实例添加了自定义标签env\",{\"1\":{\"309\":1}}],[\"为什么\",{\"1\":{\"210\":1}}],[\"为什么需要使用prometheus\",{\"1\":{\"208\":1}}],[\"为监控样本添加了额外的标签信息\",{\"1\":{\"203\":1}}],[\"为监控埋点做准备\",{\"0\":{\"94\":1}}],[\"为prometheus创建监控采集任务kubernetes\",{\"1\":{\"201\":1}}],[\"为pometheus配置文件添加以下内容\",{\"1\":{\"192\":1}}],[\"为https\",{\"1\":{\"190\":1}}],[\"为应用提供运行时环境\",{\"1\":{\"180\":1}}],[\"为整个集群和应用提供运行时资源\",{\"1\":{\"180\":1}}],[\"为用户提供了一个可以统一调度\",{\"1\":{\"180\":1,\"182\":1}}],[\"为kubernetes集群提供运行时环境\",{\"1\":{\"179\":1,\"183\":1}}],[\"为dashboard添加变量\",{\"1\":{\"129\":1}}],[\"为default\",{\"1\":{\"34\":1}}],[\"为了方便用户集成\",{\"1\":{\"348\":1}}],[\"为了减少这种绑定所带来的限制\",{\"1\":{\"300\":1}}],[\"为了在kubernetes能够方便的管理和部署prometheus\",{\"1\":{\"220\":1}}],[\"为了修复这个问题\",{\"1\":{\"219\":1}}],[\"为了通过prometheus\",{\"1\":{\"214\":1}}],[\"为了区分是平均的慢还是长尾的慢\",{\"1\":{\"230\":1}}],[\"为了区分集群中哪些endpoint是可以采集的\",{\"1\":{\"207\":1}}],[\"为了区分集群中需要进行探测的service实例\",{\"1\":{\"203\":1}}],[\"为了区分哪些pod实例是可以供prometheus进行采集的\",{\"1\":{\"201\":1}}],[\"为了解决该问题\",{\"1\":{\"199\":1,\"238\":1}}],[\"为了解决这一问题\",{\"1\":{\"147\":1}}],[\"为了能让程序之间能够相互访问\",{\"1\":{\"194\":1}}],[\"为了能够采集到主机的监控指标\",{\"1\":{\"370\":1}}],[\"为了能够采集集群中各个节点的资源使用情况\",{\"1\":{\"201\":1}}],[\"为了能够帮助用户理解和区分这些不同监控指标之间的差异\",{\"1\":{\"227\":1}}],[\"为了能够自动化的管理prometheus的配置\",{\"1\":{\"217\":1}}],[\"为了能够对ingress和service进行探测\",{\"1\":{\"203\":1}}],[\"为了能够通过prometheus采集到cadvisor的metrics服务\",{\"1\":{\"190\":1}}],[\"为了能够统一管理这些pod的配置信息\",{\"1\":{\"174\":1}}],[\"为了能够在通过prometheus\",{\"1\":{\"210\":1}}],[\"为了能够在本地模拟集群环境\",{\"1\":{\"149\":1}}],[\"为了能够在monitoring中接收来自alertmanager的消息\",{\"1\":{\"48\":1}}],[\"为了能够让客户端的图标更具有可读性\",{\"1\":{\"241\":1}}],[\"为了能够让部署在集群内的应用\",{\"1\":{\"202\":1}}],[\"为了能够让用户或者其它服务能够访问到nginx实例\",{\"1\":{\"181\":1}}],[\"为了能够让prometheus\",{\"1\":{\"223\":1,\"287\":1}}],[\"为了能够让prometheus关联到servicemonitor\",{\"1\":{\"218\":1}}],[\"为了能够让prometheus能够采集部署在kubernetes下应用的监控数据\",{\"1\":{\"217\":1}}],[\"为了能够让prometheus能够自动的对service进行探测\",{\"1\":{\"203\":1}}],[\"为了能够让prometheus能够获取到当前集群中所有节点的信息\",{\"1\":{\"187\":1}}],[\"为了能够让prometheus能够访问收到认证保护的kubernetes\",{\"1\":{\"186\":1}}],[\"为了能够让prometheus实例使用configmap中管理的配置文件\",{\"1\":{\"175\":1}}],[\"为了能够让prometheus启用定义的告警规则\",{\"1\":{\"66\":1}}],[\"为了能够让alertmanager节点之间进行通讯\",{\"1\":{\"149\":1}}],[\"为了能够更加直观的了解prometheus\",{\"1\":{\"281\":1}}],[\"为了能够更直观的表示样本数据的变化剧烈情况\",{\"1\":{\"238\":1}}],[\"为了能够更直观的了解和使用kubernetes\",{\"1\":{\"181\":1}}],[\"为了能够更好的理解kubernetes下的监控体系\",{\"1\":{\"179\":1,\"183\":1}}],[\"为了能够更好的监控系统的内部运行状态\",{\"1\":{\"115\":1}}],[\"为了能够更有效的表达出度量单位的概念\",{\"1\":{\"138\":1}}],[\"为了能够使singlestat\",{\"1\":{\"131\":1}}],[\"为了能够获取到docker容器的运行状态\",{\"1\":{\"104\":1}}],[\"为了隔离这些不同组织创建的应用程序\",{\"1\":{\"178\":1}}],[\"为了有效的减少不必要的时间序列\",{\"1\":{\"169\":1}}],[\"为了保持prometheus的简单性\",{\"1\":{\"162\":1}}],[\"为了确保数据的安全\",{\"1\":{\"202\":1}}],[\"为了确保数据库的稳定运行\",{\"1\":{\"108\":1}}],[\"为了确保此期间如果prometheus发生崩溃或者重启时能够恢复数据\",{\"1\":{\"159\":1}}],[\"为了确保prometheus服务的可用性\",{\"1\":{\"153\":1}}],[\"为了验证alertmanager的集群行为\",{\"1\":{\"150\":1}}],[\"为了将a1\",{\"1\":{\"149\":1}}],[\"为了提升prometheus的服务可用性\",{\"1\":{\"147\":1}}],[\"为了提升数字的可读性\",{\"1\":{\"144\":1}}],[\"为了适应这方面的需求\",{\"1\":{\"145\":1}}],[\"为了简化这类应用程序的管理复杂度\",{\"1\":{\"220\":1}}],[\"为了简化这些问题prometheus内置了一个简单的解决方案console\",{\"1\":{\"132\":1}}],[\"为了简化测试环境复杂度\",{\"1\":{\"108\":1}}],[\"为了防止出现此类情况\",{\"1\":{\"110\":1}}],[\"为了衡量数据库服务器当前的吞吐量变化情况\",{\"1\":{\"109\":1}}],[\"为了让折线图有更好的可读性\",{\"1\":{\"138\":1}}],[\"为了让table\",{\"1\":{\"77\":1}}],[\"为了让告警信息具有更好的可读性\",{\"1\":{\"67\":1}}],[\"为monitoring\",{\"1\":{\"48\":1}}],[\"添加\",{\"1\":{\"305\":1}}],[\"添加数据源\",{\"1\":{\"283\":1}}],[\"添加如下配置\",{\"1\":{\"280\":1}}],[\"添加到系统环境变量路径即可\",{\"1\":{\"273\":1}}],[\"添加panel\",{\"1\":{\"126\":1}}],[\"添加prometheus作为数据源\",{\"1\":{\"283\":1}}],[\"添加prometheus\",{\"1\":{\"93\":1,\"349\":1}}],[\"添加以下内容\",{\"1\":{\"110\":1}}],[\"添加以下配置\",{\"1\":{\"69\":1}}],[\"添加拦截器\",{\"0\":{\"94\":1},\"1\":{\"94\":1}}],[\"添加依赖\",{\"1\":{\"91\":1}}],[\"添加依赖之后\",{\"1\":{\"86\":1}}],[\"添加成功后slack会显示incoming\",{\"1\":{\"48\":1}}],[\"添加incomming\",{\"1\":{\"48\":1}}],[\"添加应用\",{\"0\":{\"48\":1}}],[\"添加使用blackbox进行黑盒监控\",{\"1\":{\"3\":1}}],[\"协作沟通主要通过channel\",{\"1\":{\"47\":1}}],[\"支持模式\",{\"1\":{\"167\":1}}],[\"支持将数据存储到远端和从远端读取数据\",{\"1\":{\"145\":1}}],[\"支持移动端\",{\"1\":{\"46\":1}}],[\"支持更多可能性\",{\"1\":{\"29\":1}}],[\"与该样本在右边数据中匹配到的样本数据之间\",{\"1\":{\"358\":1}}],[\"与该指标的实际含义一致\",{\"1\":{\"286\":1}}],[\"与replace不同的是\",{\"1\":{\"310\":1}}],[\"与cron\",{\"1\":{\"307\":1}}],[\"与counter不同\",{\"1\":{\"229\":1}}],[\"与console\",{\"1\":{\"133\":1}}],[\"与业务脱离的监控\",{\"1\":{\"290\":1}}],[\"与常见监控系统比较\",{\"0\":{\"290\":1}}],[\"与指标反映的实际含义一致\",{\"1\":{\"286\":1}}],[\"与采集kubelet自身监控指标相似\",{\"1\":{\"200\":1}}],[\"与prometheus集成\",{\"0\":{\"100\":1,\"106\":1,\"306\":1,\"389\":1}}],[\"与pushgateway集成\",{\"0\":{\"91\":1}}],[\"与微信进行集成\",{\"0\":{\"73\":1}}],[\"与告警规则一致\",{\"1\":{\"72\":1}}],[\"与企业微信集成\",{\"0\":{\"51\":1}}],[\"与summary类型的指标相似之处在于histogram类型的样本同样会反应当前指标的记录的总数\",{\"1\":{\"230\":1}}],[\"与smtp邮件集成\",{\"0\":{\"50\":1}}],[\"与slack集成\",{\"0\":{\"46\":1}}],[\"与钉钉集成\",{\"0\":{\"29\":1}}],[\"移动应用消息推送\",{\"1\":{\"43\":1}}],[\"内部状态等\",{\"1\":{\"232\":1}}],[\"内部服务负载均衡\",{\"1\":{\"180\":1}}],[\"内存\",{\"1\":{\"188\":1,\"236\":1,\"285\":1,\"370\":1}}],[\"内存使用量\",{\"1\":{\"104\":1,\"286\":1}}],[\"内存使用率的随时间变化的情况时\",{\"1\":{\"136\":1}}],[\"内存使用率\",{\"1\":{\"95\":1,\"180\":1,\"184\":1}}],[\"内存池\",{\"1\":{\"87\":1}}],[\"内容如下所示\",{\"1\":{\"55\":1}}],[\"内容正在建设中\",{\"1\":{\"6\":1}}],[\"内置告警接收器receiver\",{\"0\":{\"43\":1}}],[\"开放性\",{\"0\":{\"300\":1}}],[\"开头的每一行表示当前node\",{\"1\":{\"267\":1}}],[\"开头的所有行都会被视为是监控样本数据\",{\"1\":{\"116\":1}}],[\"开发\",{\"1\":{\"311\":1}}],[\"开发环境\",{\"1\":{\"292\":1}}],[\"开发人员需要特别注意这些延迟较大的错误\",{\"1\":{\"234\":1}}],[\"开发人员可以非常方便的在应用程序的业务流程中进行监控埋点\",{\"1\":{\"88\":1}}],[\"开发团队就能清楚的知道哪一个环境\",{\"1\":{\"42\":1}}],[\"开始时间\",{\"1\":{\"31\":1}}],[\"报警则会继续进行后续子节点的匹配\",{\"1\":{\"41\":1}}],[\"那\",{\"1\":{\"357\":1}}],[\"那此时prometheus只需要与kubernetes打交道就可以找到所有需要监控的容器以及服务对象\",{\"1\":{\"313\":1}}],[\"那如果需要计算系统cpu的总体使用率\",{\"1\":{\"282\":1}}],[\"那这个表达式是如何工作的呢\",{\"1\":{\"244\":1}}],[\"那只需要将查询到的时间序列的样本值进行单位换算即可\",{\"1\":{\"244\":1}}],[\"那就主要观测磁盘i\",{\"1\":{\"234\":1}}],[\"那就主要关注系统的内存状态\",{\"1\":{\"234\":1}}],[\"那就意味着所有由prometheus产生的告警在发送到alertmanager之后都会通过名为web\",{\"1\":{\"40\":1}}],[\"那在定义servicemonitor对象时\",{\"1\":{\"217\":1}}],[\"那在query\",{\"1\":{\"123\":1}}],[\"那所有历史监控数据都会丢失\",{\"1\":{\"145\":1}}],[\"那一样的读者只需要找到navbar组件的定义即可\",{\"1\":{\"134\":1}}],[\"那问题就来了\",{\"1\":{\"100\":1}}],[\"那用户完全可以通过webhook与钉钉机器人进行集成\",{\"1\":{\"60\":1}}],[\"那直接在email\",{\"1\":{\"50\":1}}],[\"那么graphite可能是一个更好的选择\",{\"1\":{\"327\":1}}],[\"那么我们可以使用\",{\"1\":{\"312\":1}}],[\"那么我们还应该找到相应的pod实例\",{\"1\":{\"184\":1}}],[\"那么我们还应该采集这些pod暴露的监控指标\",{\"1\":{\"180\":1}}],[\"那么如何让不同团队的prometheus\",{\"1\":{\"308\":1}}],[\"那么还有没有更好的方法吗\",{\"1\":{\"239\":1}}],[\"那么就会导致某些web页面的响应时间落到中位数的情况\",{\"1\":{\"230\":1}}],[\"那么secret的管理权限就落到了用户自己手中\",{\"1\":{\"210\":1}}],[\"那么kubernetes会自动根据选择器的去匹配pod实例\",{\"1\":{\"206\":1}}],[\"那么可以使用如下配置\",{\"1\":{\"311\":1}}],[\"那么可以通过以下命令对应用进行回滚\",{\"1\":{\"181\":1}}],[\"那么可视化效果将缺乏一定的可读性\",{\"1\":{\"144\":1}}],[\"那么在bucket范围将2的对数的形式进行分布\",{\"1\":{\"142\":1}}],[\"那么在panel的general选项的repeat中可以选择自动迭代的变量\",{\"1\":{\"131\":1}}],[\"那么prometheus中将包含n\",{\"1\":{\"100\":1}}],[\"那么每个样本的标签则不可能保持一致\",{\"1\":{\"85\":1}}],[\"那么这些告警将会合并为一个通知发送给接收器\",{\"1\":{\"42\":1}}],[\"那么告警在匹配到第一个子节点之后就直接停止\",{\"1\":{\"41\":1}}],[\"那该告警将会基于当前路由节点的接收器配置方式进行处理\",{\"1\":{\"41\":1}}],[\"但实际业务流程依然是失败的\",{\"1\":{\"234\":1}}],[\"但并不是所有的资源对象都是支持promethues的\",{\"1\":{\"187\":1}}],[\"但不幸的是\",{\"1\":{\"147\":1}}],[\"但我们需要的是外网ip\",{\"1\":{\"130\":1}}],[\"但是当将kapacitor和influxdb一起考虑时\",{\"1\":{\"328\":1}}],[\"但是当监控的目标资源以及数据量变得更大的时候\",{\"1\":{\"5\":1}}],[\"但是运行样本已不同的周期进行采集\",{\"1\":{\"326\":1}}],[\"但是如果你想要一个可以长期保存历史数据的集群解决方案\",{\"1\":{\"327\":1}}],[\"但是如果资源不是平滑变化的呢\",{\"1\":{\"239\":1}}],[\"但是如果直接将0或1显示在面板中\",{\"1\":{\"144\":1}}],[\"但是其反应出的是瞬时增长率\",{\"1\":{\"238\":1}}],[\"但是通过计算在时间窗口内的平均增长率却无法反应出该问题\",{\"1\":{\"238\":1}}],[\"但是在不同的场景下这些metric又有一些细微的差异\",{\"1\":{\"227\":1}}],[\"但是prometheus的target中并没包含任何的监控对象\",{\"1\":{\"218\":1}}],[\"但是本地存储也意味着prometheus无法持久化数据\",{\"1\":{\"162\":1}}],[\"但是本地存储也同时限制了prometheus的可扩展性\",{\"1\":{\"152\":1}}],[\"但是希望能够\\b将监控数据持久化\",{\"1\":{\"154\":1}}],[\"但是不解决prometheus\",{\"1\":{\"153\":1}}],[\"但是实现了cap理论中的ap系统\",{\"1\":{\"148\":1}}],[\"但是由于alertmanager之间不存在并不了解彼此的存在\",{\"1\":{\"147\":1}}],[\"但是由于单个alertmanager的存在\",{\"1\":{\"147\":1}}],[\"但是无论是以线图还是柱状图的形式展示\",{\"1\":{\"141\":1}}],[\"但是无论如何\",{\"1\":{\"127\":1}}],[\"但是缺点也很明显\",{\"1\":{\"132\":1}}],[\"但是也仅仅是对prometheus的基本能力的补充\",{\"1\":{\"120\":1}}],[\"但是需要自定义证书的服务\",{\"1\":{\"102\":1,\"317\":1}}],[\"但如果route中设置continue的值为false\",{\"1\":{\"41\":1}}],[\"并对样本数据进行格式化\",{\"1\":{\"350\":1}}],[\"并对外暴露了30000端口\",{\"1\":{\"181\":1}}],[\"并基于它实现一个简单的exporter程序\",{\"1\":{\"348\":1}}],[\"并在该面板的\",{\"1\":{\"283\":1}}],[\"并非为精确值\",{\"1\":{\"240\":1}}],[\"并随后推出了prometheus\",{\"1\":{\"220\":1}}],[\"并使用kubectl命令行工具创建\",{\"1\":{\"217\":1}}],[\"并查看当前集群状态\",{\"1\":{\"214\":1}}],[\"并查看资源的创建情况\",{\"1\":{\"175\":1}}],[\"并创建service对应的endpoint\",{\"1\":{\"206\":1}}],[\"并根据这些pod的访问信息\",{\"1\":{\"206\":1}}],[\"并指向外部的数据库服务实例\",{\"1\":{\"202\":1}}],[\"并指定使用的探针配置文件启动blockbox\",{\"1\":{\"99\":1}}],[\"并重建prometheus的pod实例后\",{\"1\":{\"199\":1}}],[\"并重建prometheus实例\",{\"1\":{\"187\":1}}],[\"并从这些instance上获取监控数据\",{\"1\":{\"280\":1}}],[\"并从这些监控目标中获取数据\",{\"1\":{\"276\":1}}],[\"并从中获取kubernetes集群相关的运行监控指标\",{\"1\":{\"198\":1}}],[\"并从该pod实例中获取其内部运行状态的监控指标\",{\"1\":{\"184\":1}}],[\"并不包含192\",{\"1\":{\"199\":1}}],[\"并不包含endpoint的地址\",{\"1\":{\"192\":1}}],[\"并不适用于kubernetes集群\",{\"1\":{\"190\":1}}],[\"并添加serviceaccount如下所示\",{\"1\":{\"219\":1}}],[\"并添加serviceaccountname和serviceaccount定义\",{\"1\":{\"186\":1}}],[\"并添加以下采集任务配置\",{\"1\":{\"199\":1}}],[\"并添加以下内容\",{\"1\":{\"58\":1,\"307\":1,\"377\":1}}],[\"并写入以下内容\",{\"1\":{\"174\":1,\"175\":1,\"186\":1,\"201\":1,\"205\":1}}],[\"并由一个中心的prometheus\",{\"1\":{\"169\":1}}],[\"并验证数据写入\",{\"1\":{\"167\":1}}],[\"并进入编辑页面\",{\"1\":{\"144\":1}}],[\"并选择heatmap\",{\"1\":{\"141\":1}}],[\"并定义其以点的形式显示在图表中\",{\"1\":{\"138\":1}}],[\"并绘制到图表中\",{\"1\":{\"138\":1}}],[\"并显示相应表达式的查询结果\",{\"1\":{\"135\":1}}],[\"并加入到index\",{\"1\":{\"134\":1}}],[\"并通过web\",{\"1\":{\"290\":1}}],[\"并通过grafana创建一个简单的可视化仪表盘\",{\"1\":{\"281\":1}}],[\"并通过kubectl创建\",{\"1\":{\"217\":1}}],[\"并通过kubectl进行创建\",{\"1\":{\"216\":1}}],[\"并通过以下命令创建\",{\"1\":{\"214\":1}}],[\"并通过适当的relabel过程\",{\"1\":{\"200\":1}}],[\"并通过blackbox\",{\"1\":{\"198\":2}}],[\"并通过relabel进行判断是否为apiserver对应的访问地址\",{\"1\":{\"202\":1}}],[\"并通过relabel自定义采集方式后的结果\",{\"1\":{\"190\":1}}],[\"并通过relabel修改target的数据采集配置\",{\"1\":{\"190\":1}}],[\"并通过标签的形式体现在target对象上\",{\"1\":{\"187\":1}}],[\"并通过正则\\b匹配\",{\"1\":{\"130\":1}}],[\"并通过httpserver将样本数据输出给prometheus\",{\"1\":{\"87\":1}}],[\"并切换到编辑模式\",{\"1\":{\"126\":1}}],[\"并\\b导入到自己的grafana中\",{\"1\":{\"123\":1}}],[\"并确保其值保持在max\",{\"1\":{\"110\":1}}],[\"并执行mysql相关的指令\",{\"1\":{\"108\":1}}],[\"并以图表的形式向用户展示\",{\"1\":{\"105\":1}}],[\"并复写到instance标签中\",{\"1\":{\"100\":1}}],[\"并获取样本数据\",{\"1\":{\"87\":1}}],[\"并调用其collect\",{\"1\":{\"86\":1}}],[\"并直接展示到表格当中\",{\"1\":{\"77\":1}}],[\"并将运算符作用域两个匹配的样本数据中\",{\"1\":{\"358\":1}}],[\"并将符合regex规则的标签从target实例中移除\",{\"1\":{\"310\":1}}],[\"并将prometheus相关的命令\",{\"1\":{\"273\":1}}],[\"并将匹配部分relacement写入到dst\",{\"1\":{\"241\":1}}],[\"并将将匹配到的内容按照$1\",{\"1\":{\"190\":1}}],[\"并将流量转发到对应的服务中\",{\"1\":{\"178\":1}}],[\"并将对service的请求转发到代理的pod中\",{\"1\":{\"178\":1}}],[\"并将数据通过可视化图表的方式进行展示\",{\"1\":{\"118\":1}}],[\"并将所有样本数据转换为prometheus要求的数据输出格式规范\",{\"1\":{\"86\":1}}],[\"并将像告警接收器发送通知\",{\"1\":{\"43\":1}}],[\"并将告警发送到该route定义的receiver中\",{\"1\":{\"41\":1}}],[\"并且采集了prometheus自身的一些运行指标数据\",{\"1\":{\"370\":1}}],[\"并且采集相同的exporter目标即可\",{\"1\":{\"153\":1}}],[\"并且产生一组新的时间序列\",{\"1\":{\"357\":1}}],[\"并且产生一个新的瞬时向量\",{\"1\":{\"357\":1}}],[\"并且转换为summarymetricfamily\",{\"1\":{\"350\":1}}],[\"并且实现collect\",{\"1\":{\"350\":1}}],[\"并且访问http\",{\"1\":{\"349\":1}}],[\"并且访问本机的4194端口\",{\"1\":{\"188\":1}}],[\"并且由各自适用的使用场景\",{\"1\":{\"328\":1}}],[\"并且新的样本数据会在一段时间后覆盖旧的样本数据\",{\"1\":{\"326\":1}}],[\"并且可以快速定位故障\",{\"1\":{\"313\":1}}],[\"并且可以非常方便地在应用程序中进行集成\",{\"1\":{\"298\":1}}],[\"并且该值的范围在1~4之间\",{\"1\":{\"312\":1}}],[\"并且使用了replace\",{\"1\":{\"311\":1}}],[\"并且使用promql表达式从prometheus中查询相应的样本数据\",{\"1\":{\"126\":1}}],[\"并且重写所有从该实例获取的样本中\",{\"1\":{\"310\":1}}],[\"并且重写了标签instance的内容\",{\"1\":{\"203\":1}}],[\"并且声明服务定义文件所在目录\",{\"1\":{\"305\":1}}],[\"并且支持直接以图形化的形式展示数据\",{\"1\":{\"299\":1}}],[\"并且超过120+项的第三方集成\",{\"1\":{\"288\":1}}],[\"并且于2015年早期对外发布早期版本\",{\"1\":{\"288\":1}}],[\"并且点击执行按钮以后\",{\"1\":{\"287\":1}}],[\"并且不存在任何的第三方依赖\",{\"1\":{\"285\":1}}],[\"并且不同类型资源对象的采集方式可能是不同的\",{\"1\":{\"187\":1}}],[\"并且提供了对prometheus的完整支持\",{\"1\":{\"283\":1}}],[\"并且让prometheus\",{\"1\":{\"280\":1}}],[\"并且定时保存到硬盘上\",{\"1\":{\"268\":1}}],[\"并且定义了一个实例为localhost\",{\"1\":{\"377\":1}}],[\"并且定义了三个alertmanager节点\",{\"1\":{\"150\":1}}],[\"并且定义以下的告警处理路由规则来对集群中的异常进行通知\",{\"1\":{\"42\":1}}],[\"并且被广泛应用在prometheus的日常应用当中\",{\"1\":{\"258\":1}}],[\"并且\",{\"1\":{\"247\":1,\"364\":1}}],[\"并且体现出更好的灵敏度\",{\"1\":{\"238\":1}}],[\"并且这个值也近似于主机节点最近两分钟内的平均cpu使用率\",{\"1\":{\"238\":1}}],[\"并且每一个时间序列包含一个额外的标签\",{\"1\":{\"226\":1,\"368\":1}}],[\"并且每一行必须是唯一的指标名称和标签键值对组合\",{\"1\":{\"116\":1}}],[\"并且首先推出了针对在kubernetes下运行和管理etcd的etcd\",{\"1\":{\"220\":1}}],[\"并且backend指向了具体的pod实例\",{\"1\":{\"207\":1}}],[\"并且指向集群外运行的mysql服务\",{\"1\":{\"206\":1}}],[\"并且指定其类型为query\",{\"1\":{\"130\":1}}],[\"并且手段创建该service需要代理的外部服务即可\",{\"1\":{\"206\":1}}],[\"并且kubelet实际上直接内置了对prometheus的支持\",{\"1\":{\"199\":1}}],[\"并且只保留default命名空间下的服务名称为kubernetes的实例作为监控对象\",{\"1\":{\"192\":1}}],[\"并且只需要保存短周期监控数据的场景\",{\"1\":{\"153\":1}}],[\"并且针对不同类型的监控目标设置不同的数据采集方式\",{\"1\":{\"187\":1}}],[\"并且为该账号赋予相应的集群访问权限\",{\"1\":{\"219\":1}}],[\"并且为该角色赋予相应的访问权限\",{\"1\":{\"186\":1}}],[\"并且为其定义了相应的service\",{\"1\":{\"195\":1}}],[\"并且为每一个实例设置了告警规则\",{\"1\":{\"62\":1}}],[\"并且对数据进行了聚合以及可视化\",{\"1\":{\"271\":1}}],[\"并且对集群资源进行统一的调度和管理\",{\"1\":{\"183\":1}}],[\"并且对外提供一个\",{\"1\":{\"178\":1,\"180\":1}}],[\"并且对应一个或者多个通知方式\",{\"1\":{\"43\":1}}],[\"并且利用minikube在本地搭建了一个单节点的kubernetes\",{\"1\":{\"173\":1}}],[\"并且相继从cncf基金会正式毕业\",{\"1\":{\"172\":1}}],[\"并且从0开始利用prometheus构建一个完整的kubernetes集群监控系统\",{\"1\":{\"171\":1}}],[\"并且保存在$gopath\",{\"1\":{\"167\":1}}],[\"并且按照bucket对数据进行重新排序\",{\"1\":{\"141\":1}}],[\"并且按照提示填写机器人名称\",{\"1\":{\"30\":1}}],[\"并且我们已经学习了如何通过promql对时间序列数据进行查询和分析\",{\"1\":{\"132\":1}}],[\"并且以匹配到的内容为新的标签名称\",{\"1\":{\"310\":1}}],[\"并且以\\b颜色的深浅来表示当前区间内样本个数的大小\",{\"1\":{\"141\":1}}],[\"并且以可视化的方式展现\",{\"1\":{\"126\":1}}],[\"并且以yaml配置文件的形式提供给blackbox\",{\"1\":{\"99\":1}}],[\"并且其支持的可视化图表类型也非常有限\",{\"1\":{\"120\":1}}],[\"并且其样本值必须和x\",{\"1\":{\"116\":1}}],[\"并且探针返回的指标probe\",{\"1\":{\"103\":1,\"318\":1}}],[\"并且验证返回状态码是否为2xx\",{\"1\":{\"101\":1,\"316\":1}}],[\"并且直接将任务的采集目标定义为我们需要探测的站点\",{\"1\":{\"100\":1}}],[\"并且存储在数据库当中\",{\"1\":{\"82\":1}}],[\"并且将相应的指标样本返回给prometheus\",{\"1\":{\"352\":1}}],[\"并且将相关信息聚合在一起\",{\"1\":{\"47\":1}}],[\"并且将匹配到的值写入到target\",{\"1\":{\"310\":1}}],[\"并且将通过服务发现获取到的service实例地址\",{\"1\":{\"203\":1}}],[\"并且将其转换为prometheus的target对象\",{\"1\":{\"189\":1}}],[\"并且将其作为target对象进行数据采集\",{\"1\":{\"187\":1}}],[\"并且将其可视化\",{\"1\":{\"123\":1}}],[\"并且将所有高于该阈值的区域显示为warining状态\",{\"1\":{\"138\":1}}],[\"并且将计算结果保存到新的时间序列record中\",{\"1\":{\"72\":1}}],[\"并且尝试实现了对主机cpu以及内存的告警规则设置\",{\"1\":{\"70\":1}}],[\"并且根据这些资源的定义自动化的完成如prometheus\",{\"1\":{\"221\":1}}],[\"并且根据这些规则计算是否向外部发送通知\",{\"1\":{\"66\":1}}],[\"并且根据不同的使用场景介绍了一种常见的高可用方案\",{\"1\":{\"152\":1}}],[\"并且根据alert中定义的threshold在图形中显示阈值内容\",{\"1\":{\"138\":1}}],[\"并且根据子路由设置的接收器发送告警\",{\"1\":{\"55\":1}}],[\"并且没有第三方依赖\",{\"1\":{\"52\":1}}],[\"并且在data节点中返回查询结果\",{\"1\":{\"256\":1}}],[\"并且在dashboard中每一个panel是一个完全独立的部分\",{\"1\":{\"123\":1}}],[\"并且在发生故障时能够即使的做出响应\",{\"1\":{\"194\":1}}],[\"并且在不同的organization下\",{\"1\":{\"124\":1}}],[\"并且在合理的时间扩大缓冲池的大小可以优化数据库的性能\",{\"1\":{\"111\":1}}],[\"并且在最后在spring\",{\"1\":{\"97\":1}}],[\"并且在receiver中定义接收方的邮件地址即可\",{\"1\":{\"50\":1}}],[\"并且在文中应该对图进行一点说明\",{\"1\":{\"4\":1}}],[\"并且通过配置指向中心的nagios服务\",{\"1\":{\"313\":1}}],[\"并且通过实现自定义controller来实现对kubernetes的扩展\",{\"1\":{\"221\":1}}],[\"并且通过service暴露应用访问信息\",{\"1\":{\"217\":1}}],[\"并且通过以下命令创建名为alrtmanager\",{\"1\":{\"214\":1}}],[\"并且通过在prometheus配置中声明式的加载\",{\"1\":{\"213\":1}}],[\"并且通过kubectl命令创建相应的资源\",{\"1\":{\"213\":1}}],[\"并且通过kubectl创建相应资源\",{\"1\":{\"219\":1}}],[\"并且通过kubectl创建\",{\"1\":{\"210\":1}}],[\"并且通过kubernetes\",{\"1\":{\"198\":1}}],[\"并且通过volumemounts将该磁盘卷挂载到了prometheus实例的\",{\"1\":{\"175\":1}}],[\"并且通过环境变量或者文件系统挂载的方式让容器使用这些配置\",{\"1\":{\"174\":1}}],[\"并且通过当前数据中心的一个中心prometheus\",{\"1\":{\"156\":1}}],[\"并且通过一个统一的中心节点进行聚合\",{\"1\":{\"145\":1}}],[\"并且通过\\b\\baxes选项\\b中选择data\",{\"1\":{\"142\":1}}],[\"并且通过prometheus自动监控集群中所有节点资源使用情况\",{\"1\":{\"204\":1}}],[\"并且通过prometheus\",{\"1\":{\"132\":1}}],[\"并且通过prometheus中的graph面板查询数据形成图表\",{\"1\":{\"132\":1}}],[\"并且通过prometheus构建我们的容器云监控系统\",{\"1\":{\"5\":1}}],[\"并且通过params指定使用的探针\",{\"1\":{\"100\":1}}],[\"并且通过name\",{\"1\":{\"95\":1}}],[\"并且通过route将所有告警信息发送到default\",{\"1\":{\"50\":1}}],[\"并且通过channel来集成各种第三方工具\",{\"1\":{\"47\":1}}],[\"并且team的值为frontend\",{\"1\":{\"42\":1}}],[\"并且service为mysql或者cassandra\",{\"1\":{\"42\":1}}],[\"并且告警中标签node的值与nodedown告警的相同\",{\"1\":{\"36\":1}}],[\"并且已发送的告警与新产生的告警中equal定义的标签完全相同\",{\"1\":{\"36\":1}}],[\"并且介绍如何通过prometheus与kubernetes结合实现应用程序的弹性伸缩\",{\"1\":{\"5\":1}}],[\"并且了解grafana作为一个通用的可视化工具是如何与prometheus进行配合的\",{\"1\":{\"5\":1}}],[\"并且能够使用prometheus来完成一些基本的日常任务\",{\"1\":{\"5\":1}}],[\"并且基于监控数据实现应用的auto\",{\"1\":{\"1\":1}}],[\"路由器\",{\"1\":{\"232\":1}}],[\"路由是一个基于标签匹配规则的树状结构\",{\"1\":{\"55\":1}}],[\"路由是一个基于标签匹配的树状匹配结构\",{\"1\":{\"26\":1}}],[\"路由\",{\"1\":{\"55\":1}}],[\"路由匹配\",{\"0\":{\"41\":1}}],[\"临时调整最大连接数\",{\"1\":{\"110\":1}}],[\"临时屏蔽告警通知\",{\"0\":{\"39\":1}}],[\"临时静默\",{\"0\":{\"37\":1}}],[\"活动的静默规则\",{\"1\":{\"37\":1,\"39\":1}}],[\"填写当前静默规则的创建者以及创建原因后\",{\"1\":{\"37\":1,\"39\":1}}],[\"则为异常\",{\"1\":{\"287\":1}}],[\"则不会出现在运算结果中\",{\"1\":{\"358\":1}}],[\"则不合法\",{\"1\":{\"266\":1}}],[\"则不停止向receiver发送通知\",{\"1\":{\"39\":1}}],[\"则必须使用bool修饰符\",{\"1\":{\"246\":1}}],[\"则直接丢弃\",{\"1\":{\"244\":1,\"245\":1,\"249\":1,\"365\":1}}],[\"则可能需要直接从服务中添加钩子统计并进行获取\",{\"1\":{\"234\":1}}],[\"则可以排除这些时间序列\",{\"1\":{\"259\":1}}],[\"则可以直接声明一个servicemonitor对象\",{\"1\":{\"217\":1}}],[\"则可以直接定义全局的smtp配置\",{\"1\":{\"50\":1}}],[\"则可以启用spark\",{\"1\":{\"144\":1}}],[\"则可以定义thresholds与colors的映射\\b关系\",{\"1\":{\"144\":1}}],[\"则可以控制grafana自身渲染的数据量\",{\"1\":{\"126\":1}}],[\"则可以使用$\",{\"1\":{\"310\":1}}],[\"则可以使用如下表达式\",{\"1\":{\"259\":1}}],[\"则可以使用fail\",{\"1\":{\"103\":1,\"318\":1}}],[\"则可以使用gauge构造器的labelnames\",{\"1\":{\"89\":1}}],[\"则可以通过series\",{\"1\":{\"138\":1}}],[\"则可以通过evaluation\",{\"1\":{\"66\":1}}],[\"则可以通过repeat\",{\"1\":{\"41\":1}}],[\"则可以接收到如下通知\",{\"1\":{\"49\":1}}],[\"则通过以下方式定义\",{\"1\":{\"217\":1}}],[\"则适用于作为服务可用性的探测标准\",{\"1\":{\"207\":1}}],[\"则主要需要关注以下\",{\"1\":{\"180\":1}}],[\"则需要使用到ingress\",{\"1\":{\"194\":1}}],[\"则需要使用到控制器\",{\"1\":{\"178\":1}}],[\"则需要通过修改mysql配置文件my\",{\"1\":{\"110\":1}}],[\"则当value的值落到不同的范围内时\",{\"1\":{\"144\":1}}],[\"则反映出当前时间点\",{\"1\":{\"141\":1}}],[\"则表示探测成功\",{\"1\":{\"103\":1,\"318\":1}}],[\"则会丢弃那些source\",{\"1\":{\"311\":1}}],[\"则会看到以下结果\",{\"1\":{\"287\":1}}],[\"则会产生一条告警\",{\"1\":{\"278\":1}}],[\"则会直接返回字符串\",{\"1\":{\"265\":1}}],[\"则会在自己的数据库中保存该通知已发送的记录\",{\"1\":{\"148\":1}}],[\"则会自动从collector的collection\",{\"1\":{\"96\":1}}],[\"则会实际触发告警并且告警状态为firing\",{\"1\":{\"69\":1}}],[\"则向database\",{\"1\":{\"42\":1}}],[\"则用于定义相同的group之间发送告警通知的时间间隔\",{\"1\":{\"42\":1}}],[\"则停止向receiver发送通知\",{\"1\":{\"37\":1}}],[\"则说明新的告警是由nodedown导致的\",{\"1\":{\"36\":1}}],[\"则启动抑制机制停止向接收器发送通知\",{\"1\":{\"36\":1}}],[\"则启动抑制机制\",{\"1\":{\"36\":1}}],[\"该配置会使用regex匹配当前target实例的所有标签\",{\"1\":{\"310\":1}}],[\"该配置会直接将promql查询到的所有样本格式化为grafana的table数据结构\",{\"1\":{\"77\":1}}],[\"该采集任务通过consul动态发现node\",{\"1\":{\"310\":1}}],[\"该标签的内容对应到target实例的\",{\"1\":{\"309\":1}}],[\"该服务器称为监控中心\",{\"1\":{\"290\":1}}],[\"该向量包含vector1中所有的\\b样本数据\",{\"1\":{\"247\":1,\"364\":1}}],[\"该向量包含vector1中完全匹配vector2中的元素组成\",{\"1\":{\"247\":1,\"364\":1}}],[\"该表达式会过滤监控指标http\",{\"1\":{\"360\":1}}],[\"该表达式会返回指标名称为http\",{\"1\":{\"259\":1}}],[\"该表达式会返回在过去5分钟内\",{\"1\":{\"250\":1,\"366\":1}}],[\"该表达式会返回当前prometheus中存储的所有时间序列\",{\"1\":{\"127\":1}}],[\"该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据\",{\"1\":{\"260\":1}}],[\"该表达式中\",{\"1\":{\"251\":1,\"367\":1}}],[\"该表达式返回结果的示例如下所示\",{\"1\":{\"244\":1}}],[\"该账号并没有权限能够获取default命名空间下的任何资源信息\",{\"1\":{\"219\":1}}],[\"该任务基于endpoints模式获取当前集群中的所有endpoints\",{\"1\":{\"192\":1}}],[\"该任务将基于node模式发现集群中所有的节点\",{\"1\":{\"190\":1}}],[\"该service实际指向的是kubernetes组件apiserver提供的服务\",{\"1\":{\"192\":1}}],[\"该节点各种类型\",{\"1\":{\"189\":1}}],[\"该节点中包含的kubernetes自动生成的注解信息\",{\"1\":{\"189\":1}}],[\"该节点中包含的用户自定义标签以及kubernetes自动生成的标签\",{\"1\":{\"189\":1}}],[\"该节点在集群中的名称\",{\"1\":{\"189\":1}}],[\"该deployment将会在默认的命令空间default中创建\",{\"1\":{\"181\":1}}],[\"该文件中分别定义了service和deployment\",{\"1\":{\"175\":1}}],[\"该方案适用于用户监控规模不大\",{\"1\":{\"154\":1}}],[\"该选项表示heatmap\",{\"1\":{\"141\":1}}],[\"该选项默认指向consoles\",{\"1\":{\"133\":1}}],[\"该监控指标记录了prometheus进行数据压缩任务的运行耗时的分布统计情况\",{\"1\":{\"139\":1}}],[\"该监控指标的所有样本数据均转换为一个metricfamilysamples\",{\"1\":{\"85\":1}}],[\"该promql会返回多条时间序列\",{\"1\":{\"138\":1}}],[\"该函数可以将时间序列中v多个标签src\",{\"1\":{\"241\":1}}],[\"该函数会依次对v中的每一条时间序列进行处理\",{\"1\":{\"241\":1}}],[\"该函数还支持的完整参数如下\",{\"1\":{\"135\":1}}],[\"该函数通过head加载相应的js源码\",{\"1\":{\"135\":1}}],[\"该变量代表时间跨度\",{\"1\":{\"129\":1}}],[\"该指标所有样本的总数需要使用一个单独的x\",{\"1\":{\"116\":1}}],[\"该指标所有样本的值的总和需要使用一个单独的x\",{\"1\":{\"116\":1}}],[\"该探针将使用http\",{\"1\":{\"101\":1,\"316\":1}}],[\"该exporter会在metrics\",{\"1\":{\"93\":1}}],[\"该模块中内置了对jvm虚拟机运行状态\",{\"1\":{\"87\":1}}],[\"该实例中包含了该样本的指标名称\",{\"1\":{\"85\":1}}],[\"该收集器需要实现collect\",{\"1\":{\"85\":1}}],[\"该程序对外暴露了一个用于获取当前监控样本数据的http访问地址\",{\"1\":{\"82\":1}}],[\"该主机上部署的所有服务\",{\"1\":{\"36\":1}}],[\"该参数的定义可能会影响到告警恢复通知的接收时间\",{\"1\":{\"26\":1}}],[\"该参数定义了当alertmanager持续多长时间未接收到告警后标记告警状态为resolved\",{\"1\":{\"26\":1}}],[\"中的实现代码\",{\"1\":{\"350\":1}}],[\"中的哪一个应用程序出现了问题\",{\"1\":{\"42\":1}}],[\"中间代理人\",{\"1\":{\"185\":1}}],[\"中间件等等各种各样的服务\",{\"1\":{\"313\":1}}],[\"中间件状态\",{\"1\":{\"232\":1}}],[\"中间件以及网络等各个方面的监控功能\",{\"1\":{\"114\":1}}],[\"中间件会不可用并触发报警\",{\"1\":{\"36\":1}}],[\"中间件服务异常的告警通知\",{\"1\":{\"36\":1}}],[\"中心prometheus\",{\"1\":{\"155\":1}}],[\"中需要通过scale定义bucket桶的分布范围\",{\"1\":{\"142\":1}}],[\"中查询出相应的监控数据\",{\"1\":{\"126\":1}}],[\"中我们已经尝试通过grafana快速搭建过一个主机监控的dashboard\",{\"1\":{\"120\":1}}],[\"中\",{\"1\":{\"68\":1,\"159\":1,\"227\":1}}],[\"中添加grafana可视化内容\",{\"1\":{\"3\":1}}],[\"而on则用于将匹配行为限定在某些便签之内\",{\"1\":{\"366\":1}}],[\"而on则用于将匹配行为限定在某些标签之内\",{\"1\":{\"250\":1}}],[\"而register\",{\"1\":{\"350\":1}}],[\"而其他监控相关的问题都需要由外部组件来解决\",{\"1\":{\"324\":1}}],[\"而其有包含了一些自身特有的运维管理和配置管理方式\",{\"1\":{\"220\":1}}],[\"而drop用于排除\",{\"1\":{\"311\":1}}],[\"而不同职能\",{\"1\":{\"311\":1}}],[\"而不是大量的如集群中的应用异常\",{\"1\":{\"36\":1}}],[\"而本节开头还提到过第二个问题\",{\"1\":{\"311\":1}}],[\"而使用labelkeep或者labeldrop则可以对target标签进行过滤\",{\"1\":{\"310\":1}}],[\"而作为下一代监控系统的首选解决方案\",{\"1\":{\"302\":1}}],[\"而作为用户\",{\"1\":{\"62\":1}}],[\"而且过程并不简单\",{\"1\":{\"290\":1}}],[\"而且首字母的大小写要一致\",{\"1\":{\"4\":1}}],[\"而监控系统却只能根据系统负载去产生告警\",{\"1\":{\"290\":1}}],[\"而黑盒监控\",{\"1\":{\"289\":1}}],[\"而一组用于相同采集目的的实例\",{\"1\":{\"280\":1}}],[\"而一旦在生产环境中大量基于kubernetes部署和管理应用程序后\",{\"1\":{\"180\":1,\"182\":1}}],[\"而告警的后续处理流程则由alertmanager进行管理\",{\"1\":{\"278\":1}}],[\"而如下表达式\",{\"1\":{\"266\":1}}],[\"而如果我们想查询\",{\"1\":{\"261\":1}}],[\"而如果我们想过去一段时间范围内的样本数据时\",{\"1\":{\"260\":1}}],[\"而如果是瞬时向量与瞬时向量之间进行数学运算时\",{\"1\":{\"244\":1}}],[\"而如果应用实例的数量更多时\",{\"1\":{\"220\":1}}],[\"而如果prometheus定义中不包含任何与配置相关的定义\",{\"1\":{\"210\":1}}],[\"而如果\",{\"1\":{\"194\":1}}],[\"而如果还希望能够自动生成row\",{\"1\":{\"131\":1}}],[\"而如果用户对于http服务是否启用ssl有强制的标准\",{\"1\":{\"103\":1,\"318\":1}}],[\"而如果所有样本的是一致的情况下\",{\"1\":{\"85\":1}}],[\"而相应的这样的表达式称之为\",{\"1\":{\"260\":1}}],[\"而label则在这个基本特征上为采集到的数据提供了多种特征维度\",{\"1\":{\"258\":1}}],[\"而右向量method\",{\"1\":{\"251\":1,\"367\":1}}],[\"而是一个个能够表达出正式业务含义的语言\",{\"1\":{\"282\":1}}],[\"而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1\",{\"1\":{\"246\":1,\"361\":1}}],[\"而是通过http\",{\"1\":{\"240\":1}}],[\"而是通过定义两个标准接口\",{\"1\":{\"162\":1}}],[\"而系统管理员在排查问题的时候可能只想知道当前内存使用率超过95\",{\"1\":{\"245\":1}}],[\"而布尔运算则支持用户根据时间序列中样本的值\",{\"1\":{\"245\":1}}],[\"而返回的结果成为瞬时向量\",{\"1\":{\"244\":1}}],[\"而histogram的分位数计算需要通过histogram\",{\"1\":{\"240\":1}}],[\"而histogram则会消耗更多的资源\",{\"1\":{\"95\":1,\"230\":1}}],[\"而对于没有内置prometheus支持的监控需求\",{\"1\":{\"370\":1}}],[\"而对于prometheus而言其解决方案就是引入一个中间的代理人\",{\"1\":{\"313\":1}}],[\"而对于prometheus这一类基于pull模式的监控系统\",{\"1\":{\"313\":1}}],[\"而对于prometheus来说\",{\"1\":{\"300\":1}}],[\"而对于一些系统内部的异常\",{\"1\":{\"234\":1}}],[\"而对于第二个问题\",{\"1\":{\"178\":1}}],[\"而个别请求的响应时间需要5s\",{\"1\":{\"230\":1}}],[\"而指标node\",{\"1\":{\"227\":1}}],[\"而time\",{\"1\":{\"227\":1}}],[\"而保留其它标签\",{\"1\":{\"226\":1,\"368\":1}}],[\"而默认的bundle\",{\"1\":{\"223\":1}}],[\"而除了这些原生的resource资源以外\",{\"1\":{\"221\":1}}],[\"而除了数据持久化问题以外\",{\"1\":{\"152\":1}}],[\"而非通过prometheus\",{\"1\":{\"210\":1}}],[\"而哪些是不可以采集的\",{\"1\":{\"207\":1}}],[\"而该kubernetes服务代理的后端实际地址通过endpoints进行维护\",{\"1\":{\"202\":1}}],[\"而有些是隐式\",{\"1\":{\"234\":1}}],[\"而有些情况下\",{\"1\":{\"201\":1}}],[\"而有些则可能是一些基于rest的api服务\",{\"1\":{\"102\":1,\"317\":1}}],[\"而与prometheus的部署不同的是\",{\"1\":{\"201\":1,\"205\":1}}],[\"而通过kubernetes的api\",{\"1\":{\"199\":1}}],[\"而这种现象被称为长尾问题\",{\"1\":{\"230\":1}}],[\"而这些都无法通过kubernetes原生提供的应用管理概念实现自动化\",{\"1\":{\"220\":1}}],[\"而这些target的访问地址实际上就是kubelet的访问地址\",{\"1\":{\"199\":1}}],[\"而这个过程主要由kube\",{\"1\":{\"180\":1,\"184\":1}}],[\"而kubernetes直接在kubelet组件中集成了cadvisor\",{\"1\":{\"188\":1}}],[\"而kubelet完成pod的创建和启动工作\",{\"1\":{\"180\":1,\"184\":1}}],[\"而创建service\",{\"1\":{\"178\":1}}],[\"而用户则可以在适配器中对接外部任意的服务\",{\"1\":{\"163\":1}}],[\"而webhook服务只接收到来自alertmanager集群的一条告警通知\",{\"1\":{\"151\":1}}],[\"而prometheus中\",{\"1\":{\"325\":1}}],[\"而prometheus则根据consul返回的node\",{\"1\":{\"308\":1}}],[\"而prometheus可以高效地处理这些数据\",{\"1\":{\"296\":1}}],[\"而prometheus\",{\"1\":{\"279\":1}}],[\"而promql提供的聚合操作可以用来对这些时间序列进行处理\",{\"1\":{\"262\":1}}],[\"而pod实例可能随机运行在任意节点上\",{\"1\":{\"201\":1,\"205\":1}}],[\"而pull\",{\"1\":{\"148\":1}}],[\"而panel则会负责从特定的prometheus中查询出\\b相应的数据\",{\"1\":{\"123\":1}}],[\"而接下来\",{\"1\":{\"147\":1}}],[\"而实际情况下\",{\"1\":{\"144\":1}}],[\"而实际的应用场景中往往不同的人对于可视化的需求不一样\",{\"1\":{\"118\":1}}],[\"而图形的高度\",{\"1\":{\"141\":1}}],[\"而避免从prometheus或exporter中修改采集指标\",{\"1\":{\"130\":1}}],[\"而能和prometheus一起工作的主要包含以下5种类型\",{\"1\":{\"129\":1}}],[\"而当action设置为drop时\",{\"1\":{\"311\":1}}],[\"而当用户只想关注其中某些主机时\",{\"1\":{\"127\":1}}],[\"而当告警项恢复正常后\",{\"1\":{\"49\":1}}],[\"而sumamry的分位数则是直接在客户端计算完成\",{\"1\":{\"230\":1}}],[\"而sumamry的分位数则是直接在客户端进行定义\",{\"1\":{\"95\":1}}],[\"而service作为负载均衡器\",{\"1\":{\"207\":1}}],[\"而serviceaccount是属于特定命名空间的资源\",{\"1\":{\"186\":1}}],[\"而siglestat则必须要求查询结果为单个样本\",{\"1\":{\"126\":1}}],[\"而exporter的一个实例称为target\",{\"1\":{\"113\":1}}],[\"而白盒监控则侧重于主动发现或者预测潜在的问题\",{\"1\":{\"98\":1}}],[\"而从完整的监控逻辑的角度\",{\"1\":{\"98\":1}}],[\"而在大多数场景下引入监控系统通常还需要构建可以长期使用的监控数据可视化面板\",{\"1\":{\"283\":1}}],[\"而在其它的情况下我们可能需要的是真正的布尔结果\",{\"1\":{\"246\":1,\"361\":1}}],[\"而在prometheus\",{\"1\":{\"213\":1,\"217\":1}}],[\"而在prometheus中histogram类型的监控指标其实是已经自带了分布的bucket信息的\",{\"1\":{\"141\":1}}],[\"而在一些特殊的情况下\",{\"1\":{\"210\":1}}],[\"而在kubernetes下prometheus就是需要与kubernetes的api进行交互\",{\"1\":{\"185\":1}}],[\"而在kubernetes中运行着的容器则可以视为是这个操作系统中运行的\",{\"1\":{\"177\":1}}],[\"而在黑盒监控层面\",{\"1\":{\"180\":1}}],[\"而在多主机的情况下\",{\"1\":{\"105\":1}}],[\"而在启动之前\",{\"1\":{\"86\":1}}],[\"而在某些promql较为复杂且计算量较大时\",{\"1\":{\"71\":1}}],[\"而所有监控数据的产生则是由exporter来进行实现\",{\"1\":{\"83\":1}}],[\"而将这些告警内聚在一起成为一个通知\",{\"1\":{\"62\":1}}],[\"而无法对问题进行快速定位\",{\"1\":{\"62\":1}}],[\"而alertmanager负责告警产生后的后续处理\",{\"1\":{\"58\":1}}],[\"而某些告警规则可能来源于开发团队的定义\",{\"1\":{\"42\":1}}],[\"而group\",{\"1\":{\"42\":1}}],[\"告诉他这时候集群出现了问题\",{\"1\":{\"36\":1}}],[\"告警处理当中\",{\"1\":{\"258\":1}}],[\"告警处理可不是这么简单的一件事情\",{\"1\":{\"40\":1}}],[\"告警通知发送完成后\",{\"1\":{\"148\":1}}],[\"告警发送完成后该alertmanager进入最后一个阶段gossip\",{\"1\":{\"148\":1}}],[\"告警的后续所有业务全部失效\",{\"1\":{\"147\":1}}],[\"告警活动状态\",{\"1\":{\"68\":1,\"69\":1}}],[\"告警组\",{\"1\":{\"60\":1}}],[\"告警名称\",{\"1\":{\"60\":1}}],[\"告警规则创建成功后\",{\"1\":{\"213\":1}}],[\"告警规则也编程一个通过kubernetes\",{\"1\":{\"213\":1}}],[\"告警规则的名称\",{\"1\":{\"66\":1}}],[\"告警规则实际上主要由promql进行定义\",{\"1\":{\"60\":1}}],[\"告警规则\",{\"1\":{\"60\":2,\"69\":1}}],[\"告警能力在prometheus的架构中被划分成两个独立的部分\",{\"1\":{\"60\":1}}],[\"告警详情\",{\"1\":{\"51\":2}}],[\"告警级别\",{\"1\":{\"51\":2}}],[\"告警类型\",{\"1\":{\"51\":2}}],[\"告警\",{\"1\":{\"50\":1,\"51\":1,\"138\":1,\"289\":1}}],[\"告警恢复信息\",{\"1\":{\"49\":1}}],[\"告警接收器可以通过以下形式进行配置\",{\"1\":{\"43\":1}}],[\"告警分组\",{\"0\":{\"42\":1},\"1\":{\"62\":1}}],[\"告警进入到顶级route后会遍历所有的子节点\",{\"1\":{\"41\":1}}],[\"告警信息\",{\"1\":{\"37\":1,\"39\":1,\"49\":1}}],[\"告警项\",{\"1\":{\"31\":1}}],[\"告警时间\",{\"1\":{\"30\":2,\"62\":1}}],[\"告警路由\",{\"1\":{\"26\":1}}],[\"告警模板详解\",{\"1\":{\"8\":1,\"20\":1}}],[\"抑制是指当某一告警发出后\",{\"1\":{\"63\":1}}],[\"抑制\",{\"0\":{\"63\":1}}],[\"抑制以及静默等告警特性\",{\"1\":{\"61\":1}}],[\"抑制机制同样通过alertmanager的配置文件进行设置\",{\"1\":{\"63\":1}}],[\"抑制机制\",{\"0\":{\"36\":1}}],[\"抑制规则\",{\"1\":{\"26\":1}}],[\"重点是要区分成功请求的延迟时间和失败请求的延迟时间\",{\"1\":{\"234\":1}}],[\"重点将放在告警处理也就是alertmanager部分\",{\"1\":{\"147\":1}}],[\"重建prometheus实例\",{\"1\":{\"202\":1}}],[\"重新启动consul服务\",{\"1\":{\"305\":1}}],[\"重新启动prometheus\",{\"1\":{\"287\":1,\"377\":1}}],[\"重新启动prometheus能够获取数据后\",{\"1\":{\"167\":1}}],[\"重新加载配置文件\",{\"1\":{\"202\":1}}],[\"重新加载promethues配置文件\",{\"1\":{\"199\":1}}],[\"重新运行customexporter\",{\"1\":{\"87\":1}}],[\"重量\",{\"1\":{\"138\":1}}],[\"重启prometheus后访问prometheus\",{\"1\":{\"69\":1}}],[\"重启prometheus服务\",{\"1\":{\"58\":1}}],[\"重启alertmanager服务后\",{\"1\":{\"34\":1}}],[\"重构第2章\",{\"1\":{\"3\":3}}],[\"重构第1章\",{\"1\":{\"3\":1}}],[\"修改等\",{\"1\":{\"305\":1}}],[\"修改本地数据存储的路径\",{\"1\":{\"273\":1}}],[\"修改监控配置项也是prometheus下常用的运维操作之一\",{\"1\":{\"217\":1}}],[\"修改监控采集任务的配置\",{\"1\":{\"200\":1}}],[\"修改名为prometheus\",{\"1\":{\"210\":1}}],[\"修改kubernetes\",{\"1\":{\"190\":1}}],[\"修改prometheus\",{\"1\":{\"167\":1,\"186\":1,\"190\":1,\"192\":1,\"199\":1,\"218\":2,\"219\":1}}],[\"修改prometheus配置文件\",{\"1\":{\"108\":1}}],[\"修改prometheus配置文件prometheus\",{\"1\":{\"69\":1}}],[\"修改后的图标显示效果如下\",{\"1\":{\"138\":1}}],[\"修改后刷新页面\",{\"1\":{\"134\":1}}],[\"修改\",{\"1\":{\"106\":1}}],[\"修改alertmanager配置文件\",{\"1\":{\"34\":1}}],[\"修改feedback反馈的内容\",{\"1\":{\"3\":1}}],[\"扩展启动函数\",{\"0\":{\"33\":1}}],[\"创建用户\",{\"0\":{\"372\":1}}],[\"创建用于接收remote\",{\"1\":{\"166\":1}}],[\"创建配置目录\",{\"1\":{\"305\":1}}],[\"创建dashboard\",{\"1\":{\"283\":1}}],[\"创建dingtalk通知发送包\",{\"0\":{\"32\":1}}],[\"创建服务mysql\",{\"1\":{\"206\":1}}],[\"创建blackbox\",{\"1\":{\"203\":1}}],[\"创建监控任务kubernetes\",{\"1\":{\"202\":1}}],[\"创建node\",{\"0\":{\"374\":1},\"1\":{\"201\":1,\"205\":1}}],[\"创建并查看service资源\",{\"1\":{\"181\":1}}],[\"创建了一个名为nginx\",{\"1\":{\"181\":1}}],[\"创建两个prometheus节点\",{\"1\":{\"151\":1}}],[\"创建prometheus配置文件\",{\"1\":{\"307\":1}}],[\"创建prometheus实例\",{\"0\":{\"216\":1}}],[\"创建prometheus\",{\"1\":{\"151\":1,\"174\":1,\"175\":1}}],[\"创建prometheus集群配置文件\",{\"1\":{\"151\":1}}],[\"创建panel之后\",{\"1\":{\"126\":1}}],[\"创建alertmanager\",{\"1\":{\"150\":1}}],[\"创建alertmanager集群\",{\"0\":{\"150\":1}}],[\"创建alertmanager配置文件\",{\"0\":{\"55\":1},\"1\":{\"150\":1}}],[\"创建我们的第一个console\",{\"1\":{\"133\":1}}],[\"创建metrics指标\",{\"1\":{\"96\":1}}],[\"创建counter类型的监控指标\",{\"1\":{\"95\":1}}],[\"创建channel\",{\"1\":{\"47\":1}}],[\"创建静默规则\",{\"1\":{\"37\":1,\"39\":1}}],[\"创建告警通知对应的结构体notification\",{\"1\":{\"28\":1}}],[\"通讯量\",{\"1\":{\"234\":2}}],[\"通知发送状态同步\",{\"1\":{\"148\":1}}],[\"通知流水线\",{\"1\":{\"148\":1}}],[\"通知组\",{\"1\":{\"31\":2}}],[\"通用设置\",{\"1\":{\"126\":1}}],[\"通用\",{\"1\":{\"121\":1}}],[\"通常来说当我们需要监控一个应用程序时\",{\"1\":{\"300\":1}}],[\"通常来说从内存中读取数据的速度要比从磁盘中读取快很多\",{\"1\":{\"111\":1}}],[\"通常是\",{\"1\":{\"285\":1}}],[\"通常需要使用\",{\"1\":{\"150\":1}}],[\"通常用户会部署两个或者两个以上的promthus\",{\"1\":{\"147\":1}}],[\"通常会关注一下四个与性能和资源利用率相关的指标\",{\"1\":{\"108\":1}}],[\"通过quantile\",{\"1\":{\"352\":1}}],[\"通过构造histogram可以记录某个方法的处理时间在buckets上的分布情况\",{\"1\":{\"352\":1}}],[\"通过添加自定义的collector\",{\"1\":{\"351\":1}}],[\"通过添加注解自定义采集数据的相关配置\",{\"1\":{\"207\":1}}],[\"通过从collectorregistry\",{\"1\":{\"350\":1}}],[\"通过从target实例中获取\",{\"1\":{\"310\":1}}],[\"通过基于文件的服务发现方式下\",{\"1\":{\"307\":1}}],[\"通过可视化仪表盘能够直接获取系统的运行状态\",{\"1\":{\"289\":1}}],[\"通过可视化的方式直观的在图表中显示一些可能出现异常的区域\",{\"1\":{\"138\":1}}],[\"通过监控能够方便的对系统进行跟踪和比较\",{\"1\":{\"289\":1}}],[\"通过监控slow\",{\"1\":{\"112\":1}}],[\"通过建立完善的监控体系\",{\"1\":{\"289\":1}}],[\"通过排除系统闲置的cpu使用率即可获得\",{\"1\":{\"282\":1}}],[\"通过部署node\",{\"1\":{\"275\":1}}],[\"通过这个ui可以方便地直接对数据进行查询\",{\"1\":{\"299\":1}}],[\"通过这个ui可以直接通过promql实现数据的查询以及可视化\",{\"1\":{\"276\":1}}],[\"通过这些exporter程序\",{\"1\":{\"370\":1}}],[\"通过这些构造器\",{\"1\":{\"352\":1}}],[\"通过这些client\",{\"1\":{\"348\":1}}],[\"通过这些标签\",{\"1\":{\"325\":1}}],[\"通过这些丰富的表达书语句\",{\"1\":{\"282\":1}}],[\"通过这些维度prometheus可以对样本数据进行过滤\",{\"1\":{\"269\":1}}],[\"通过这种方式\",{\"1\":{\"307\":1}}],[\"通过这种方式可以快速分析系统慢的原因\",{\"1\":{\"230\":1}}],[\"通过这种方式可以大大简化应用的配置管理复杂度\",{\"1\":{\"221\":1}}],[\"通过这种方式集群内的应用或者系统主机就可以通过集群内部的dns域名kubernetes\",{\"1\":{\"202\":1}}],[\"通过这种方式开发者可以实现更多个性化的扩展支持\",{\"1\":{\"43\":1}}],[\"通过区间向量表达式查询到的结果我们称为\",{\"1\":{\"260\":1}}],[\"通过集合运算\",{\"1\":{\"247\":1}}],[\"通过集群中主机的4194端口获取cadvisor数据\",{\"1\":{\"190\":1}}],[\"通过数学运算符我们可以很方便的计算出\",{\"1\":{\"245\":1}}],[\"通过数据源定义好可视化的数据来源之后\",{\"1\":{\"123\":1}}],[\"通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态\",{\"1\":{\"238\":1}}],[\"通过ingress提供集群外的访问入口\",{\"1\":{\"180\":1}}],[\"通过interval类型的变量\",{\"1\":{\"129\":1}}],[\"通过增长率表示样本的变化情况\",{\"1\":{\"238\":1}}],[\"通过histogram和summary类型的监控指标\",{\"1\":{\"230\":1}}],[\"通过http\",{\"1\":{\"216\":1,\"254\":1}}],[\"通过http探针能够网站或者http服务建立有效的监控\",{\"1\":{\"101\":1,\"316\":1}}],[\"通过without和by可以按照样本的问题对数据进行聚合\",{\"1\":{\"226\":1,\"368\":1}}],[\"通过webhook用户可以完成对告警更多个性化的扩展\",{\"1\":{\"24\":1}}],[\"通过强大的数据统计能力\",{\"1\":{\"225\":1}}],[\"通过运行一下命令安装prometheus\",{\"1\":{\"223\":1}}],[\"通过运行以下命令\",{\"1\":{\"99\":1}}],[\"通过手动的方式部署和升级prometheus过程繁琐并且效率低下\",{\"1\":{\"220\":1}}],[\"通过定义selector中的标签定义选择监控目标的pod对象\",{\"1\":{\"217\":1}}],[\"通过定义标签的匹配规则\",{\"1\":{\"37\":1,\"39\":1}}],[\"通过服务发现的方式\",{\"1\":{\"308\":1}}],[\"通过服务发现\",{\"1\":{\"303\":1}}],[\"通过服务发现规则将prometheus与alertmanager进行了自动关联\",{\"1\":{\"214\":1}}],[\"通过服务发现自动地去发现监控目标\",{\"1\":{\"5\":1}}],[\"通过修改prometheus\",{\"1\":{\"210\":1}}],[\"通过设置kubernetes\",{\"1\":{\"207\":1}}],[\"通过设置match\",{\"1\":{\"41\":1}}],[\"通过设置match规则判断当前告警中是否存在标签labelname并且其值等于labelvalue\",{\"1\":{\"41\":1}}],[\"通过endpoint发现的node\",{\"1\":{\"207\":1}}],[\"通过endpoint\\b是能够找到特定服务的多个访问地址的\",{\"1\":{\"207\":1}}],[\"通过endpoints自动维护满足标签选择器的pod实例的访问信息\",{\"1\":{\"202\":1}}],[\"通过访问prometheus\",{\"1\":{\"230\":1}}],[\"通过访问kubelet的\",{\"1\":{\"200\":1}}],[\"通过访问http\",{\"1\":{\"105\":1}}],[\"通过获取各个节点中kubelet的监控指标\",{\"1\":{\"199\":1}}],[\"通过获取节点的\",{\"1\":{\"190\":1}}],[\"通过alerting指定使用的alertmanager资源即可\",{\"1\":{\"214\":1}}],[\"通过alertmanager提供的webhook支持可以轻松实现这一类的扩展\",{\"1\":{\"27\":1}}],[\"通过api\",{\"1\":{\"199\":1,\"200\":1}}],[\"通过deployment定义了一个单实例的blackbox\",{\"1\":{\"195\":1}}],[\"通过daemonset的形式将node\",{\"1\":{\"201\":1}}],[\"通过daemonset的形式在集群中各个节点部署node\",{\"1\":{\"184\":1}}],[\"通过dashboard页面的settings选项\",{\"1\":{\"129\":1}}],[\"通过网络探针对ingress和service对应的服务进行监控\",{\"1\":{\"194\":1}}],[\"通过直接修改其值为http\",{\"1\":{\"190\":1}}],[\"通过node\",{\"1\":{\"267\":1,\"281\":1}}],[\"通过node动态发现的target会包含如下几类标签\",{\"1\":{\"189\":1}}],[\"通过nginx\",{\"1\":{\"181\":1}}],[\"通过各个节点中kubelet内置的cadvisor中获取个节点中所有容器的运行状态和资源使用情况\",{\"1\":{\"184\":1}}],[\"通过将集群环境抽象为一个统一调度和管理的云\",{\"1\":{\"181\":1}}],[\"通过将监控与数据分离\",{\"1\":{\"145\":1}}],[\"通过kubernetes获取到的endpoint对象\",{\"1\":{\"207\":1}}],[\"通过kubernetes这一中央协调器\",{\"1\":{\"177\":1}}],[\"通过kubectl命令部署blackbox\",{\"1\":{\"203\":1}}],[\"通过kubectl命令\",{\"1\":{\"195\":1}}],[\"通过kubectl命令行\",{\"1\":{\"187\":1}}],[\"通过kubectl命令行工具\",{\"1\":{\"181\":1}}],[\"通过kubectl命令创建rbac对应的各个资源\",{\"1\":{\"186\":1}}],[\"通过kubectl命令还可以对镜像进行滚动升级\",{\"1\":{\"181\":1}}],[\"通过kubectl\",{\"1\":{\"181\":1,\"186\":1,\"214\":1}}],[\"通过blackbox\",{\"1\":{\"180\":1}}],[\"通过separator作为连接符写入到一个新的标签dst\",{\"1\":{\"241\":1}}],[\"通过service暴露的dns地址\",{\"1\":{\"195\":1}}],[\"通过service\",{\"1\":{\"187\":1}}],[\"通过service在集群暴露应用功能\",{\"1\":{\"180\":1}}],[\"通过summary可以将http请求的字节数以及请求处理时间作为统计样本\",{\"1\":{\"90\":1}}],[\"通过对不同监控以及历史数据的分析\",{\"1\":{\"289\":1}}],[\"通过对磁盘空间增长率的判断\",{\"1\":{\"289\":1}}],[\"通过对监控样本数据的持续收集和统计\",{\"1\":{\"289\":1}}],[\"通过对监控指标的观察能够预判可能出现的问题\",{\"1\":{\"98\":1,\"289\":1}}],[\"通过对histogram类型的监控指标\",{\"1\":{\"240\":1}}],[\"通过对资源以上指标持续观察\",{\"1\":{\"236\":1}}],[\"通过对应用以及集群运行状态数据的收集和分析\",{\"1\":{\"180\":1,\"182\":1}}],[\"通过与apiserver交互使相应的资源达到预期状态\",{\"1\":{\"179\":1,\"183\":1}}],[\"通过consul动态发现的服务实例还会包含以下metadata标签信息\",{\"1\":{\"310\":1}}],[\"通过controller和pod我们定义了应用程序是如何运行的\",{\"1\":{\"178\":1}}],[\"通过client\",{\"1\":{\"87\":1}}],[\"通过operator高效管理和部署在kubernetes集群中的prometheus\",{\"1\":{\"171\":1}}],[\"通过organization\",{\"1\":{\"124\":1}}],[\"通过url中的match\",{\"1\":{\"169\":1}}],[\"通过时间窗口的形式保存所有的样本数据\",{\"1\":{\"159\":1}}],[\"通过rate\",{\"1\":{\"228\":1}}],[\"通过regex匹配src\",{\"1\":{\"241\":1}}],[\"通过replicas可以控制alertmanager的实例数\",{\"1\":{\"214\":1}}],[\"通过replicas定义了该deployment创建后将会自动创建3个pod实例\",{\"1\":{\"181\":1}}],[\"通过relabeling的keep模式\",{\"1\":{\"207\":1}}],[\"通过relabeling\",{\"1\":{\"199\":1}}],[\"通过relabel设置\",{\"1\":{\"156\":1}}],[\"通过remote\",{\"1\":{\"168\":1}}],[\"通过rule\",{\"1\":{\"72\":1}}],[\"通过value配置项组可以控制当前面板中显示的值\",{\"1\":{\"144\":1}}],[\"通过热图可以直观的查看样本的分布情况\",{\"1\":{\"140\":1}}],[\"通过图形的面积\",{\"1\":{\"139\":1}}],[\"通过该前缀定义的标签就不会写入到target或者采集到的样本的标签中\",{\"1\":{\"312\":1}}],[\"通过该设置grafana会自动计算histogram中的bucket边界范围以及该范围内的值\",{\"1\":{\"139\":1}}],[\"通过该服务用户可以轻松实现dashboard的共享\",{\"1\":{\"123\":1}}],[\"通过left\",{\"1\":{\"138\":1}}],[\"通过labelnames\",{\"1\":{\"95\":1}}],[\"通过硬编码的形式实现\",{\"1\":{\"131\":1}}],[\"通过正则从返回结果中匹配出所需要的ip地址\",{\"1\":{\"130\":1}}],[\"通过指定kubernetes\",{\"1\":{\"187\":1,\"203\":1}}],[\"通过指定特定的dom节点以及相应的promql表达式\",{\"1\":{\"135\":1}}],[\"通过指定正则匹配表达式为\",{\"1\":{\"130\":1}}],[\"通过指标kubelet\",{\"1\":{\"199\":1}}],[\"通过指标io\",{\"1\":{\"95\":2}}],[\"通过指标的labels\",{\"1\":{\"89\":1}}],[\"通过使用功能分区\",{\"1\":{\"297\":1}}],[\"通过使用query\",{\"1\":{\"255\":1}}],[\"通过使用布尔运算符可以方便的获取到该结果\",{\"1\":{\"245\":1}}],[\"通过使用label=value可以选择那些标签满足表达式定义的时间序列\",{\"1\":{\"259\":1}}],[\"通过使用label\",{\"1\":{\"131\":1}}],[\"通过使用变量可以轻松实现对时间序列的过滤\",{\"1\":{\"131\":1}}],[\"通过使用node\",{\"1\":{\"130\":1}}],[\"通过使用promql查询特定prometheus实例中的数据并且在panel中实现可视化\",{\"1\":{\"125\":1}}],[\"通过动态改变promql从而实现基于标签快速对时间序列进行过滤\",{\"1\":{\"128\":1}}],[\"通过graph面板\",{\"1\":{\"282\":1}}],[\"通过grafana添加dashboard并且为该dashboard添加一个类型为\",{\"1\":{\"283\":1}}],[\"通过grafana\",{\"1\":{\"126\":1}}],[\"通过gauge指标\",{\"1\":{\"229\":1}}],[\"通过global\",{\"1\":{\"110\":1}}],[\"通过port\",{\"1\":{\"210\":1,\"216\":1}}],[\"通过pod模式自动发现node\",{\"1\":{\"201\":1}}],[\"通过params参数可以用于指定只获取某些时间序列的样本数据\",{\"1\":{\"169\":1}}],[\"通过panel的\",{\"1\":{\"123\":1}}],[\"通过prober配置项指定探针类型\",{\"1\":{\"101\":1,\"316\":1}}],[\"通过promql可以轻松回答类似于以下问题\",{\"1\":{\"295\":1}}],[\"通过promql可以实现对监控数据的查询\",{\"1\":{\"295\":1}}],[\"通过promql可以实时对prometheus中采集到的样本数据进行查询\",{\"1\":{\"71\":1}}],[\"通过promql我们可以非常方便的对数据进行查询\",{\"1\":{\"282\":1}}],[\"通过promql查询数据\",{\"1\":{\"262\":1}}],[\"通过promql查询当前剩余的可用连接数\",{\"1\":{\"110\":1}}],[\"通过promql内置函数delta\",{\"1\":{\"229\":1}}],[\"通过promql用户可以非常方便地对监控样本数据进行统计分析\",{\"1\":{\"224\":1}}],[\"通过prometheus内置的ui可以对这些采集到的样本数据进行查询\",{\"1\":{\"370\":1}}],[\"通过prometheus\",{\"1\":{\"214\":1,\"282\":1}}],[\"通过prometheus的remote\",{\"1\":{\"152\":1}}],[\"通过prometheus的状态页\",{\"1\":{\"108\":1}}],[\"通过prometheus提供的告警以及告警处理能力\",{\"1\":{\"25\":1}}],[\"通过操作系统提供的相关接口\",{\"1\":{\"115\":1}}],[\"通过min\",{\"1\":{\"126\":1}}],[\"通过mysql全局状态中的com\",{\"1\":{\"109\":1}}],[\"通过matchers部分可以设置多条匹配规则\",{\"1\":{\"37\":1,\"39\":1}}],[\"通过以时序的形式存储这些数据\",{\"1\":{\"228\":1}}],[\"通过以上的例子\",{\"1\":{\"352\":1}}],[\"通过以上步骤\",{\"1\":{\"207\":1}}],[\"通过以上relabel过程实现对pod实例的过滤\",{\"1\":{\"201\":1}}],[\"通过以上设置\",{\"1\":{\"141\":1,\"142\":1}}],[\"通过以上监控指标\",{\"1\":{\"111\":1}}],[\"通过以上3个relabel步骤\",{\"1\":{\"100\":1}}],[\"通过以下表达式可以选择最近5分钟内的所有样本数据\",{\"1\":{\"260\":1}}],[\"通过以下表达式可以得到与increase函数相同的结果\",{\"1\":{\"238\":1}}],[\"通过以下流程可以知道用户识别资源瓶颈\",{\"1\":{\"236\":1}}],[\"通过以下命令查看\",{\"1\":{\"206\":1}}],[\"通过以下命令可以查看node\",{\"1\":{\"206\":1}}],[\"通过以下promql获取当前集群99\",{\"1\":{\"193\":1}}],[\"通过以下promql可以得到各个mysql实例的缓冲池利用率\",{\"1\":{\"111\":1}}],[\"通过以下promql可以查看当前mysql实例查询速率的变化情况\",{\"1\":{\"109\":1}}],[\"通过以下指标展示当前的slow\",{\"1\":{\"112\":1}}],[\"通过以下指令可以查看当前mysql实例中slow\",{\"1\":{\"112\":1}}],[\"通过以下指令可以直接当前mysql实例的连接数\",{\"1\":{\"110\":1}}],[\"通过白盒能够了解其内部的实际运行状态\",{\"1\":{\"98\":1,\"289\":1}}],[\"通过复写父方法prehandle和aftercompletion可以拦截一个http请求生命周期的不同阶段\",{\"1\":{\"94\":1}}],[\"通过注解\",{\"1\":{\"93\":1}}],[\"通过调用io\",{\"1\":{\"87\":1}}],[\"通过表格的形式可以同时显示多条时间序列中的数据\",{\"1\":{\"76\":1}}],[\"通过本章前几节的内容读者应该对prometheus\",{\"1\":{\"75\":1}}],[\"通过$labels\",{\"1\":{\"67\":1}}],[\"通过配置alertmanager可以忽略与该集群有关的其它所有告警\",{\"1\":{\"63\":1}}],[\"通过在prometheus\",{\"1\":{\"280\":1}}],[\"通过在prometheus中使用ruleselector通过选择需要关联的prometheusrule即可\",{\"1\":{\"213\":1}}],[\"通过在prometheus中定义alertrule\",{\"1\":{\"60\":1}}],[\"通过在tls\",{\"1\":{\"199\":1}}],[\"通过在页面中使用promconsole\",{\"1\":{\"135\":1}}],[\"通过在面板中使用promql表达式\",{\"1\":{\"127\":1}}],[\"通过在主机上运行cadvisor用户可以轻松的获取到当前主机上容器的运行统计信息\",{\"1\":{\"105\":1}}],[\"通过在alertmanager的全局设置中定义templates配置来指定自定义模板的访问路径\",{\"1\":{\"45\":1}}],[\"通过一个独立的channle可以减少信息对用户工作的干扰\",{\"1\":{\"47\":1}}],[\"通过一个简单案例\",{\"1\":{\"5\":1}}],[\"通过\",{\"1\":{\"37\":1,\"39\":1}}],[\"通过包transformer\",{\"1\":{\"32\":1}}],[\"通过钉钉客户端\",{\"1\":{\"30\":1}}],[\"通过聚合trello\",{\"1\":{\"29\":1}}],[\"通过聚合github\",{\"1\":{\"29\":1}}],[\"通过内置的告警通知能力\",{\"1\":{\"25\":1}}],[\"通过阅读本章希望读者能对prometheus有一个基本的理解和认识\",{\"1\":{\"5\":1}}],[\"定义所有的监控目标\",{\"1\":{\"307\":1}}],[\"定义alertmanager实例a2\",{\"1\":{\"149\":1}}],[\"定义alertmanager实例a1\",{\"1\":{\"149\":1}}],[\"定义thresholds的分割区间值为\",{\"1\":{\"144\":1}}],[\"定义一个threshold规则\",{\"1\":{\"138\":1}}],[\"定义一个采集任务\",{\"1\":{\"100\":1}}],[\"定义图表\",{\"0\":{\"135\":1}}],[\"定义页面菜单\",{\"0\":{\"134\":1}}],[\"定义变量的可选值\",{\"1\":{\"129\":1}}],[\"定义该指标包含的标签\",{\"1\":{\"95\":1}}],[\"定义recoding\",{\"0\":{\"72\":1}}],[\"定义主机监控告警\",{\"0\":{\"69\":1}}],[\"定义告警规则\",{\"0\":{\"66\":1}}],[\"定义单独子路由用于处理这一类的告警通知\",{\"1\":{\"42\":1}}],[\"定义如下抑制规则\",{\"1\":{\"36\":1}}],[\"定义转换器将alertmanager发送的告警通知转换为dingtalk的消息体\",{\"1\":{\"31\":1}}],[\"定义转换器将告警通知转化为dingtalk消息对象\",{\"0\":{\"31\":1}}],[\"定义路由\",{\"1\":{\"28\":1}}],[\"xzf\",{\"1\":{\"273\":1,\"285\":1}}],[\"x509\",{\"1\":{\"199\":1}}],[\"xpost\",{\"1\":{\"150\":3}}],[\"xtitle\",{\"1\":{\"135\":1}}],[\"xxx段\",{\"1\":{\"130\":1}}],[\"xxx段的ip地址替换为10\",{\"1\":{\"130\":1}}],[\"xvf\",{\"1\":{\"54\":1,\"373\":1}}],[\"xfl1rihl3hrnc2w9nnhrb004\",{\"1\":{\"48\":3,\"49\":1}}],[\"x\",{\"1\":{\"30\":1,\"48\":1,\"135\":2,\"157\":6,\"159\":1}}],[\"$2\",{\"1\":{\"201\":1,\"207\":1}}],[\"$gopath\",{\"1\":{\"167\":1}}],[\"$path\",{\"1\":{\"150\":1}}],[\"$pod\",{\"1\":{\"130\":1}}],[\"$1\",{\"1\":{\"130\":1,\"190\":1,\"201\":1,\"207\":1,\"214\":2,\"218\":6,\"241\":1,\"310\":1}}],[\"$node\",{\"1\":{\"128\":1}}],[\"$labels\",{\"1\":{\"67\":6,\"69\":4,\"151\":4}}],[\"$value\",{\"1\":{\"67\":2,\"69\":2,\"151\":2}}],[\"$value则可以获取当前promql表达式计算的样本值\",{\"1\":{\"67\":1}}],[\"$version\",{\"1\":{\"54\":2,\"273\":1}}],[\"$alerts1\",{\"1\":{\"150\":3}}],[\"$alert\",{\"1\":{\"51\":27}}],[\"$index\",{\"1\":{\"51\":4}}],[\"$\",{\"1\":{\"30\":1,\"86\":1,\"87\":1,\"104\":1,\"108\":2,\"150\":1,\"167\":2,\"175\":3,\"181\":13,\"186\":3,\"187\":5,\"188\":2,\"189\":1,\"190\":1,\"192\":2,\"195\":1,\"197\":3,\"199\":2,\"200\":1,\"201\":5,\"202\":2,\"203\":5,\"205\":5,\"206\":3,\"210\":3,\"213\":1,\"214\":5,\"216\":4,\"217\":3,\"218\":4,\"219\":2,\"223\":2,\"255\":1,\"257\":1,\"273\":2,\"305\":7,\"310\":1}}],[\">>header<<\",{\"1\":{\"305\":1}}],[\">=\",{\"1\":{\"245\":1,\"248\":1,\"359\":1,\"369\":1}}],[\">8086\",{\"1\":{\"167\":1}}],[\">graph<\",{\"1\":{\"134\":1}}],[\">alerts<\",{\"1\":{\"134\":1}}],[\">prometheus<\",{\"1\":{\"134\":1}}],[\"><\",{\"1\":{\"134\":3,\"135\":1,\"268\":2}}],[\">toggle\",{\"1\":{\"134\":1}}],[\">1s\",{\"1\":{\"67\":1}}],[\">5\",{\"1\":{\"67\":1}}],[\">\",{\"1\":{\"30\":2,\"31\":1,\"66\":1,\"67\":1,\"69\":2,\"90\":1,\"134\":7,\"150\":7,\"151\":9,\"167\":3,\"245\":2,\"246\":1,\"248\":1,\"268\":2,\"325\":4,\"359\":1,\"360\":2,\"361\":1,\"369\":1}}],[\"+cmd\",{\"1\":{\"305\":1}}],[\"+联邦集群\",{\"1\":{\"297\":1}}],[\"+inf\",{\"1\":{\"95\":1,\"116\":2,\"139\":1,\"230\":1,\"240\":1}}],[\"+\",{\"0\":{\"154\":1,\"155\":2},\"1\":{\"30\":2,\"109\":18,\"110\":18,\"111\":27,\"112\":18,\"154\":1,\"155\":3,\"190\":7,\"195\":2,\"196\":1,\"197\":4,\"199\":4,\"200\":4,\"201\":3,\"203\":6,\"207\":3,\"244\":4,\"248\":1,\"310\":2,\"355\":1,\"358\":3,\"369\":1}}],[\"可扩展\",{\"0\":{\"297\":1}}],[\"可扩展性低\",{\"1\":{\"290\":1}}],[\"可增可减的仪表盘\",{\"0\":{\"229\":1}}],[\"可视化\",{\"0\":{\"299\":1},\"1\":{\"258\":1}}],[\"可视化工具会根据时间序列的标签来渲染图表\",{\"1\":{\"241\":1}}],[\"可视化的精度越低\",{\"1\":{\"126\":1}}],[\"可视化一切\",{\"0\":{\"118\":1}}],[\"可视化是监控的核心目标之一\",{\"1\":{\"5\":1,\"118\":1,\"119\":1}}],[\"可用内存大小\",{\"1\":{\"95\":1,\"229\":1}}],[\"可选参数\",{\"1\":{\"66\":1,\"255\":2,\"257\":1}}],[\"可能在某一个由于访问量或者其它问题导致cpu占用100\",{\"1\":{\"238\":1}}],[\"可能导致计算结果与实际结果产生巨大的差异\",{\"1\":{\"234\":1}}],[\"可能导致大量的服务实例无法连接到数据库\",{\"1\":{\"62\":1}}],[\"可能还是希望能够手动管理prometheus配置文件\",{\"1\":{\"210\":1}}],[\"可能意味着数据库的性能有问题\",{\"1\":{\"111\":1}}],[\"可能会导致数据库性能的下降\",{\"1\":{\"111\":1}}],[\"可能只希望能够在一个通知中就能查看哪些服务实例受到影响\",{\"1\":{\"62\":1}}],[\"可以使prometheus可以从这些exporter间接的获取到相应的监控数据\",{\"1\":{\"370\":1}}],[\"可以使用node\",{\"1\":{\"305\":1}}],[\"可以使用关键字node\",{\"1\":{\"282\":1}}],[\"可以使用offset时间位移操作\",{\"1\":{\"261\":1}}],[\"可以使用on\",{\"1\":{\"250\":1,\"366\":1}}],[\"可以使用如下relabel\",{\"1\":{\"310\":1}}],[\"可以使用如下表达式\",{\"1\":{\"239\":1,\"244\":1}}],[\"可以使用如下方式\",{\"1\":{\"130\":1}}],[\"可以使用表达式\",{\"1\":{\"226\":1,\"248\":1,\"360\":1,\"368\":1}}],[\"可以使用endpoints配置中定义basicauth如下所示\",{\"1\":{\"217\":1}}],[\"可以使用\",{\"1\":{\"181\":1,\"352\":1}}],[\"可以使用send\",{\"1\":{\"150\":1}}],[\"可以使用goreman\",{\"1\":{\"150\":1}}],[\"可以使用graph面板\",{\"1\":{\"136\":1}}],[\"可以使用preferred\",{\"1\":{\"103\":1,\"318\":1}}],[\"可以使用valid\",{\"1\":{\"103\":1,\"318\":1}}],[\"可以使用buckets\",{\"1\":{\"90\":1}}],[\"可以使用以下方式实现\",{\"1\":{\"89\":1}}],[\"可以使用curl验证钉钉webhook是否能够成功调用\",{\"1\":{\"30\":1}}],[\"可以根据用户定义的规则动态地创建或者销毁ec2实例\",{\"1\":{\"313\":1}}],[\"可以简单理解为keep用于选择\",{\"1\":{\"311\":1}}],[\"可以让用户快速实现已有应用程序与prometheus的集成\",{\"1\":{\"350\":1}}],[\"可以让多个prometheus实例产生一个逻辑集群\",{\"1\":{\"297\":1}}],[\"可以让prometheus在单节点的情况下满足大部分用户的监控需求\",{\"1\":{\"152\":1}}],[\"可以理解为agent或者插件\",{\"1\":{\"290\":1}}],[\"可以找到大量可直接使用的dashboard\",{\"1\":{\"283\":1}}],[\"可以计算在单位时间内样本数据的变化情况即增长率\",{\"1\":{\"282\":1}}],[\"可以反映被监控样本的含义\",{\"1\":{\"269\":1}}],[\"可以反映出各个bucket下的大致数据分布情况\",{\"1\":{\"139\":1}}],[\"可以反映出当前mysql服务器的性能状态\",{\"1\":{\"112\":1}}],[\"可以查询该指标下的所有时间序列\",{\"1\":{\"259\":1}}],[\"可以查看minikube项目的官方说明文档进行安装即可\",{\"1\":{\"181\":1}}],[\"可以查看当前alertmanager集群的状态\",{\"1\":{\"150\":1}}],[\"可以查看当前prometheus返回的样本数据\",{\"1\":{\"126\":1}}],[\"可以查看当前target的状态\",{\"1\":{\"108\":1}}],[\"可以查看容器的cpu利用率\",{\"1\":{\"104\":1}}],[\"可以查看预览当前匹配规则匹配到的告警信息\",{\"1\":{\"37\":1,\"39\":1}}],[\"可以这么说\",{\"1\":{\"258\":1}}],[\"可以对其进行扩展\",{\"1\":{\"297\":1}}],[\"可以对时序数据进行丰富的处理\",{\"1\":{\"237\":1}}],[\"可以对线程或者lamda表达式运行时间进行统计\",{\"1\":{\"90\":1}}],[\"可以帮助用户添加与环境相关的特征维度\",{\"1\":{\"310\":1}}],[\"可以帮助用户直接使用promql查询数据\",{\"1\":{\"118\":1}}],[\"可以帮助我们计算监控指标的增长率\",{\"1\":{\"237\":1}}],[\"可以指导用户快速识别资源瓶颈以及错误的方法\",{\"1\":{\"236\":1}}],[\"可以获取到以下监控样本数据\",{\"1\":{\"230\":1}}],[\"可以获取到当前节点上cadvisor的监控样本数据\",{\"1\":{\"188\":1}}],[\"可以获取到当前请求的请求路径\",{\"1\":{\"95\":1}}],[\"可以获取样本在一段时间返回内的变化情况\",{\"1\":{\"229\":1}}],[\"可以直接使用表达式\",{\"1\":{\"226\":1,\"368\":1}}],[\"可以直接设置相关的认证信息即可\",{\"1\":{\"102\":1,\"317\":1}}],[\"可以将time\",{\"1\":{\"268\":1}}],[\"可以将瞬时表达式返回的样本数据进行聚合\",{\"1\":{\"226\":1,\"368\":1}}],[\"可以将告警发送到外部服务如alertmanager中并通过alertmanager可以对这些告警进行进一步的处理\",{\"1\":{\"65\":1}}],[\"可以方便的获取到当前集群中的所有节点信息\",{\"1\":{\"187\":1}}],[\"可以方便的查看和比较监控指标的数据\",{\"1\":{\"76\":1}}],[\"可以方便用户或者开发人员在本地进行与kubernetes相关的开发和测试工作\",{\"1\":{\"181\":1}}],[\"可以声明一个selector\",{\"1\":{\"178\":1}}],[\"可以明显提高prometheus的查询效率\",{\"1\":{\"159\":1}}],[\"可以快速的恢复\",{\"1\":{\"154\":1}}],[\"可以快速对应用进行问题定位\",{\"1\":{\"42\":1}}],[\"可以选择利用prometheus的联邦集群的特性\",{\"1\":{\"152\":1}}],[\"可以看到类似于如下代码\",{\"1\":{\"350\":1}}],[\"可以看到类似于以下内容的告警信息\",{\"1\":{\"214\":1}}],[\"可以看到如下的结果\",{\"1\":{\"312\":1}}],[\"可以看到如下结果\",{\"1\":{\"287\":1}}],[\"可以看到如下信息\",{\"1\":{\"218\":1}}],[\"可以看到当前node\",{\"1\":{\"286\":1}}],[\"可以看到当前系统的运行状态以及配置信息\",{\"1\":{\"57\":1}}],[\"可以看到以下页面\",{\"1\":{\"285\":1}}],[\"可以看到以下输出\",{\"1\":{\"150\":1,\"285\":1}}],[\"可以看到目前operator创建了只包含基本配置的prometheus实例\",{\"1\":{\"216\":1}}],[\"可以看到prometheus\",{\"1\":{\"216\":1}}],[\"可以为读者在选择监控解决方案时\",{\"1\":{\"271\":1}}],[\"可以为指定的时间序列指定自定义的draw\",{\"1\":{\"138\":1}}],[\"可以为user赋予不同的权限\",{\"1\":{\"124\":1}}],[\"可以动态改变promql区间向量表达式中的时间范围\",{\"1\":{\"129\":1}}],[\"可以进入dashboard的配置页面并且选择variables子菜单\",{\"1\":{\"129\":1}}],[\"可以添加如下配置\",{\"1\":{\"138\":1}}],[\"可以添加任意个query\",{\"1\":{\"126\":1}}],[\"可以添加以下依赖\",{\"1\":{\"86\":1}}],[\"可以属于一个或多个不同的organization\",{\"1\":{\"124\":1}}],[\"可以实现对复杂查询的性能优化\",{\"1\":{\"71\":1}}],[\"可以通过prometheus\",{\"1\":{\"309\":1}}],[\"可以通过pushgateway将内部网络的监控数据主动push到gateway当中\",{\"1\":{\"279\":1}}],[\"可以通过refresh\",{\"1\":{\"307\":1}}],[\"可以通过联邦集群以及功能分区的方式对prometheus\",{\"1\":{\"276\":1}}],[\"可以通过label\",{\"1\":{\"241\":1}}],[\"可以通过yaml文件进行描述并创建\",{\"1\":{\"186\":1}}],[\"可以通过consul的dns服务的方式访问其中的节点\",{\"1\":{\"305\":1}}],[\"可以通过content\",{\"1\":{\"117\":1}}],[\"可以通过column\",{\"1\":{\"77\":1}}],[\"可以通过gauge统计函数中某个方法正在处理中的调用次数\",{\"1\":{\"352\":1}}],[\"可以通过global\",{\"1\":{\"109\":1}}],[\"可以通过group\",{\"1\":{\"42\":1}}],[\"可以通过\",{\"1\":{\"108\":1,\"352\":1}}],[\"可以通过http\",{\"1\":{\"108\":1,\"274\":1}}],[\"可以通过以下方式实现\",{\"1\":{\"352\":1}}],[\"可以通过以下表达式counter类型指标的增长率\",{\"1\":{\"238\":1}}],[\"可以通过以下表达式计算容器的cpu使用率\",{\"1\":{\"106\":1}}],[\"可以通过以下公式计算\",{\"1\":{\"160\":1}}],[\"可以通过以下promql查询slow\",{\"1\":{\"112\":1}}],[\"可以通过以下只能查看innodb\",{\"1\":{\"111\":1}}],[\"可以通过以下指令在mysql中查询当前long\",{\"1\":{\"112\":1}}],[\"可以通过以下指令查看\",{\"1\":{\"111\":2}}],[\"可以通过以下指令查询当前mysql实例insert语句的执行次数总量\",{\"1\":{\"109\":1}}],[\"可以通过以下指令进行设置\",{\"1\":{\"110\":1}}],[\"可以通过以下mysql指令查询questions等服务器状态变量的值\",{\"1\":{\"109\":1}}],[\"可以通过以下命令进行查看\",{\"1\":{\"186\":1}}],[\"可以通过以下命令登录到mysql容器当中\",{\"1\":{\"108\":1}}],[\"可以通过以下命令快速在本地启动一个nginx服务\",{\"1\":{\"104\":1}}],[\"可以通过tls\",{\"1\":{\"102\":1,\"317\":1}}],[\"可以通过endpoint配置进行修改\",{\"1\":{\"93\":1}}],[\"可以通过自定义collector的方式\",{\"1\":{\"85\":1}}],[\"可以通过向build\",{\"1\":{\"85\":1}}],[\"可以通过表达式\",{\"1\":{\"68\":1}}],[\"可以通过模板化优化summary以及description的内容的可读性\",{\"1\":{\"67\":1}}],[\"可以停止重复发送由此告警引发的其它告警的机制\",{\"1\":{\"63\":1}}],[\"可以从https\",{\"1\":{\"273\":1,\"285\":1}}],[\"可以从http\",{\"1\":{\"58\":1}}],[\"可以在网页中看到以下内容\",{\"1\":{\"349\":1}}],[\"可以在任何地方\",{\"1\":{\"292\":1}}],[\"可以在系统或者服务在发生故障时能够快速通知相关的人员进行处理\",{\"1\":{\"289\":1}}],[\"可以在两个瞬时向量与瞬时向量之间进行相应的集合操作\",{\"1\":{\"247\":1}}],[\"可以在kubernetes集群中部署blackbox\",{\"1\":{\"195\":1}}],[\"可以在各个数据中心中部署多个prometheus\",{\"1\":{\"170\":1}}],[\"可以在singlestat\",{\"1\":{\"144\":1}}],[\"可以在更大规模上使用grafana\",{\"1\":{\"124\":1}}],[\"可以在prometheus\",{\"1\":{\"106\":1}}],[\"可以在企业微信的后台中建立多个应用\",{\"1\":{\"51\":1}}],[\"可以在钉钉应用群消息中接收到类似于如下通知消息\",{\"1\":{\"30\":1}}],[\"可以接收到如下的告警内容\",{\"1\":{\"50\":1,\"51\":1}}],[\"可以创建自定义模板文件custom\",{\"1\":{\"45\":1}}],[\"可以向webhook地址以post形式发送以下\",{\"1\":{\"30\":1}}],[\"连接数过多\",{\"1\":{\"110\":1}}],[\"连接情况\",{\"0\":{\"110\":1},\"1\":{\"108\":1}}],[\"连接\",{\"1\":{\"30\":1}}],[\"目标\",{\"1\":{\"198\":1}}],[\"目前社区官方提供支持的包括\",{\"1\":{\"347\":1}}],[\"目前支持\",{\"1\":{\"298\":1}}],[\"目前已经有超过650+位贡献者参与到prometheus的研发工作上\",{\"1\":{\"288\":1}}],[\"目前主要支持两种匹配模式\",{\"1\":{\"259\":1}}],[\"目前prometheus社区也提供了部分对于第三方数据库的remote\",{\"1\":{\"167\":1}}],[\"目前prometheus社区官方提供了对以下编程语言的支持\",{\"1\":{\"114\":1}}],[\"目前\",{\"1\":{\"122\":1,\"245\":1,\"247\":1,\"359\":1,\"364\":1}}],[\"目前属于oracle旗下的产品\",{\"1\":{\"107\":1}}],[\"目前alertmanager还不支持钉钉\",{\"1\":{\"60\":1}}],[\"目前为止\",{\"1\":{\"59\":1,\"70\":1,\"185\":1,\"187\":1,\"201\":1}}],[\"目前配置文件中只设置了一个顶级路由route并且定义的接收器为default\",{\"1\":{\"55\":1}}],[\"目前只相当于一个占位符\",{\"1\":{\"55\":1}}],[\"目前官方内置的第三方通知集成包括\",{\"1\":{\"43\":1}}],[\"目前自定义机器人支持文本\",{\"1\":{\"30\":1}}],[\"目录下\",{\"1\":{\"167\":1,\"186\":1}}],[\"目录\",{\"0\":{\"19\":1}}],[\"即结果为\",{\"1\":{\"358\":1}}],[\"即使找不到可以直接使用的client\",{\"1\":{\"347\":1}}],[\"即表示找到当前样本数据中的中位数\",{\"1\":{\"226\":1,\"368\":1}}],[\"即通过联邦集群的特性在任务级别对prometheus采集任务进行划分\",{\"1\":{\"170\":1}}],[\"即单个采集任务的target数也变得非常巨大\",{\"1\":{\"156\":1}}],[\"即\",{\"1\":{\"130\":1,\"142\":1}}],[\"即可获取到需要采集的监控数据\",{\"1\":{\"277\":1}}],[\"即可获取到以下数据\",{\"1\":{\"86\":1}}],[\"即可用性和分区容错性\",{\"1\":{\"148\":1}}],[\"即可实现对histogram类型监控指标的可视化\",{\"1\":{\"141\":1}}],[\"即可实现向该群主发送消息\",{\"1\":{\"30\":1}}],[\"即可在特定区域图形化显示相应的图表内容\",{\"1\":{\"135\":1}}],[\"即可大大简化prometheus任务配置的复杂度\",{\"1\":{\"100\":1}}],[\"即时通讯软件\",{\"1\":{\"43\":1}}],[\"即时获取到异常结果是大多数用户使用监控系统的最主要的目的之一\",{\"1\":{\"25\":1}}],[\"即不能有任何的匹配设置match和match\",{\"1\":{\"41\":1}}],[\"用户共享的dashboard\",{\"1\":{\"283\":1}}],[\"用户无法真正了解系统的真正的运行状态\",{\"1\":{\"232\":1}}],[\"用户看到的依然是一个黑盒\",{\"1\":{\"232\":1}}],[\"用户还能直接使用promql实时查询监控数据\",{\"1\":{\"282\":1}}],[\"用户还需要了解prometheus的样本数据模型\",{\"1\":{\"224\":1}}],[\"用户还可通过插件安装更多类型的panel面板\",{\"1\":{\"123\":1}}],[\"用户还可以通过http\",{\"1\":{\"305\":1}}],[\"用户还可以通过docker提供的http\",{\"1\":{\"104\":1}}],[\"用户还可以基于prometheus提供的client\",{\"1\":{\"114\":1}}],[\"用户都可以通过为pod添加注解的形式为其添加监控指标采集的支持\",{\"1\":{\"201\":1}}],[\"用户应用\",{\"1\":{\"180\":1}}],[\"用户就可以通过dns或http\",{\"1\":{\"305\":1}}],[\"用户就可以按照自己的需求进行后续的逻辑处理\",{\"1\":{\"166\":1}}],[\"用户就可以使用任何方式向该地址发起http\",{\"1\":{\"30\":1}}],[\"用户根据自己当前样本的值含义选择即可\",{\"1\":{\"138\":1}}],[\"用户希望能够手动选择并查看其中特定主机的监控数据\",{\"1\":{\"130\":1}}],[\"用户直接通过手动的方式\",{\"1\":{\"129\":1}}],[\"用户需要手动将认证信息保存到secret中\",{\"1\":{\"217\":1}}],[\"用户需要指定变量的名称\",{\"1\":{\"129\":1}}],[\"用户需要为告警规则命名\",{\"1\":{\"60\":1}}],[\"用户\",{\"1\":{\"124\":1}}],[\"用户只能通过独立运行一个程序的方式\",{\"1\":{\"115\":1}}],[\"用户只需要按照prometheus的格式输出指标数据即可\",{\"1\":{\"347\":1}}],[\"用户只需要按照以上规范返回响应的文本数据即可\",{\"1\":{\"116\":1}}],[\"用户只需要下载对应平台的二进制包\",{\"1\":{\"272\":1}}],[\"用户只需要关心应用程序的最终状态\",{\"1\":{\"221\":1}}],[\"用户只需要部署多套prometheus\",{\"1\":{\"145\":1,\"153\":1}}],[\"用户只需要添加相应的依赖\",{\"1\":{\"87\":1}}],[\"用户只需要定义好smtp相关的配置\",{\"1\":{\"50\":1}}],[\"用户只需要使用post方式向channel发送需要通知的消息即可\",{\"1\":{\"48\":1}}],[\"用户自定义的\",{\"1\":{\"114\":1}}],[\"用户不用再登录到服务器中即可以可视化图表的形式查看主机上所有容器的运行状态\",{\"1\":{\"105\":1}}],[\"用户也可能会很快得到请求失败的响应内容\",{\"1\":{\"234\":1}}],[\"用户也可以通过参数\",{\"1\":{\"273\":1}}],[\"用户也可以通过以下命令查看节点的详细信息\",{\"1\":{\"189\":1}}],[\"用户也可以提供mock数据\\b渲染图像\",{\"1\":{\"126\":1}}],[\"用户也可以基于slack开发自己的聊天机器人来实现一些更高级的能力\",{\"1\":{\"47\":1}}],[\"用户也在启动alertmanager时使用参数修改相关配置\",{\"1\":{\"56\":1}}],[\"用户则可以直接在配置中使用该模板\",{\"1\":{\"45\":1}}],[\"用户可以轻松实现对外部系统\",{\"1\":{\"351\":1}}],[\"用户可以轻松的在应用程序中添加对prometheus的支持\",{\"1\":{\"293\":1}}],[\"用户可以轻松获取样本数据的分布情况\",{\"1\":{\"240\":1}}],[\"用户可以使用promql表达式查询特定监控指标的监控数据\",{\"1\":{\"282\":1}}],[\"用户可以使用这些操作符对进一步的对事件序列进行二次加工\",{\"1\":{\"243\":1}}],[\"用户可以非常方便的安装和使用prometheus并且能够非常方便的对其进行扩展\",{\"1\":{\"281\":1}}],[\"用户可以基于这些特征维度过滤\",{\"1\":{\"258\":1}}],[\"用户可以根据时间序列的特征维度对其进行查询\",{\"1\":{\"245\":1}}],[\"用户可以根据自己的需求灵活选择\",{\"1\":{\"157\":1}}],[\"用户可以根据自己的需求同时启用多种模式\",{\"1\":{\"138\":1}}],[\"用户可以从以下地址中过去prometheus\",{\"1\":{\"223\":1}}],[\"用户可以评估集群中各节点的性能表现\",{\"1\":{\"199\":1}}],[\"用户可以可视化的管理当前集群中运行的所有资源\",{\"1\":{\"181\":1}}],[\"用户可以方便了对应用进行扩容或者缩容\",{\"1\":{\"174\":1}}],[\"用户可以考虑基于prometheus联邦集群的方式将监控采集任务划分到不同的prometheus实例当中即在任务级别功能分区\",{\"1\":{\"155\":1}}],[\"用户可以在controller定义pod的调度规则\",{\"1\":{\"178\":1}}],[\"用户可以在prometheus配置文件中指定remote\",{\"1\":{\"163\":1}}],[\"用户可以在panel的general或者metrics中通过$node的方式使用该变量\",{\"1\":{\"130\":1}}],[\"用户可以在企业中根据用途添加多个channel\",{\"1\":{\"47\":1}}],[\"用户可以获取站点的dns解析耗时\",{\"1\":{\"99\":1}}],[\"用户可以直接在业务代码中实现监控样本收集\",{\"1\":{\"352\":1}}],[\"用户可以直接在alertmanager的配置文件中使用模板字符串\",{\"1\":{\"45\":1}}],[\"用户可以直接查看系统的当前状态\",{\"1\":{\"229\":1}}],[\"用户可以直接通过kubelet组件获取给节点上容器相关监控指标\",{\"1\":{\"180\":1}}],[\"用户可以直接使用\",{\"1\":{\"133\":1}}],[\"用户可以直接使用go\",{\"1\":{\"99\":1}}],[\"用户可以快速实现自己的监控数据收集器\",{\"1\":{\"87\":1}}],[\"用户可以通过json或者yaml格式的文件\",{\"1\":{\"307\":1}}],[\"用户可以通过consul官网https\",{\"1\":{\"305\":1}}],[\"用户可以通过内置函数scalar\",{\"1\":{\"264\":1}}],[\"用户可以通过自定义资源alertmanager进行定义\",{\"1\":{\"214\":1}}],[\"用户可以通过命令行启动参数的方式修改本地存储的配置\",{\"1\":{\"160\":1}}],[\"用户可以通过在service添加注解的形式\",{\"1\":{\"207\":1}}],[\"用户可以通过在promql表达式或者panel的标题中通过以下形式使用该变量\",{\"1\":{\"128\":1}}],[\"用户可以通过在gradle中添加以下依赖\",{\"1\":{\"87\":1}}],[\"用户可以通过以下指令查看当前mysql服务的max\",{\"1\":{\"110\":1}}],[\"用户可以通过以下promql查看当前mysql实例写操作速率的变化情况\",{\"1\":{\"109\":1}}],[\"用户可以通过docker的stats命令获取到当前主机上运行容器的统计信息\",{\"1\":{\"104\":1}}],[\"用户可以通过prometheus\",{\"1\":{\"68\":1}}],[\"用户可以通过prometheus的web界面查看这些告警规则以及告警的触发状态\",{\"1\":{\"65\":1}}],[\"用户可以通过手动点击\",{\"1\":{\"37\":1,\"39\":1}}],[\"用户可以通过该ui定义新的静默规则的开始时间以及持续时间\",{\"1\":{\"37\":1,\"39\":1}}],[\"用户可能只希望接收到一条告警\",{\"1\":{\"36\":1}}],[\"用户或者管理员还可以直接通过alertmanager的ui临时屏蔽特定的告警通知\",{\"1\":{\"37\":1,\"39\":1}}],[\"用于返回比较的结果\",{\"1\":{\"362\":1}}],[\"用于返回该collector中获取到的所有监控指标和样本数据\",{\"1\":{\"350\":1}}],[\"用于指定用于计算promql的时间戳\",{\"1\":{\"255\":1}}],[\"用于指定一组附加信息\",{\"1\":{\"66\":1}}],[\"用于衡量服务的容量需求\",{\"1\":{\"234\":1}}],[\"用于管理kubernetes下资源访问权限\",{\"1\":{\"186\":1}}],[\"用于与对集群资源进行管理\",{\"1\":{\"181\":1}}],[\"用于存储kubernetes集群的所有数据\",{\"1\":{\"179\":1,\"183\":1}}],[\"用于获取多组时间序列的监控数据\",{\"1\":{\"169\":1}}],[\"用于采集当前数据中心监控数据\",{\"1\":{\"169\":1}}],[\"用于实现分布式节点之间的信息交换和状态同步\",{\"1\":{\"148\":1}}],[\"用于缓存数据表以及索引的数据\",{\"1\":{\"111\":1}}],[\"用于验证http返回内容是否符合或者不符合正则表达式的内容\",{\"1\":{\"103\":1,\"318\":1}}],[\"用于表明当前探针是否使用了ssl\",{\"1\":{\"103\":1,\"318\":1}}],[\"用于表示只有当触发条件持续一段时间后才发送告警\",{\"1\":{\"66\":1}}],[\"用于计算区间向量中时间序列每秒的即时增长率\",{\"1\":{\"248\":1,\"369\":1}}],[\"用于计算是否有时间序列满足该条件\",{\"1\":{\"66\":1}}],[\"用于计数器+1\",{\"1\":{\"89\":1}}],[\"用于在启动时添加全局的dingtalk群聊机器人地址\",{\"1\":{\"33\":1}}],[\"用于映射alertmanager发送的告警信息\",{\"1\":{\"28\":1}}],[\"用于定义告警通知时的模板\",{\"1\":{\"26\":1}}],[\"用于定义一些全局的公共参数\",{\"1\":{\"26\":1}}],[\"获取最新的node\",{\"1\":{\"285\":1}}],[\"获取分布直方图的中位数\",{\"1\":{\"240\":1}}],[\"获取时间序列最近两分钟的所有样本\",{\"1\":{\"238\":1}}],[\"获取http请求数前5位的时序样本数据\",{\"1\":{\"226\":1,\"368\":1}}],[\"获取集群中ingress的访问信息\",{\"1\":{\"198\":1}}],[\"获取集群中service的访问地址\",{\"1\":{\"198\":1}}],[\"获取api\",{\"1\":{\"198\":1}}],[\"获取alertmanager提供的webhook示例\",{\"1\":{\"150\":1}}],[\"获取remote\",{\"1\":{\"167\":1}}],[\"获取并监控kubernetes核心组件的运行状态\",{\"1\":{\"180\":1}}],[\"获取并启动prometheus提供的remote\",{\"1\":{\"167\":1}}],[\"获取并安装软件包\",{\"0\":{\"54\":1,\"373\":1}}],[\"获取到每个区间范围内的样本个数\",{\"1\":{\"141\":1}}],[\"获取到当前prometheus监控指标up中所有可选的job\\b标签的值\",{\"1\":{\"131\":1}}],[\"获取当前所有采集任务的名称\",{\"1\":{\"130\":1}}],[\"获取\",{\"1\":{\"54\":1,\"100\":1}}],[\"获取webhook地址\",{\"1\":{\"30\":1}}],[\"获取机器人webhook地址\",{\"1\":{\"30\":1}}],[\"将其注册到collectorregistry中\",{\"1\":{\"351\":1}}],[\"将带领读者感受prometheus是如何对监控系统的重新定义\",{\"1\":{\"300\":1}}],[\"将标签cpu去除后聚合数据即可\",{\"1\":{\"282\":1}}],[\"将采集到的监控数据按照时间序列的方式存储在本地磁盘当中\",{\"1\":{\"276\":1}}],[\"将采集任务地址重定向到apiserver的api地址\",{\"1\":{\"190\":1}}],[\"将单个瞬时向量转换为标量\",{\"1\":{\"264\":1}}],[\"将对prometheus的变更应用到集群中\",{\"1\":{\"218\":1}}],[\"将以一个具体的例子详细讲解如何在应用中实现对prometheus的集成\",{\"1\":{\"352\":1}}],[\"将以下内容保存到example\",{\"1\":{\"217\":1}}],[\"将以上内容保存为文件alertmanager\",{\"1\":{\"214\":2}}],[\"将以上内容保存为example\",{\"1\":{\"213\":1}}],[\"将以上内容保存到prometheus\",{\"1\":{\"210\":1,\"216\":1,\"219\":1}}],[\"将secret的内容作为配置文件挂载到alertmanager实例当中\",{\"1\":{\"214\":1}}],[\"将service与endpoint分离还带来另外一个好处\",{\"1\":{\"206\":1}}],[\"将从kubernetes获取到的默认地址\",{\"1\":{\"199\":1}}],[\"将node节点上的标签\",{\"1\":{\"199\":1}}],[\"将prometheus的配置文件挂载到容器中\",{\"1\":{\"175\":1}}],[\"将prometheus的监控任务划分到不同的实例当中\",{\"1\":{\"152\":1}}],[\"将请求内容转换成writerequest后\",{\"1\":{\"166\":1}}],[\"将两小时内产生的数据存储在一个块\",{\"1\":{\"159\":1}}],[\"将统一任务的不同实例的监控数据采集任务划分到不同的prometheus实例\",{\"1\":{\"156\":1}}],[\"将不同类型的采集任务划分到不同的prometheus子服务中\",{\"1\":{\"155\":1}}],[\"将监控数据保存在第三方存储服务上\",{\"1\":{\"154\":1}}],[\"将显示不同的颜色\",{\"1\":{\"144\":1}}],[\"将显示如下界面\",{\"1\":{\"30\":1}}],[\"将介绍如何使用heatmap\",{\"1\":{\"140\":1}}],[\"将10\",{\"1\":{\"130\":1}}],[\"将会自动跳过ca证书的校验过程\",{\"1\":{\"199\":1}}],[\"将会显示当前系统中所有可使用的panel类型\",{\"1\":{\"126\":1}}],[\"将会介绍更多常用的exporter用法\",{\"1\":{\"92\":1}}],[\"将系统的运行状态数据转换为可供prometheus读取的监控数据\",{\"1\":{\"115\":1}}],[\"将cadvisor添加监控数据采集任务目标当中\",{\"1\":{\"106\":1}}],[\"将该指标注册到collector的defaultregistry中中\",{\"1\":{\"95\":1}}],[\"将incomming\",{\"1\":{\"49\":1}}],[\"将多条告警合合并为一个通知\",{\"1\":{\"42\":1}}],[\"将告警通知发送到第三方服务\",{\"1\":{\"24\":1}}],[\"桌面或者手机\",{\"1\":{\"30\":1}}],[\"以作为下一个relabel操作的输入\",{\"1\":{\"312\":1}}],[\"以适应监控规模的变化\",{\"1\":{\"290\":1}}],[\"以适应不同监控规模的变化\",{\"1\":{\"168\":1}}],[\"以指标http\",{\"1\":{\"240\":1}}],[\"以系统api调用的平均响应时间为例\",{\"1\":{\"230\":1}}],[\"以确保已正常运行\",{\"1\":{\"223\":1}}],[\"以确定在接收到告警后alertmanager需要如何对其进行处理\",{\"1\":{\"40\":1}}],[\"以扩展kubernetes\",{\"1\":{\"221\":1}}],[\"以\",{\"1\":{\"207\":2,\"230\":2}}],[\"以下代码会自动计算当前请求延迟和请求量大小的中位数以及9分位数\",{\"1\":{\"352\":1}}],[\"以下代码会自动统计请求的响应时间以及请求的数据量在buckets下的分布情况\",{\"1\":{\"352\":1}}],[\"以下代码\",{\"1\":{\"351\":1}}],[\"以下代码展示了一个简单的remote\",{\"1\":{\"166\":1}}],[\"以下5个方面\",{\"1\":{\"184\":1}}],[\"以下是类型为histogram和summary的样本输出示例\",{\"1\":{\"116\":1}}],[\"以此类推即可\",{\"1\":{\"240\":1}}],[\"以此类推\",{\"1\":{\"139\":1}}],[\"以prometheus自身的监控指标prometheus\",{\"1\":{\"139\":1}}],[\"以便能够更直观的从可视化图表中获取信息\",{\"1\":{\"138\":1}}],[\"以主机为例\",{\"1\":{\"138\":1}}],[\"以帮助用户能够快速理解grafana\",{\"1\":{\"121\":1}}],[\"以node\",{\"1\":{\"116\":1}}],[\"以我们已经使用过的node\",{\"1\":{\"115\":1}}],[\"以请求响应时间requests\",{\"1\":{\"95\":1}}],[\"以提供日后优化的相关支撑数据\",{\"1\":{\"94\":1}}],[\"以gauge为例\",{\"1\":{\"89\":1}}],[\"以gmail邮箱为例\",{\"1\":{\"50\":1}}],[\"以simpleclient\",{\"1\":{\"87\":1}}],[\"以支持不同类型应用的部署和调度模式\",{\"1\":{\"178\":1}}],[\"以支持规模的扩展\",{\"1\":{\"170\":1}}],[\"以支持更多定制化的场景\",{\"1\":{\"60\":1}}],[\"以支持将alertmanager的告警通知转发到钉钉平台\",{\"1\":{\"29\":1}}],[\"以及线程数等监控统计信息\",{\"1\":{\"349\":1}}],[\"以及查询\",{\"1\":{\"325\":1}}],[\"以及每个任务对应的target列表\",{\"1\":{\"307\":1}}],[\"以及自身的高可用等\",{\"1\":{\"302\":1}}],[\"以及一组标签\",{\"1\":{\"294\":1}}],[\"以及一些其他的性能优化模式\",{\"1\":{\"24\":1}}],[\"以及服务运行状态等直观的信息\",{\"1\":{\"289\":1}}],[\"以及服务状态\",{\"1\":{\"232\":1}}],[\"以及安装应用和插件等主要流程\",{\"1\":{\"283\":1}}],[\"以及聚合\",{\"1\":{\"282\":1}}],[\"以及各个任务下所有实例的状态\",{\"1\":{\"280\":1}}],[\"以及对应的一组标签\",{\"1\":{\"258\":1}}],[\"以及vector2中没有与vector1匹配到的样本数据\",{\"1\":{\"247\":1,\"364\":1}}],[\"以及错误\",{\"1\":{\"236\":1}}],[\"以及后端pod的相关信息\",{\"1\":{\"207\":1}}],[\"以及采集任务地址替换\",{\"1\":{\"201\":1}}],[\"以及监视其资源运行状态\",{\"1\":{\"181\":1}}],[\"以及pod的启动时间等指标上\",{\"1\":{\"180\":1,\"184\":1}}],[\"以及prometheus的基础架构\",{\"1\":{\"1\":1}}],[\"以及metadata\",{\"1\":{\"164\":1}}],[\"以及索引文件\",{\"1\":{\"159\":1}}],[\"以及单台prometheus能够处理的时间序列数\",{\"1\":{\"152\":1}}],[\"以及历史数据的存储\",{\"1\":{\"152\":1}}],[\"以及用于接收告警通知的webhook服务\",{\"1\":{\"150\":1}}],[\"以及用户体验相关的如响应时间等等\",{\"1\":{\"101\":1,\"316\":1}}],[\"以及告警当中\",{\"1\":{\"295\":1}}],[\"以及告警配置等\",{\"1\":{\"147\":1}}],[\"以及告警的接受方式可以通过alertmanager的配置文件进行配置\",{\"1\":{\"62\":1}}],[\"以及字体大小等\",{\"1\":{\"144\":1}}],[\"以及是否包含全选\",{\"1\":{\"130\":1}}],[\"以及通过更专业的开源工具grafana实现prometheus的数据可视化\",{\"1\":{\"119\":1}}],[\"以及跨平台性\",{\"1\":{\"116\":1}}],[\"以及实际监控的场景\",{\"1\":{\"111\":1}}],[\"以及时获取该指标的变化情况\",{\"1\":{\"109\":1}}],[\"以及时间序列模型\",{\"1\":{\"5\":1}}],[\"以及探测目标\",{\"1\":{\"100\":1}}],[\"以及当前探针的具体配置项\",{\"1\":{\"99\":1}}],[\"以及访问效率等\",{\"1\":{\"98\":1}}],[\"以及其值的总量\",{\"1\":{\"230\":1}}],[\"以及其分布情况\",{\"1\":{\"95\":1}}],[\"以及其当前所处的活动状态\",{\"1\":{\"68\":1}}],[\"以及业务状态进行采集\",{\"1\":{\"94\":1}}],[\"以及接收器\",{\"1\":{\"55\":1}}],[\"以及alertmanager需要将匹配到的告警发送给哪一个receiver\",{\"1\":{\"40\":1}}],[\"以及dingtalk群机器人的webhook地址\",{\"1\":{\"32\":1}}],[\"以及它的架构组成\",{\"1\":{\"5\":1}}],[\"以及如何通过一些其他的开源工具如prometheus\",{\"1\":{\"1\":1}}],[\"以及教会读者如果通过prometheus提供的client\",{\"1\":{\"1\":1}}],[\"群机器人\",{\"1\":{\"30\":2}}],[\"群机器人支持webhook协议的自定义接入\",{\"1\":{\"29\":1}}],[\"群机器人可以将第三方服务的信息聚合到群聊中\",{\"1\":{\"29\":1}}],[\"不需要对prometheus进行任何的重启操作\",{\"1\":{\"307\":1}}],[\"不需要指定命名空间\",{\"1\":{\"186\":1}}],[\"不仅仅支持prometheus\",{\"1\":{\"298\":1}}],[\"不仅如此\",{\"1\":{\"29\":1}}],[\"不存在任何的第三方依赖\",{\"1\":{\"292\":1}}],[\"不依赖于任何的第三方依赖\",{\"1\":{\"272\":1}}],[\"不合法\",{\"1\":{\"266\":1}}],[\"不相等\",{\"1\":{\"245\":1,\"359\":1}}],[\"不直接通过kubelet的metrics服务采集监控数据\",{\"1\":{\"199\":1}}],[\"不变的情况下\",{\"1\":{\"160\":1}}],[\"不发送告警\",{\"1\":{\"148\":1}}],[\"不过这里有一些例外\",{\"1\":{\"309\":1}}],[\"不过当需要分析长期趋势或者在告警规则中\",{\"1\":{\"238\":1}}],[\"不过当前来说它并不能发挥其监控系统的作用\",{\"1\":{\"185\":1}}],[\"不过\",{\"1\":{\"187\":1,\"207\":1,\"218\":1}}],[\"不过相应的用户会丢失该块中保存的大概两个小时的监控记录\",{\"1\":{\"161\":1}}],[\"不过通过graph面板展示histogram也并不太直观\",{\"1\":{\"139\":1}}],[\"不过可视化效果不如heatmap\",{\"1\":{\"137\":1}}],[\"不同于4大黄金信号\",{\"1\":{\"236\":1}}],[\"不同在于histogram通过histogram\",{\"1\":{\"230\":1}}],[\"不同在于histogram指标直接反应了在不同区间内样本的个数\",{\"1\":{\"230\":1}}],[\"不同在于histogram可以通过histogram\",{\"1\":{\"95\":1}}],[\"不同容器实例可能包含一些自定义的标签\",{\"1\":{\"85\":1}}],[\"不能一会儿使用中文\",{\"1\":{\"4\":1}}],[\"例如prometheus自身\",{\"1\":{\"370\":1}}],[\"例如使用env标签标示当前节点所在的环境\",{\"1\":{\"307\":1}}],[\"例如使用rate\",{\"1\":{\"282\":1}}],[\"例如使用以下表达式查询表达式up在30秒范围内以15秒为间隔计算promql表达式的结果\",{\"1\":{\"257\":1}}],[\"例如使用以下表达式查询表达式up在时间点2015\",{\"1\":{\"255\":1}}],[\"例如http\",{\"1\":{\"266\":1}}],[\"例如http每秒的平均响应时间\",{\"1\":{\"95\":1}}],[\"例如当存在样本\",{\"1\":{\"250\":1,\"366\":1}}],[\"例如当集群中的某一个主机节点异常宕机导致告警nodedown被触发\",{\"1\":{\"36\":1}}],[\"例如当集群不可用时\",{\"1\":{\"36\":1}}],[\"例如通过up指标可以获取到当前所有运行的exporter实例以及其状态\",{\"1\":{\"241\":1}}],[\"例如cpu的平均运行排队长度\",{\"1\":{\"236\":1}}],[\"例如cpu的平均使用率\",{\"1\":{\"230\":1}}],[\"例如在微服务架构的应用程序中\",{\"1\":{\"313\":1}}],[\"例如在aws中就提供了专门的autoscall服务\",{\"1\":{\"313\":1}}],[\"例如在当前主机上运行的node\",{\"1\":{\"280\":1}}],[\"例如在数据库或者其他关键祸端服务异常触发http\",{\"1\":{\"234\":1}}],[\"例如在监控主机时\",{\"1\":{\"95\":1}}],[\"例如我们可以在应用程序中记录某些事件发生的次数\",{\"1\":{\"228\":1}}],[\"例如aws或者其他平台中的基础设施或者应用\",{\"1\":{\"210\":1}}],[\"例如可以将不同的监控任务分离到不同的prometheus实例当中\",{\"1\":{\"170\":1}}],[\"例如如下所示\",{\"1\":{\"170\":1}}],[\"例如如何监控数据库\",{\"1\":{\"82\":1}}],[\"例如up或者\",{\"1\":{\"169\":1}}],[\"例如一个prometheus\",{\"1\":{\"155\":1}}],[\"例如对于一个企业而言\",{\"1\":{\"124\":1}}],[\"例如自动化运维\",{\"1\":{\"47\":1}}],[\"例如\",{\"1\":{\"29\":1,\"30\":1,\"36\":1,\"42\":1,\"43\":1,\"45\":2,\"47\":1,\"48\":3,\"49\":1,\"60\":1,\"62\":1,\"63\":1,\"67\":1,\"85\":2,\"96\":1,\"104\":1,\"109\":1,\"110\":1,\"117\":1,\"118\":1,\"123\":1,\"126\":2,\"127\":1,\"128\":1,\"130\":2,\"134\":1,\"136\":1,\"138\":2,\"142\":1,\"144\":2,\"149\":1,\"169\":2,\"190\":1,\"193\":1,\"199\":1,\"202\":1,\"206\":2,\"207\":3,\"226\":3,\"227\":2,\"228\":1,\"229\":2,\"230\":2,\"234\":2,\"236\":1,\"238\":1,\"239\":2,\"244\":2,\"245\":1,\"246\":2,\"248\":1,\"251\":1,\"259\":2,\"260\":1,\"264\":1,\"266\":1,\"267\":1,\"277\":1,\"280\":1,\"289\":1,\"290\":1,\"305\":1,\"307\":2,\"309\":2,\"310\":4,\"311\":1,\"312\":1,\"352\":2,\"357\":1,\"358\":1,\"360\":1,\"361\":2,\"362\":1,\"363\":1,\"367\":1,\"368\":3,\"369\":1,\"378\":1}}],[\"提醒\",{\"1\":{\"251\":1,\"367\":1}}],[\"提高用户交互性\",{\"1\":{\"131\":1}}],[\"提高查询效率\",{\"1\":{\"71\":1}}],[\"提高开发效率等\",{\"1\":{\"47\":1}}],[\"提供一定的参考\",{\"1\":{\"271\":1}}],[\"提供了对prometheus的直接支持\",{\"1\":{\"115\":1}}],[\"提供了即时通讯以及移动办公等丰富的功能\",{\"1\":{\"29\":1}}],[\"提供群组聊天和直接消息发送功能\",{\"1\":{\"46\":1}}],[\"提升平台的动态能力\",{\"1\":{\"1\":1}}],[\"专为中国企业打造的免费智能移动办公平台\",{\"1\":{\"29\":1}}],[\"阿里巴巴出品\",{\"1\":{\"29\":1}}],[\"钉钉群机器人告警信息\",{\"1\":{\"34\":1}}],[\"钉钉群机器人是钉钉群的高级扩展功能\",{\"1\":{\"29\":1}}],[\"钉钉\",{\"1\":{\"29\":1}}],[\"join\",{\"1\":{\"241\":1}}],[\"join函数提供了对时间序列标签的自定义能力\",{\"1\":{\"241\":1}}],[\"join函数\",{\"1\":{\"241\":1}}],[\"joined\",{\"1\":{\"150\":1}}],[\"job结合等等\",{\"1\":{\"307\":1}}],[\"job=~\",{\"1\":{\"266\":1}}],[\"job=\",{\"1\":{\"66\":1,\"130\":2,\"135\":2,\"169\":2,\"187\":1,\"189\":1,\"207\":1,\"229\":1,\"239\":1,\"241\":6,\"244\":2,\"246\":2,\"259\":2,\"260\":2,\"287\":2,\"309\":1,\"310\":3,\"357\":4,\"358\":8,\"360\":3,\"361\":2}}],[\"job\",{\"1\":{\"66\":1,\"67\":2,\"72\":2,\"91\":1,\"100\":3,\"106\":1,\"108\":1,\"130\":1,\"131\":1,\"151\":2,\"156\":3,\"169\":4,\"170\":1,\"174\":1,\"187\":6,\"190\":2,\"192\":1,\"196\":1,\"197\":1,\"199\":3,\"200\":2,\"201\":1,\"202\":1,\"203\":2,\"207\":4,\"214\":1,\"218\":2,\"226\":1,\"248\":1,\"255\":2,\"257\":2,\"273\":2,\"280\":4,\"287\":2,\"306\":1,\"307\":5,\"310\":2,\"311\":1,\"312\":3,\"368\":1,\"369\":1,\"377\":3}}],[\"js等等语言的客户端sdk\",{\"1\":{\"298\":1}}],[\"js\",{\"1\":{\"114\":1,\"347\":1}}],[\"json文件中动态获取到的target实例信息以及监控任务的采集状态\",{\"1\":{\"307\":1}}],[\"json\",{\"1\":{\"28\":2,\"30\":1,\"32\":3,\"33\":2,\"102\":1,\"159\":4,\"305\":1,\"307\":2,\"312\":1,\"317\":1}}],[\"jenkins\",{\"1\":{\"114\":1}}],[\"jetty\",{\"1\":{\"87\":1}}],[\"jira\",{\"1\":{\"114\":1}}],[\"jira等项目协调服务\",{\"1\":{\"29\":1}}],[\"jvm相关监控数据采集的实现\",{\"1\":{\"349\":1}}],[\"jvm\",{\"1\":{\"87\":5,\"93\":14,\"349\":16,\"350\":2}}],[\"jmx\",{\"1\":{\"87\":1,\"277\":1,\"298\":2,\"349\":1}}],[\"java依赖包\",{\"1\":{\"349\":1}}],[\"java创建exporter程序\",{\"1\":{\"348\":1}}],[\"java的实现过程\",{\"0\":{\"350\":1}}],[\"java的基本用法\",{\"1\":{\"97\":1}}],[\"java的simpleclient模块中提供了自定义监控指标的核心接口\",{\"1\":{\"85\":1}}],[\"java自定义多种监控指标\",{\"1\":{\"95\":1}}],[\"java还提供了对pushgateway的支持\",{\"1\":{\"91\":1}}],[\"java还提供了多个内置的collector模块\",{\"1\":{\"87\":1}}],[\"java\",{\"0\":{\"348\":1,\"349\":1},\"1\":{\"90\":1,\"93\":2,\"96\":3,\"97\":1,\"114\":1,\"298\":1,\"347\":1,\"348\":1,\"349\":2,\"350\":6}}],[\"java项目中除了使用内置了对jvm监控的collector以外\",{\"1\":{\"87\":1}}],[\"java中对collector的一个针对计数器类型指标的封装\",{\"1\":{\"352\":1}}],[\"java中该提供了对countermetricfamily以及summarymetricfamily等针对其它监控指标类型的支持\",{\"1\":{\"351\":1}}],[\"java中除了使用collector直接采集样本数据以外\",{\"1\":{\"88\":1}}],[\"java中定义的标准接口\",{\"1\":{\"87\":1}}],[\"java中还提供了对spring\",{\"1\":{\"86\":1}}],[\"java下的simpleclient\",{\"1\":{\"86\":1}}],[\"java针对不同指标类型的实现gaugemetricfamily\",{\"1\":{\"85\":1}}],[\"java以支持prometheus\",{\"1\":{\"84\":1}}],[\"java用户可以快速实现独立运行的exporter程序\",{\"1\":{\"84\":1}}],[\"java是prometheus针对jvm类开发语言的client\",{\"1\":{\"84\":1}}],[\"java构建exporter程序\",{\"0\":{\"84\":1},\"1\":{\"9\":1,\"21\":1}}],[\"jaxenter\",{\"1\":{\"16\":1}}],[\"`job=<job\",{\"1\":{\"273\":1}}],[\"`json\",{\"1\":{\"28\":13,\"31\":7}}],[\"`these\",{\"1\":{\"265\":1}}],[\"`\",{\"1\":{\"28\":6,\"31\":6,\"116\":8}}],[\"首先对于nagios而言\",{\"1\":{\"290\":1}}],[\"首先是及时发现问题\",{\"1\":{\"232\":1}}],[\"首先就是数据持久化的问题\",{\"1\":{\"145\":1}}],[\"首先\",{\"1\":{\"134\":1}}],[\"首先grafana是一个通用的可视化工具\",{\"1\":{\"121\":1}}],[\"首先用户需要学习和了解go\",{\"1\":{\"120\":1}}],[\"首先我们需要在kubernetes下定义角色\",{\"1\":{\"186\":1}}],[\"首先我们先从一个小例子开始\",{\"1\":{\"133\":1}}],[\"首先我们使用拦截器处理对应用的所有请求\",{\"1\":{\"94\":1}}],[\"首先我们尝试使用golang创建用于接收webhook告警通知的服务\",{\"1\":{\"28\":1}}],[\"首先为程序添加命令行参数支持\",{\"1\":{\"33\":1}}],[\"首先创建model包\",{\"1\":{\"28\":1}}],[\"n6wp5\",{\"1\":{\"217\":1}}],[\"nix\",{\"1\":{\"319\":1}}],[\"nick\",{\"1\":{\"195\":1}}],[\"nil\",{\"1\":{\"28\":1,\"32\":4,\"33\":1,\"166\":5}}],[\"nfmsw\",{\"1\":{\"181\":2}}],[\"nsq\",{\"1\":{\"114\":1}}],[\"nginx=nginx\",{\"1\":{\"181\":1}}],[\"nginx主页\",{\"1\":{\"181\":1}}],[\"nginx\",{\"1\":{\"104\":1,\"105\":3,\"114\":1,\"181\":29,\"280\":1,\"393\":3}}],[\"n的uri\",{\"1\":{\"95\":1}}],[\"number=\",{\"1\":{\"207\":1}}],[\"numberformatter\",{\"1\":{\"135\":4}}],[\"number\",{\"1\":{\"93\":2,\"99\":1,\"109\":1,\"135\":2}}],[\"numeric\",{\"1\":{\"67\":1}}],[\"null\",{\"1\":{\"58\":1,\"69\":1,\"151\":1}}],[\"nav>\",{\"1\":{\"134\":1}}],[\"nav\",{\"1\":{\"134\":2}}],[\"navigation<\",{\"1\":{\"134\":1}}],[\"navbar\",{\"1\":{\"134\":12}}],[\"nagios等\",{\"1\":{\"298\":1}}],[\"nagios这一类监控系统本身运维管理难度就比较大\",{\"1\":{\"290\":1}}],[\"nagios通过check\",{\"1\":{\"290\":1}}],[\"nagios主机监控页面\",{\"1\":{\"290\":1}}],[\"nagios软件需要安装在一台独立的服务器上运行\",{\"1\":{\"290\":1}}],[\"nagios的主要功能是监控服务和主机\",{\"1\":{\"290\":1}}],[\"nagios监控系统\",{\"1\":{\"290\":1}}],[\"nagios\",{\"0\":{\"338\":1},\"1\":{\"114\":1}}],[\"nand\",{\"1\":{\"48\":1}}],[\"name和描述当前样本特征的labelsets\",{\"1\":{\"268\":1}}],[\"name和label\",{\"1\":{\"116\":1}}],[\"name并重写\",{\"1\":{\"190\":1}}],[\"name的形式引用该变量\",{\"1\":{\"129\":1}}],[\"name的样本必须按照一个组的形式排列\",{\"1\":{\"116\":1}}],[\"name必须遵循promql的格式规范要求\",{\"1\":{\"116\":1}}],[\"name方式定义监控目标\",{\"1\":{\"108\":1}}],[\"name=node\",{\"1\":{\"206\":1}}],[\"name=root\",{\"1\":{\"108\":1}}],[\"name=\",{\"1\":{\"105\":5,\"187\":1,\"189\":1,\"207\":8}}],[\"name=cadvisor\",{\"1\":{\"105\":1}}],[\"name>`\",{\"1\":{\"273\":1}}],[\"name>的形式保存在数据库中的\",{\"1\":{\"269\":1}}],[\"name>=<label\",{\"1\":{\"269\":1}}],[\"name>\",{\"1\":{\"68\":1,\"116\":2,\"256\":2,\"266\":1,\"269\":1}}],[\"namespaceselector\",{\"1\":{\"217\":3}}],[\"namespaces\",{\"1\":{\"214\":1,\"218\":1}}],[\"namespace=\",{\"1\":{\"207\":1}}],[\"namespace=kube\",{\"1\":{\"181\":1}}],[\"namespace\",{\"1\":{\"51\":4,\"95\":30,\"96\":1,\"181\":1,\"186\":3,\"192\":1,\"196\":2,\"197\":2,\"201\":2,\"202\":1,\"203\":6,\"206\":1,\"207\":2,\"210\":1,\"213\":1,\"214\":3,\"216\":1,\"217\":2,\"218\":4,\"219\":3,\"223\":1,\"397\":2}}],[\"names\",{\"1\":{\"49\":1,\"135\":1,\"167\":1,\"214\":1,\"218\":1}}],[\"named\",{\"1\":{\"48\":1}}],[\"name\",{\"1\":{\"27\":1,\"34\":1,\"40\":1,\"43\":1,\"45\":2,\"49\":1,\"50\":2,\"51\":5,\"55\":1,\"66\":1,\"67\":1,\"69\":1,\"72\":6,\"89\":2,\"90\":5,\"95\":4,\"100\":3,\"106\":1,\"108\":1,\"109\":2,\"110\":2,\"111\":3,\"112\":2,\"116\":3,\"135\":3,\"150\":1,\"151\":3,\"156\":3,\"166\":1,\"167\":2,\"169\":5,\"174\":2,\"175\":11,\"181\":8,\"186\":6,\"187\":8,\"189\":1,\"190\":4,\"192\":5,\"195\":4,\"196\":3,\"197\":3,\"199\":4,\"200\":4,\"201\":9,\"202\":5,\"203\":14,\"205\":9,\"206\":5,\"207\":6,\"210\":2,\"213\":3,\"214\":9,\"216\":3,\"217\":11,\"218\":8,\"219\":6,\"223\":1,\"255\":2,\"257\":2,\"258\":1,\"266\":3,\"268\":1,\"269\":3,\"273\":2,\"280\":2,\"287\":2,\"294\":1,\"305\":2,\"306\":1,\"307\":2,\"310\":2,\"311\":1,\"312\":2,\"314\":1,\"352\":6,\"377\":3,\"397\":2}}],[\"noerror\",{\"1\":{\"305\":1,\"314\":1}}],[\"none\",{\"1\":{\"206\":1}}],[\"nonresourceurls\",{\"1\":{\"186\":1,\"219\":1}}],[\"now\",{\"1\":{\"135\":1,\"159\":1,\"181\":1}}],[\"no\",{\"1\":{\"85\":1,\"103\":1,\"160\":1,\"318\":1,\"351\":1,\"372\":1}}],[\"nodeexporter启动后\",{\"1\":{\"375\":1}}],[\"nodeexternalip\",{\"1\":{\"189\":1}}],[\"nodemeta\",{\"1\":{\"305\":1}}],[\"nodehostname\",{\"1\":{\"189\":1}}],[\"nodelegacyhostip\",{\"1\":{\"189\":1}}],[\"nodeinternalip\",{\"1\":{\"189\":1}}],[\"nodes\",{\"1\":{\"186\":2,\"187\":4,\"189\":2,\"190\":2,\"193\":4,\"199\":2,\"200\":1,\"219\":1,\"305\":1,\"310\":1}}],[\"node组件主要包括\",{\"1\":{\"179\":1,\"183\":1}}],[\"node组件会运行在集群的所有节点上\",{\"1\":{\"179\":1,\"183\":1}}],[\"nodeport\",{\"1\":{\"175\":2,\"181\":3}}],[\"node=\",{\"1\":{\"130\":1}}],[\"node\",{\"1\":{\"36\":1,\"51\":4,\"69\":4,\"95\":2,\"114\":2,\"116\":6,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":6,\"135\":3,\"138\":1,\"144\":1,\"151\":7,\"169\":2,\"180\":1,\"187\":14,\"189\":16,\"190\":6,\"198\":4,\"199\":7,\"200\":6,\"201\":11,\"204\":1,\"205\":15,\"206\":7,\"207\":9,\"218\":2,\"227\":3,\"228\":1,\"229\":5,\"232\":1,\"238\":3,\"239\":2,\"241\":2,\"244\":6,\"245\":6,\"248\":1,\"255\":1,\"257\":1,\"262\":3,\"266\":1,\"267\":7,\"268\":3,\"280\":2,\"282\":3,\"285\":10,\"286\":16,\"287\":2,\"298\":1,\"305\":18,\"306\":2,\"307\":1,\"308\":1,\"309\":2,\"310\":10,\"311\":2,\"347\":1,\"358\":14,\"360\":1,\"369\":1,\"372\":1,\"373\":10,\"374\":2,\"375\":2,\"377\":2,\"378\":9,\"392\":1,\"393\":1,\"399\":1}}],[\"nodedown\",{\"1\":{\"36\":1}}],[\"notifier\",{\"1\":{\"32\":1,\"33\":2}}],[\"notifier包中使用golang的net\",{\"1\":{\"32\":1}}],[\"notifications\",{\"1\":{\"45\":2}}],[\"notification\",{\"1\":{\"28\":5,\"31\":7,\"32\":3,\"33\":1,\"45\":1}}],[\"notify\",{\"1\":{\"27\":1,\"51\":1}}],[\"not\",{\"1\":{\"27\":1,\"51\":1,\"99\":1,\"103\":6,\"160\":1,\"214\":1,\"265\":1,\"305\":1,\"314\":3,\"318\":6,\"321\":1}}],[\"n>\",{\"1\":{\"30\":2,\"31\":1}}],[\"n\",{\"1\":{\"30\":6,\"31\":5,\"166\":1,\"210\":3,\"213\":1,\"214\":5,\"216\":3,\"218\":1,\"219\":2,\"223\":2,\"265\":2}}],[\"newfixedthreadpool\",{\"1\":{\"350\":1}}],[\"new\",{\"1\":{\"37\":1,\"39\":1,\"72\":1,\"85\":7,\"86\":3,\"90\":1,\"91\":1,\"94\":1,\"96\":2,\"135\":1,\"349\":1,\"350\":12,\"351\":4}}],[\"newbuffer\",{\"1\":{\"32\":1}}],[\"newrequest\",{\"1\":{\"32\":1}}],[\"news\",{\"1\":{\"16\":1}}],[\"net=host\",{\"1\":{\"396\":1}}],[\"network=192\",{\"1\":{\"396\":1}}],[\"network\",{\"1\":{\"105\":2,\"106\":2,\"286\":1,\"305\":2}}],[\"net\",{\"1\":{\"16\":1,\"18\":1,\"28\":1,\"32\":1,\"45\":2,\"104\":1,\"166\":1,\"298\":1}}],[\"needed\",{\"1\":{\"160\":1}}],[\"need\",{\"1\":{\"16\":1}}],[\"一书中指出\",{\"1\":{\"289\":1}}],[\"一\",{\"1\":{\"251\":1,\"367\":1}}],[\"一对一\\b匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配\",{\"1\":{\"250\":1,\"366\":1}}],[\"一对一匹配\",{\"0\":{\"250\":1,\"366\":1}}],[\"一对一\",{\"1\":{\"249\":1,\"365\":1}}],[\"一是减少时间序列的数量\",{\"1\":{\"160\":1}}],[\"一旦服务注册成功之后\",{\"1\":{\"305\":1}}],[\"一旦设置了该配置项\",{\"1\":{\"163\":1}}],[\"一旦可用连接数被用尽\",{\"1\":{\"110\":1}}],[\"一旦prometheusmetricsinterceptor能够成功拦截和处理请求之后\",{\"1\":{\"95\":1}}],[\"一般需要该应用程序提供对相应监控系统协议的支持\",{\"1\":{\"300\":1}}],[\"一般在定义counter类型指标的名称时推荐使用\",{\"1\":{\"228\":1}}],[\"一般prometheus推荐只保留几周或者几个月的数据\",{\"1\":{\"145\":1}}],[\"一般还可以从监控读操作和写操作的执行情况进行判断\",{\"1\":{\"109\":1}}],[\"一般而言\",{\"1\":{\"95\":1}}],[\"一般来说可以将exporter分为2类\",{\"1\":{\"277\":1}}],[\"一般来说来说\",{\"1\":{\"241\":1}}],[\"一般来说service有两个主要的使用场景\",{\"1\":{\"202\":1}}],[\"一般来说gossip有两种实现方式分别为push\",{\"1\":{\"148\":1}}],[\"一般来说会包含2个主要的配置选项\",{\"1\":{\"126\":1}}],[\"一般来说还需要结合innodb\",{\"1\":{\"111\":1}}],[\"一般来说\",{\"1\":{\"67\":1,\"202\":1,\"262\":1,\"309\":1}}],[\"一般来说我们可以通过以下几种方式来部署alertmanager\",{\"1\":{\"52\":1}}],[\"一般来说有两种方式可以选择\",{\"1\":{\"45\":1}}],[\"一条告警规则主要由以下几部分组成\",{\"1\":{\"66\":1}}],[\"一条典型的告警规则如下所示\",{\"1\":{\"66\":1}}],[\"一种方式基于字符串验证\",{\"1\":{\"41\":1}}],[\"一个最简单的relabel配置如下\",{\"1\":{\"310\":1}}],[\"一个最简单的route定义如下所示\",{\"1\":{\"40\":1}}],[\"一个float64的浮点型数据表示当前样本的值\",{\"1\":{\"268\":1}}],[\"一个精确到毫秒的时间戳\",{\"1\":{\"268\":1}}],[\"一个简单的字符串值\",{\"0\":{\"265\":1}}],[\"一个简单的规则文件可能是这个样子的\",{\"1\":{\"72\":1}}],[\"一个浮点型的数字值\",{\"0\":{\"264\":1}}],[\"一个用于外网访问\",{\"1\":{\"130\":1}}],[\"一个用于内网访问\",{\"1\":{\"130\":1}}],[\"一个完善的监控目标是要能够从白盒的角度发现潜在问题\",{\"1\":{\"98\":1}}],[\"一个group下可以包含多条规则rule\",{\"1\":{\"72\":1}}],[\"一个receiver可以对应一组webhook配置\",{\"1\":{\"27\":1}}],[\"一会儿又使用英文\",{\"1\":{\"4\":1}}],[\"其值作为新标签的值\",{\"1\":{\"310\":1}}],[\"其值就会+1\",{\"1\":{\"109\":1}}],[\"其对传统监控系统的测试和告警模型进行了彻底的颠覆\",{\"1\":{\"291\":1}}],[\"其核心是采用了测试和告警\",{\"1\":{\"290\":1}}],[\"其可以是一个独立运行的程序独立于监控目标以外\",{\"1\":{\"285\":1}}],[\"其主要任务负责数据的收集\",{\"1\":{\"285\":1}}],[\"其会默认加载当前路径下的prometheus\",{\"1\":{\"273\":1}}],[\"其采集的数据会以文件的形式存储在本地中\",{\"1\":{\"273\":1}}],[\"其提供对时间序列数据丰富的查询\",{\"1\":{\"258\":1}}],[\"其样本单位为bytes\",{\"1\":{\"244\":1}}],[\"其无法反应在时间窗口内样本数据的突发变化\",{\"1\":{\"238\":1}}],[\"其注释中也包含了该样本的类型\",{\"1\":{\"227\":1}}],[\"其注释信息为\",{\"1\":{\"89\":1}}],[\"其余标签则移除\",{\"1\":{\"226\":1,\"368\":1}}],[\"其余的配置则根据panel类型的不同而不同\",{\"1\":{\"126\":1}}],[\"其实就是要了解prometheus\",{\"1\":{\"222\":1}}],[\"其实际意义是当表达式\",{\"1\":{\"60\":1}}],[\"其负责维护和管理节点上pod的运行状态\",{\"1\":{\"199\":1}}],[\"其负责代理外部进入集群内的请求\",{\"1\":{\"178\":1}}],[\"其默认运行端口为4194\",{\"1\":{\"188\":1}}],[\"其默认值为10秒\",{\"1\":{\"112\":1}}],[\"其默认值为5分钟\",{\"1\":{\"26\":1}}],[\"其次prometheus\",{\"1\":{\"276\":1}}],[\"其次是要能够快速对问题进行定位\",{\"1\":{\"232\":1}}],[\"其次\",{\"1\":{\"180\":1,\"184\":1,\"193\":1}}],[\"其次本地存储也意味着prometheus不适合保存大量历史数据\",{\"1\":{\"145\":1}}],[\"其解决如用户应用程序如何运行的问题\",{\"1\":{\"180\":1,\"182\":1}}],[\"其他实例接收到gossip消息后\",{\"1\":{\"148\":1}}],[\"其只能处理一条时间序列\",{\"1\":{\"144\":1}}],[\"其并不能直接反映出bucket的\\b大小以及分布情况\",{\"1\":{\"139\":1}}],[\"其匹配图例名称满足\",{\"1\":{\"138\":1}}],[\"其通过折线图或者柱状图的形式显示监控样本随时间而变化的趋势\",{\"1\":{\"136\":1}}],[\"其必须是一一对应的\",{\"1\":{\"135\":1}}],[\"其分别指定页面组件以及页面的存储路径\",{\"1\":{\"133\":1}}],[\"其不同分位数quantile所代表的样本\",{\"1\":{\"116\":1}}],[\"其它内置函数\",{\"0\":{\"242\":1}}],[\"其它的都通过kubernetes来帮助我们完成\",{\"1\":{\"221\":1}}],[\"其它操作系统用户\",{\"1\":{\"181\":1}}],[\"其它\",{\"1\":{\"114\":1}}],[\"其允许用户通过\",{\"1\":{\"99\":1}}],[\"其内部实现如下所示\",{\"1\":{\"86\":1}}],[\"其中simpleclient是对prometheus集成的核心依赖\",{\"1\":{\"349\":1}}],[\"其中action定义了当前relabel\",{\"1\":{\"310\":1}}],[\"其中alertmanager的服务运行在9093端口\",{\"1\":{\"149\":1}}],[\"其中模式的任务名称为file\",{\"1\":{\"307\":1}}],[\"其中help用于解释当前指标的含义\",{\"1\":{\"286\":1}}],[\"其中histogram和summary都可以用于统计和分析数据的分布情况\",{\"1\":{\"240\":1}}],[\"其中以\",{\"1\":{\"269\":1}}],[\"其中非\",{\"1\":{\"267\":1}}],[\"其中irate是promql中的内置函数\",{\"1\":{\"248\":1,\"369\":1}}],[\"其中φ\",{\"1\":{\"240\":1}}],[\"其中参数v是一个区间向量\",{\"1\":{\"238\":1}}],[\"其中中位数\",{\"1\":{\"230\":1}}],[\"其中只有count\",{\"1\":{\"226\":1,\"368\":1}}],[\"其中basicauth中关联了名为basic\",{\"1\":{\"217\":1}}],[\"其中需要注意的是clusterrole是全局的\",{\"1\":{\"186\":1}}],[\"其中matser组件提供了集群层面的管理功能\",{\"1\":{\"179\":1}}],[\"其中metrics表示当前时间序列的特征维度\",{\"1\":{\"256\":2}}],[\"其中metric\",{\"1\":{\"116\":1}}],[\"其中url用于指定远程读\",{\"1\":{\"165\":1}}],[\"其中主服务运行在9094端口\",{\"1\":{\"149\":1}}],[\"其中主要的参数包括\",{\"1\":{\"149\":1}}],[\"其中大部分的配置选项与graph面板基本保持一致\",{\"1\":{\"141\":1}}],[\"其中任务耗时在01ms区间内的为2次\",{\"1\":{\"139\":1}}],[\"其中标签le定义了分布桶bucket的边界\",{\"1\":{\"139\":1}}],[\"其中包含三个部分\",{\"1\":{\"138\":1}}],[\"其中还会包含两个特殊的数据源\",{\"1\":{\"126\":1}}],[\"其中像graph这样的面板允许用户可视化任意多个监控指标以及多条时间序列\",{\"1\":{\"126\":1}}],[\"其中version用于指定text\",{\"1\":{\"117\":1}}],[\"其中y为当前分布的上位数\",{\"1\":{\"116\":1}}],[\"其中\",{\"1\":{\"95\":1,\"124\":1,\"138\":1,\"189\":1,\"287\":1}}],[\"其中0\",{\"1\":{\"90\":2,\"226\":1,\"368\":1}}],[\"其中名为value列会显示当前样本的值\",{\"1\":{\"77\":1}}],[\"其中样本的所有标签都被映射成表格的列\",{\"1\":{\"77\":1}}],[\"其中告警的匹配有两种方式可以选择\",{\"1\":{\"41\":1}}],[\"其中route中则主要定义了告警的路由匹配规则\",{\"1\":{\"40\":1}}],[\"其完整配置格式如下\",{\"1\":{\"26\":1}}],[\"读者可以根据自己的实际需求来选择如何部署自己的promethues集群\",{\"1\":{\"146\":1}}],[\"读者可以通过关键字define\",{\"1\":{\"134\":1}}],[\"读者可根据自己的实际场景进行定义\",{\"1\":{\"26\":1}}],[\"读者已经对prometheus已经有了一个相对完成的认识\",{\"1\":{\"132\":1}}],[\"读者将会了解到如何通过prometheus的服务发现能力\",{\"1\":{\"5\":1}}],[\"读者将会了解到prometheus的数据模型\",{\"1\":{\"5\":1}}],[\"qr\",{\"1\":{\"305\":1}}],[\"qps\",{\"1\":{\"232\":1}}],[\"qzlwx\",{\"1\":{\"181\":1}}],[\"question\",{\"1\":{\"305\":2}}],[\"questions反映当前questions计数器的大小\",{\"1\":{\"109\":1}}],[\"questions\",{\"1\":{\"109\":6}}],[\"queries\",{\"1\":{\"112\":6,\"135\":2,\"166\":2}}],[\"queries的增长情况\",{\"1\":{\"112\":1}}],[\"queries的增长率\",{\"1\":{\"112\":1}}],[\"queries的值\",{\"1\":{\"112\":1}}],[\"queries的数量\",{\"1\":{\"112\":1}}],[\"queries的计数器\",{\"1\":{\"112\":1}}],[\"query=up\",{\"1\":{\"255\":1,\"257\":1}}],[\"query=<string>\",{\"1\":{\"255\":1,\"257\":1}}],[\"query和\",{\"1\":{\"254\":1}}],[\"queryresult\",{\"1\":{\"166\":2}}],[\"queryselector\",{\"1\":{\"135\":1}}],[\"querygraph\",{\"1\":{\"135\":2}}],[\"query类型的变量\",{\"1\":{\"130\":1}}],[\"query\",{\"1\":{\"5\":1,\"112\":4,\"123\":1,\"126\":4,\"129\":1,\"130\":3,\"135\":2,\"159\":1,\"166\":2,\"195\":3,\"246\":2,\"254\":1,\"255\":3,\"257\":3,\"282\":1,\"305\":3,\"314\":2,\"321\":2,\"350\":2,\"360\":1,\"361\":2}}],[\"quantile计算的分位数\",{\"1\":{\"240\":1}}],[\"quantile函数是在服务器端计算的分位数\",{\"1\":{\"230\":1}}],[\"quantile函数在服务器端计算分位数\",{\"1\":{\"95\":1}}],[\"quantile用于计算当前样本数据值的分布情况quantile\",{\"1\":{\"226\":1,\"368\":1}}],[\"quantile\",{\"1\":{\"90\":2,\"95\":2,\"226\":3,\"230\":1,\"240\":2,\"352\":4,\"368\":3}}],[\"quantile=0\",{\"1\":{\"230\":2}}],[\"quantile=\",{\"1\":{\"67\":1,\"95\":2,\"116\":4,\"193\":1,\"199\":1,\"230\":3}}],[\"qq\",{\"1\":{\"26\":1,\"51\":1}}],[\"qyapi\",{\"1\":{\"26\":1,\"51\":1}}],[\"eu\",{\"1\":{\"397\":1}}],[\"e561b376\",{\"1\":{\"305\":1}}],[\"edns\",{\"1\":{\"305\":1}}],[\"edit\",{\"1\":{\"210\":1}}],[\"editor还提供了调试相关的功能\",{\"1\":{\"126\":1}}],[\"editor界面\",{\"1\":{\"126\":1}}],[\"editor中定义查询结果的format\",{\"1\":{\"139\":1}}],[\"editor中\",{\"1\":{\"123\":1,\"126\":1}}],[\"editor\",{\"1\":{\"123\":1,\"126\":3}}],[\"edison\",{\"1\":{\"114\":1}}],[\"e8a8\",{\"1\":{\"305\":2}}],[\"e2f8\",{\"1\":{\"305\":2}}],[\"e2c\",{\"1\":{\"280\":1}}],[\"epoch\",{\"1\":{\"188\":1}}],[\"echo\",{\"1\":{\"305\":1}}],[\"ec2\",{\"1\":{\"298\":1}}],[\"ec2可用区\",{\"1\":{\"169\":1}}],[\"ecs\",{\"1\":{\"114\":1}}],[\"either\",{\"1\":{\"135\":1}}],[\"each\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"286\":1}}],[\"erlang\",{\"1\":{\"114\":1}}],[\"err=\",{\"1\":{\"218\":1}}],[\"errmsg\",{\"1\":{\"30\":1}}],[\"errcode\",{\"1\":{\"30\":1}}],[\"errortype\",{\"1\":{\"253\":1}}],[\"error=\",{\"1\":{\"110\":2}}],[\"errors\",{\"1\":{\"110\":6,\"236\":2,\"250\":6,\"251\":2,\"366\":6,\"367\":2}}],[\"error\",{\"1\":{\"28\":2,\"31\":1,\"32\":1,\"33\":2,\"144\":1,\"166\":6,\"253\":3}}],[\"err\",{\"1\":{\"28\":3,\"31\":1,\"32\":9,\"33\":3,\"166\":9}}],[\"elasticsearch\",{\"1\":{\"122\":1}}],[\"element\",{\"1\":{\"67\":2}}],[\"else\",{\"1\":{\"49\":2,\"350\":1}}],[\"event\",{\"1\":{\"221\":1}}],[\"events\",{\"1\":{\"26\":1,\"206\":1}}],[\"every\",{\"1\":{\"72\":1,\"273\":4}}],[\"evaluate\",{\"1\":{\"72\":1,\"273\":2}}],[\"evaluated\",{\"1\":{\"72\":2}}],[\"evaluation\",{\"1\":{\"66\":1,\"72\":4,\"151\":1,\"174\":1,\"187\":1,\"190\":1,\"210\":1,\"218\":1,\"273\":2,\"307\":1}}],[\"equivalent\",{\"1\":{\"90\":1}}],[\"equal\",{\"1\":{\"36\":2,\"55\":1}}],[\"eq\",{\"1\":{\"49\":2,\"51\":2}}],[\"empty\",{\"1\":{\"135\":2}}],[\"emoji\",{\"1\":{\"48\":2,\"49\":1}}],[\"email\",{\"1\":{\"34\":1,\"43\":1,\"50\":3}}],[\"etcd\",{\"1\":{\"179\":1,\"183\":1,\"277\":1}}],[\"etcd等直接在代码中使用了prometheus的client\",{\"1\":{\"115\":1}}],[\"etc\",{\"1\":{\"45\":1,\"51\":1,\"69\":2,\"99\":1,\"106\":2,\"108\":2,\"149\":2,\"150\":5,\"151\":5,\"167\":1,\"175\":3,\"218\":1,\"274\":2,\"305\":3,\"307\":2,\"374\":1,\"377\":2,\"396\":2}}],[\"extracted\",{\"1\":{\"310\":1}}],[\"extensions\",{\"1\":{\"175\":1,\"181\":1,\"186\":1,\"195\":1,\"201\":1,\"203\":1,\"205\":1}}],[\"extends\",{\"1\":{\"85\":2,\"94\":2,\"95\":4,\"96\":2,\"350\":1,\"351\":1}}],[\"external\",{\"1\":{\"156\":1,\"175\":1,\"181\":2,\"187\":1,\"192\":1,\"202\":1,\"203\":1,\"218\":1}}],[\"externalurl`\",{\"1\":{\"28\":1}}],[\"externalurl\",{\"1\":{\"27\":1,\"28\":1}}],[\"existing\",{\"1\":{\"310\":1}}],[\"exactly\",{\"1\":{\"273\":1}}],[\"examplealert\",{\"1\":{\"213\":1}}],[\"example3\",{\"1\":{\"150\":2}}],[\"example2\",{\"1\":{\"150\":2}}],[\"example1\",{\"1\":{\"150\":2}}],[\"examples\",{\"0\":{\"405\":1},\"1\":{\"150\":1,\"167\":1}}],[\"example\",{\"1\":{\"66\":1,\"67\":1,\"72\":1,\"100\":1,\"101\":1,\"102\":3,\"103\":3,\"134\":2,\"213\":6,\"214\":3,\"217\":17,\"218\":3,\"316\":1,\"317\":3,\"318\":3}}],[\"excluding\",{\"1\":{\"135\":2}}],[\"exception\",{\"1\":{\"93\":1,\"94\":3,\"95\":11,\"96\":1}}],[\"execstart=\",{\"1\":{\"374\":1}}],[\"executors\",{\"1\":{\"350\":1}}],[\"executorservice\",{\"1\":{\"350\":2}}],[\"executed\",{\"1\":{\"109\":1}}],[\"execution\",{\"1\":{\"93\":1}}],[\"exec\",{\"1\":{\"108\":1,\"167\":1,\"186\":1}}],[\"ex\",{\"1\":{\"94\":2,\"95\":6}}],[\"expected\",{\"1\":{\"321\":1}}],[\"expect\",{\"1\":{\"195\":4,\"321\":1}}],[\"expr>\",{\"1\":{\"250\":4,\"251\":8,\"366\":4,\"367\":8}}],[\"express\",{\"1\":{\"226\":1,\"368\":1}}],[\"expression>\",{\"1\":{\"226\":1,\"368\":1}}],[\"expression\",{\"1\":{\"67\":1,\"72\":1,\"135\":1,\"287\":1,\"310\":3}}],[\"expr\",{\"1\":{\"66\":2,\"67\":2,\"69\":2,\"72\":2,\"135\":2,\"151\":2,\"213\":1}}],[\"exported\",{\"1\":{\"169\":1}}],[\"exporter以及相应的实例\",{\"1\":{\"378\":1}}],[\"exporter以外\",{\"1\":{\"115\":1}}],[\"exporter服务实例的ip地址信息\",{\"1\":{\"305\":1}}],[\"exporter服务的信息\",{\"1\":{\"305\":1}}],[\"exporter通过服务的方式注册到consul当中\",{\"1\":{\"305\":1}}],[\"exporter通过以下指标返回缓冲池中innodb\",{\"1\":{\"111\":1}}],[\"exporter通过以下指标返回缓冲池中各类内存页的数量\",{\"1\":{\"111\":1}}],[\"exporter监控数据\",{\"1\":{\"287\":1}}],[\"exporter监控指标\",{\"0\":{\"286\":1}}],[\"exporter收集监控数据\",{\"0\":{\"287\":1}}],[\"exporter自身进程相关运行指标\",{\"1\":{\"286\":1}}],[\"exporter页面\",{\"1\":{\"285\":1}}],[\"exporter版本的二进制包\",{\"1\":{\"285\":1}}],[\"exporter同样采用golang编写\",{\"1\":{\"285\":1}}],[\"exporter可以被称为一个实例\",{\"1\":{\"280\":1}}],[\"exporter可以是一个单独的为了采集特定数据而构建的应用程序\",{\"1\":{\"83\":1}}],[\"exporter将监控数据采集的端点通过http服务的形式暴露给prometheus\",{\"1\":{\"277\":1}}],[\"exporter我们成功的获取到了当前主机的资源使用情况\",{\"1\":{\"275\":1}}],[\"exporter暴露的http服务\",{\"1\":{\"267\":1}}],[\"exporter暴露的服务中获取监控指标数据\",{\"1\":{\"280\":1}}],[\"exporter暴露的服务\",{\"1\":{\"108\":1}}],[\"exporter返回的样本中指标node\",{\"1\":{\"227\":1}}],[\"exporter返回的样本数据\",{\"1\":{\"116\":1}}],[\"exporter返回的样本数据中\",{\"1\":{\"112\":1}}],[\"exporter能够采集和获取当前所在主机的运行状态数据\",{\"1\":{\"204\":1}}],[\"exporter在集群内暴露访问地址blackbox\",{\"1\":{\"203\":1}}],[\"exporter而言每个节点只运行一个唯一的实例\",{\"1\":{\"205\":1}}],[\"exporter而言每个节点只需要运行一个唯一的实例\",{\"1\":{\"201\":1}}],[\"exporter而言\",{\"1\":{\"201\":1}}],[\"exporter添加了注解\",{\"1\":{\"201\":1}}],[\"exporter部署到了集群中的各个节点中\",{\"1\":{\"201\":1}}],[\"exporter需要能够访问宿主机\",{\"1\":{\"201\":1,\"205\":1}}],[\"exporter获取数据\",{\"1\":{\"287\":1}}],[\"exporter获取到监控数据\",{\"1\":{\"287\":1}}],[\"exporter获取到的当前主机的所有监控数据\",{\"1\":{\"286\":1}}],[\"exporter获取网络探测指标\",{\"1\":{\"198\":2}}],[\"exporter获取节点的资源使用情况\",{\"1\":{\"180\":1}}],[\"exporter进行黑盒监控\",{\"1\":{\"194\":1}}],[\"exporter探针服务\",{\"1\":{\"184\":1}}],[\"exporter探测service的可用性\",{\"1\":{\"180\":1}}],[\"exporter采集主机运行数据\",{\"0\":{\"284\":1}}],[\"exporter采集主机数据\",{\"1\":{\"8\":1,\"20\":1}}],[\"exporter采集当前主机的系统资源使用情况\",{\"1\":{\"281\":1}}],[\"exporter采集到的一个监控样本\",{\"1\":{\"267\":1}}],[\"exporter采集节点的资源使用情况\",{\"1\":{\"184\":1}}],[\"exporter对ingress的可用性进行探测\",{\"1\":{\"180\":1}}],[\"exporter规范\",{\"0\":{\"116\":1}}],[\"exporter为例\",{\"1\":{\"115\":1,\"116\":1}}],[\"exporter等都是通过这种方式实现的\",{\"1\":{\"115\":1}}],[\"exporter等\",{\"1\":{\"114\":9,\"277\":1}}],[\"exporter也会自动获取到相关数据\",{\"1\":{\"112\":1}}],[\"exporter中go相关指标\",{\"1\":{\"286\":1}}],[\"exporter中采集主机资源相关的运行资源\",{\"1\":{\"198\":1}}],[\"exporter中包含了默认配置文件中定义了几个常用的探针配置\",{\"1\":{\"195\":1}}],[\"exporter中可以通过以下指标查看innodb\",{\"1\":{\"111\":1}}],[\"exporter中返回的样本数据中通过mysql\",{\"1\":{\"109\":1}}],[\"exporter中所有的探针均是以module的信息进行配置\",{\"1\":{\"101\":1,\"316\":1}}],[\"exporter实现对mysql数据库性能以及资源利用率的监控和度量\",{\"1\":{\"107\":1}}],[\"exporter实例信息作为监控采集目标\",{\"1\":{\"310\":1}}],[\"exporter实例信息动态的维护target列表\",{\"1\":{\"308\":1}}],[\"exporter实例采集上来的样本数据如下所示\",{\"1\":{\"310\":1}}],[\"exporter实例会自动注册到consul中\",{\"1\":{\"308\":1}}],[\"exporter实例对应的ip地址\",{\"1\":{\"206\":1}}],[\"exporter实例即可\",{\"1\":{\"201\":1}}],[\"exporter实例状态\",{\"1\":{\"108\":1}}],[\"exporter实例的样本数据\",{\"1\":{\"311\":1}}],[\"exporter实例的采集任务配置\",{\"1\":{\"108\":1}}],[\"exporter实例的采集任务即可\",{\"1\":{\"100\":1}}],[\"exporter实例的访问地址\",{\"1\":{\"100\":1,\"203\":1}}],[\"exporter实例\",{\"0\":{\"207\":1},\"1\":{\"99\":1,\"195\":2,\"201\":3,\"203\":3,\"205\":1,\"207\":1,\"308\":1}}],[\"exporter内置了对basic\",{\"1\":{\"102\":1,\"317\":1}}],[\"exporter每一个探针配置称为一个module\",{\"1\":{\"99\":1}}],[\"exporter时\",{\"1\":{\"99\":1}}],[\"exporter源码并生成本地可执行文件\",{\"1\":{\"99\":1}}],[\"exporter是以主机网络的形式运行\",{\"1\":{\"201\":1,\"205\":1}}],[\"exporter是否正常连接到了mysql实例\",{\"1\":{\"108\":1}}],[\"exporter是prometheus社区提供的官方黑盒监控解决方案\",{\"1\":{\"99\":1}}],[\"exporter是什么\",{\"0\":{\"113\":1},\"1\":{\"9\":1,\"21\":1}}],[\"exporter的service\",{\"0\":{\"374\":1}}],[\"exporter的service中包含了自定义的注解\",{\"1\":{\"207\":1}}],[\"exporter的服务实例信息\",{\"1\":{\"306\":1}}],[\"exporter的使用\",{\"1\":{\"302\":1}}],[\"exporter的使用场景和方法\",{\"1\":{\"92\":1}}],[\"exporter的pod实例\",{\"1\":{\"203\":1}}],[\"exporter的运行方式\",{\"0\":{\"115\":1}}],[\"exporter的来源\",{\"0\":{\"114\":1}}],[\"exporter的\",{\"1\":{\"109\":1}}],[\"exporter的实例称为一个target\",{\"1\":{\"82\":1}}],[\"exporter程序\",{\"1\":{\"82\":1,\"370\":1}}],[\"exporters\",{\"0\":{\"18\":1,\"277\":1}}],[\"exporter\",{\"0\":{\"98\":1,\"99\":1,\"107\":1,\"108\":1,\"195\":1,\"205\":1,\"285\":1,\"371\":1,\"375\":1},\"1\":{\"9\":2,\"16\":1,\"21\":2,\"99\":3,\"108\":3,\"113\":1,\"114\":25,\"115\":1,\"151\":2,\"195\":11,\"196\":1,\"197\":1,\"198\":3,\"201\":11,\"203\":16,\"204\":2,\"205\":15,\"206\":9,\"207\":7,\"232\":4,\"244\":2,\"277\":2,\"285\":10,\"305\":12,\"306\":2,\"310\":2,\"311\":2,\"349\":1,\"358\":8,\"360\":1,\"372\":1,\"373\":10,\"374\":5,\"375\":2,\"377\":3,\"378\":1,\"392\":1,\"393\":2,\"399\":1}}],[\"exporter详解\",{\"1\":{\"9\":1,\"21\":1}}],[\"export\",{\"1\":{\"54\":1,\"150\":1,\"273\":1}}],[\"expire\",{\"1\":{\"37\":1,\"39\":1}}],[\"e\",{\"1\":{\"27\":1,\"45\":1,\"396\":2}}],[\"env=\",{\"1\":{\"309\":1}}],[\"env\",{\"1\":{\"307\":3}}],[\"environment=\",{\"1\":{\"294\":2}}],[\"environment=~\",{\"1\":{\"259\":1}}],[\"environment\",{\"0\":{\"391\":1},\"1\":{\"42\":2,\"108\":2,\"167\":1,\"349\":1}}],[\"encrypt\",{\"1\":{\"305\":1}}],[\"encoding\",{\"1\":{\"32\":1,\"117\":1,\"350\":1}}],[\"entity\",{\"1\":{\"253\":1}}],[\"entrypoint\",{\"1\":{\"167\":1}}],[\"enabled=true\",{\"1\":{\"167\":1}}],[\"enabled\",{\"1\":{\"93\":1}}],[\"enableprometheusendpoint\",{\"1\":{\"93\":1,\"94\":1,\"96\":1}}],[\"enableprometheusendpoint启用prometheus\",{\"1\":{\"93\":1}}],[\"end=2015\",{\"1\":{\"257\":1}}],[\"end=<rfc3339\",{\"1\":{\"257\":1}}],[\"ends\",{\"1\":{\"135\":1}}],[\"endsat\",{\"1\":{\"27\":1,\"28\":2,\"51\":1}}],[\"endtime\",{\"1\":{\"135\":1}}],[\"end\",{\"1\":{\"45\":1,\"49\":2,\"51\":15,\"134\":2,\"166\":1}}],[\"endpoints\",{\"1\":{\"93\":1,\"186\":1,\"187\":4,\"192\":3,\"198\":1,\"202\":3,\"206\":4,\"207\":9,\"214\":1,\"217\":2,\"218\":4,\"219\":1}}],[\"endpoint为\",{\"1\":{\"93\":1}}],[\"endpoint中统计当前应用jvm的相关信息\",{\"1\":{\"93\":1}}],[\"endpoint\",{\"1\":{\"27\":1,\"75\":1,\"93\":1,\"179\":1,\"183\":1,\"192\":1,\"202\":1,\"207\":3,\"214\":1,\"218\":6,\"273\":1}}],[\"enqueue\",{\"1\":{\"26\":1}}],[\"udp\",{\"1\":{\"181\":1,\"305\":1,\"314\":2}}],[\"ul>\",{\"1\":{\"134\":1}}],[\"uroot\",{\"1\":{\"108\":1}}],[\"url请求参数\",{\"1\":{\"255\":1,\"257\":1}}],[\"url=http\",{\"1\":{\"167\":1}}],[\"url主要用于prometheus无法直接访问适配器服务的情况下\",{\"1\":{\"165\":1}}],[\"url添加到全局配置中即可\",{\"1\":{\"49\":1}}],[\"urlencode\",{\"1\":{\"48\":1}}],[\"url则是用于接收webhook请求的地址\",{\"1\":{\"27\":1}}],[\"url\",{\"1\":{\"26\":6,\"27\":1,\"34\":1,\"40\":1,\"48\":1,\"49\":6,\"51\":4,\"55\":1,\"150\":1,\"165\":4,\"167\":2,\"214\":1}}],[\"utilization\",{\"1\":{\"236\":2}}],[\"util\",{\"1\":{\"96\":3,\"350\":3}}],[\"unescaped\",{\"1\":{\"265\":2}}],[\"unavailiable\",{\"1\":{\"253\":1}}],[\"unprocessable\",{\"1\":{\"253\":1}}],[\"unless和or才注意操作中默认与右向量中的所有元素进行匹配\",{\"1\":{\"251\":1,\"367\":1}}],[\"unless\",{\"1\":{\"247\":2,\"248\":1,\"364\":2,\"369\":1}}],[\"unknown\",{\"1\":{\"187\":1,\"290\":1}}],[\"undo\",{\"1\":{\"181\":1}}],[\"unmarshal\",{\"1\":{\"166\":1}}],[\"unit\",{\"1\":{\"374\":1}}],[\"unit文件\",{\"0\":{\"374\":1}}],[\"units\",{\"1\":{\"135\":1}}],[\"unix\",{\"1\":{\"188\":1,\"255\":1,\"257\":2}}],[\"unixtime\",{\"1\":{\"135\":1}}],[\"unique\",{\"1\":{\"72\":1}}],[\"untyped\",{\"1\":{\"109\":1,\"111\":2,\"112\":1}}],[\"unreachable\",{\"1\":{\"67\":1}}],[\"updated\",{\"1\":{\"181\":1}}],[\"update\",{\"1\":{\"109\":1}}],[\"update以及com\",{\"1\":{\"109\":1}}],[\"upgrades\",{\"1\":{\"321\":1}}],[\"upgrade\",{\"1\":{\"109\":1}}],[\"up指标判断当前mysqld\",{\"1\":{\"108\":1}}],[\"up\",{\"1\":{\"67\":1,\"108\":5,\"130\":1,\"131\":1,\"167\":2,\"181\":3,\"201\":1,\"205\":1,\"241\":7,\"255\":2,\"257\":2,\"280\":1,\"287\":3,\"363\":2}}],[\"ui上直接查询主机相关资源的使用情况\",{\"1\":{\"378\":1}}],[\"ui的targets页面中查看这些实例的metadata标签的内容\",{\"1\":{\"309\":1}}],[\"ui的targets下就可以看到当前从targets\",{\"1\":{\"307\":1}}],[\"ui可以查看consul中所有服务以及节点的状态\",{\"1\":{\"305\":1}}],[\"ui显示出来\",{\"1\":{\"290\":1}}],[\"ui提供了快速验证promql以及临时可视化支持的能力\",{\"1\":{\"283\":1}}],[\"ui提供了基本的数据可视化能力\",{\"1\":{\"118\":1}}],[\"ui用户能够轻松的了解prometheus当前的配置\",{\"1\":{\"282\":1}}],[\"ui用户可以在一个dashboard下添加panel\",{\"1\":{\"126\":1}}],[\"ui是prometheus内置的一个可视化管理界面\",{\"1\":{\"282\":1}}],[\"uid=\",{\"1\":{\"207\":1}}],[\"ui中的targets页面查看当前所有的监控采集任务\",{\"1\":{\"280\":1}}],[\"ui中可以查看该target实例包含的所有metadata标签信息\",{\"1\":{\"189\":1}}],[\"ui中查看到当前所有的target状态\",{\"1\":{\"106\":1}}],[\"ui如果配置正常\",{\"1\":{\"167\":1}}],[\"ui一样定义一个时间轴控制器\",{\"1\":{\"135\":1}}],[\"ui一致\",{\"1\":{\"134\":1}}],[\"ui查看当前告警的活动状态\",{\"1\":{\"70\":1}}],[\"uihttp\",{\"1\":{\"69\":1}}],[\"ui此时可以看到alertmanager接收到的告警信息\",{\"1\":{\"58\":1}}],[\"ui\",{\"1\":{\"37\":1,\"39\":1,\"175\":1,\"187\":1,\"274\":1,\"276\":1,\"299\":1,\"305\":1}}],[\"using\",{\"1\":{\"310\":1}}],[\"usr\",{\"1\":{\"285\":1,\"373\":2,\"374\":1}}],[\"usgae\",{\"1\":{\"69\":2,\"151\":2}}],[\"use方法主要关注与资源的\",{\"1\":{\"236\":1}}],[\"use方法全称\",{\"1\":{\"236\":1}}],[\"use方法\",{\"0\":{\"236\":1}}],[\"used\",{\"1\":{\"87\":5,\"99\":1,\"103\":1,\"135\":1,\"318\":1,\"321\":1,\"349\":5}}],[\"useradd\",{\"1\":{\"372\":1}}],[\"user=node\",{\"1\":{\"374\":1}}],[\"user=prom\",{\"1\":{\"167\":1}}],[\"user=admin\",{\"1\":{\"167\":1}}],[\"user\",{\"1\":{\"51\":3,\"105\":2,\"124\":1,\"167\":1,\"195\":1,\"217\":2,\"218\":1,\"374\":1}}],[\"username=prom\",{\"1\":{\"167\":1}}],[\"username即可\",{\"1\":{\"48\":1}}],[\"username\",{\"1\":{\"26\":1,\"48\":3,\"49\":2,\"50\":2,\"102\":2,\"165\":2,\"167\":1,\"217\":1,\"317\":2}}],[\"use\",{\"0\":{\"394\":1},\"1\":{\"45\":1,\"51\":1,\"167\":1,\"181\":1}}],[\"usage\",{\"1\":{\"33\":1,\"69\":2,\"104\":1,\"105\":4,\"106\":2,\"151\":2}}],[\"ubuntu\",{\"1\":{\"13\":1}}],[\"<<>>\",{\"1\":{\"305\":2}}],[\"<value>\",{\"1\":{\"256\":1,\"257\":1}}],[\"<vector\",{\"1\":{\"226\":1,\"250\":4,\"251\":8,\"366\":4,\"367\":8,\"368\":1}}],[\"<victorops\",{\"1\":{\"43\":1}}],[\"<none>\",{\"1\":{\"175\":2,\"181\":4,\"187\":2,\"192\":1,\"201\":1,\"202\":2,\"203\":1,\"205\":1,\"206\":1}}],[\"<name>\",{\"1\":{\"309\":1}}],[\"<name>形式的标签表示\",{\"1\":{\"100\":1}}],[\"<name\",{\"1\":{\"210\":1}}],[\"<nav\",{\"1\":{\"134\":1}}],[\"<───\",{\"1\":{\"159\":1}}],[\"<li><a\",{\"1\":{\"134\":2}}],[\"<label\",{\"1\":{\"226\":1,\"250\":2,\"251\":8,\"256\":4,\"269\":1,\"366\":2,\"367\":8,\"368\":1}}],[\"<labelvalue>\",{\"1\":{\"36\":2,\"40\":1,\"72\":1,\"165\":1}}],[\"<labelname>变量可以访问当前告警实例中指定标签的值\",{\"1\":{\"67\":1}}],[\"<labelname>\",{\"1\":{\"36\":5,\"40\":3,\"67\":1,\"72\":1,\"165\":1,\"189\":1,\"310\":2}}],[\"<uint64>\",{\"1\":{\"310\":1}}],[\"<unix\",{\"1\":{\"256\":4}}],[\"<ul\",{\"1\":{\"134\":1}}],[\"<username>\",{\"1\":{\"50\":1}}],[\"<usernae>\",{\"1\":{\"50\":1}}],[\"<bin\",{\"1\":{\"250\":2,\"251\":4,\"366\":2,\"367\":4}}],[\"<button\",{\"1\":{\"134\":1}}],[\"<body>\",{\"1\":{\"134\":1}}],[\"<boolean\",{\"1\":{\"321\":2}}],[\"<boolean>\",{\"1\":{\"27\":1,\"40\":1,\"49\":2,\"50\":1,\"51\":1,\"165\":1,\"319\":1}}],[\"<bool>\",{\"1\":{\"26\":1,\"50\":1}}],[\"<metric\",{\"1\":{\"269\":1}}],[\"<metrics\",{\"1\":{\"116\":3}}],[\"<mysql\",{\"1\":{\"108\":1}}],[\"<mail\",{\"1\":{\"50\":1}}],[\"<\",{\"1\":{\"103\":1,\"134\":8,\"135\":1,\"239\":1,\"245\":1,\"248\":1,\"268\":2,\"318\":1,\"359\":1,\"369\":1}}],[\"<int>\",{\"1\":{\"319\":1}}],[\"<inhibit\",{\"1\":{\"26\":1,\"36\":1}}],[\"<icmp\",{\"1\":{\"99\":1}}],[\"<data>\",{\"1\":{\"253\":1}}],[\"<div\",{\"1\":{\"134\":3,\"135\":1}}],[\"<doc\",{\"1\":{\"116\":1}}],[\"<docker\",{\"1\":{\"105\":1}}],[\"<dns\",{\"1\":{\"99\":1}}],[\"<duration>\",{\"1\":{\"26\":1,\"40\":3,\"66\":1,\"72\":2,\"99\":1,\"165\":2}}],[\"<tls\",{\"1\":{\"165\":2,\"321\":1}}],[\"<tcp\",{\"1\":{\"99\":1}}],[\"<tmpl\",{\"1\":{\"26\":1,\"49\":12,\"50\":4,\"51\":1}}],[\"<=\",{\"1\":{\"95\":1,\"103\":1,\"245\":1,\"248\":1,\"318\":1,\"359\":1,\"369\":1}}],[\"<=10\",{\"1\":{\"95\":1}}],[\"<=0\",{\"1\":{\"95\":3}}],[\"<all>\",{\"1\":{\"305\":2}}],[\"<alert\",{\"1\":{\"68\":1}}],[\"<aggr\",{\"1\":{\"226\":1,\"368\":1}}],[\"<address\",{\"1\":{\"189\":1}}],[\"<additional\",{\"1\":{\"68\":1}}],[\"<annotationname>\",{\"1\":{\"189\":1}}],[\"<a\",{\"1\":{\"134\":1}}],[\"<filepath\",{\"1\":{\"66\":1,\"72\":1}}],[\"<filepath>\",{\"1\":{\"26\":1,\"45\":1}}],[\"<operator>\",{\"1\":{\"250\":1,\"366\":1}}],[\"<opsgenie\",{\"1\":{\"43\":1}}],[\"<original\",{\"1\":{\"169\":1}}],[\"<object>\",{\"1\":{\"27\":5}}],[\"<port>\",{\"1\":{\"309\":1}}],[\"<prober\",{\"1\":{\"99\":1}}],[\"<password>\",{\"1\":{\"50\":1}}],[\"<pagerduty\",{\"1\":{\"43\":1}}],[\"<pushover\",{\"1\":{\"43\":1}}],[\"<h3>links<\",{\"1\":{\"135\":1}}],[\"<h3>queries<\",{\"1\":{\"135\":1}}],[\"<h1>prometheus\",{\"1\":{\"135\":1}}],[\"<head>\",{\"1\":{\"134\":1}}],[\"<html>\",{\"1\":{\"134\":1}}],[\"<https\",{\"1\":{\"48\":1}}],[\"<http\",{\"1\":{\"26\":1,\"27\":1,\"99\":1}}],[\"<hipchat\",{\"1\":{\"43\":1}}],[\"<email\",{\"1\":{\"43\":1,\"50\":1}}],[\"<webhook\",{\"1\":{\"27\":1,\"43\":1}}],[\"<rule>\",{\"1\":{\"72\":1}}],[\"<rule\",{\"1\":{\"72\":1}}],[\"<rfc3339>\",{\"1\":{\"27\":2}}],[\"<relabel\",{\"1\":{\"165\":1,\"310\":1}}],[\"<regex>\",{\"1\":{\"36\":2,\"40\":1,\"310\":1,\"314\":6}}],[\"<resolved|firing>\",{\"1\":{\"27\":1}}],[\"<receiver>\",{\"1\":{\"26\":1,\"43\":1}}],[\"<route>\",{\"1\":{\"26\":1,\"40\":2}}],[\"<string\",{\"1\":{\"256\":1}}],[\"<string>\",{\"1\":{\"26\":10,\"27\":5,\"40\":1,\"43\":1,\"50\":6,\"51\":6,\"72\":3,\"165\":10,\"253\":2,\"310\":2,\"314\":6,\"319\":2,\"321\":4}}],[\"<scalar\",{\"1\":{\"256\":1}}],[\"<script>\",{\"1\":{\"135\":1}}],[\"<sample3>\",{\"1\":{\"325\":1}}],[\"<sample2>\",{\"1\":{\"325\":1}}],[\"<sample1>\",{\"1\":{\"325\":1}}],[\"<sample\",{\"1\":{\"256\":2}}],[\"<span\",{\"1\":{\"134\":4}}],[\"<smtp\",{\"1\":{\"50\":1}}],[\"<slack\",{\"1\":{\"43\":1}}],[\"<secret>\",{\"1\":{\"26\":7,\"49\":1,\"50\":2,\"51\":1}}],[\"5操作会将每一条时间序列数据中的瞬时样本数据\",{\"1\":{\"357\":1}}],[\"56\",{\"1\":{\"305\":1}}],[\"564\",{\"1\":{\"273\":1}}],[\"5分钟前的瞬时样本数据\",{\"1\":{\"261\":1}}],[\"5分钟内的数据\",{\"1\":{\"261\":1}}],[\"554\",{\"1\":{\"273\":1}}],[\"55\",{\"1\":{\"273\":6}}],[\"5536e+06\",{\"1\":{\"230\":1}}],[\"55f655696d\",{\"1\":{\"175\":1,\"186\":1}}],[\"5时\",{\"1\":{\"226\":1,\"368\":1}}],[\"523\",{\"1\":{\"273\":1}}],[\"52\",{\"1\":{\"218\":1}}],[\"5251401593e+09\",{\"1\":{\"201\":1,\"205\":1}}],[\"52506226634e+09\",{\"1\":{\"188\":1}}],[\"52s\",{\"1\":{\"181\":1,\"214\":1}}],[\"58b94fcb9\",{\"1\":{\"181\":2}}],[\"587\",{\"1\":{\"50\":1}}],[\"5f9qm\",{\"1\":{\"181\":2}}],[\"50684\",{\"1\":{\"305\":1}}],[\"509537z\",{\"1\":{\"273\":1}}],[\"509509z\",{\"1\":{\"273\":1}}],[\"508068z\",{\"1\":{\"273\":1}}],[\"507999z\",{\"1\":{\"273\":1}}],[\"503\",{\"1\":{\"253\":1}}],[\"501\",{\"1\":{\"250\":1,\"366\":1}}],[\"500\",{\"1\":{\"250\":3,\"251\":2,\"325\":4,\"366\":3,\"367\":2}}],[\"500可以通过在负载均衡器\",{\"1\":{\"234\":1}}],[\"500错误\",{\"1\":{\"234\":1}}],[\"500的情况下\",{\"1\":{\"234\":1}}],[\"5001\",{\"1\":{\"40\":1,\"55\":1,\"150\":1}}],[\"50\",{\"1\":{\"151\":2}}],[\"53\",{\"1\":{\"181\":2}}],[\"53423\",{\"1\":{\"116\":1}}],[\"53196063\",{\"1\":{\"18\":1}}],[\"5s的时间\",{\"1\":{\"148\":1}}],[\"5s\",{\"1\":{\"102\":2,\"103\":3,\"175\":1,\"317\":2,\"318\":3,\"377\":3}}],[\"51s\",{\"1\":{\"181\":1,\"201\":1,\"205\":1}}],[\"512\",{\"1\":{\"139\":1}}],[\"516\",{\"1\":{\"111\":1}}],[\"51\",{\"1\":{\"95\":2,\"139\":1,\"255\":2,\"349\":1}}],[\"5\",{\"1\":{\"66\":1,\"67\":2,\"85\":1,\"86\":1,\"90\":5,\"95\":6,\"108\":1,\"116\":1,\"167\":4,\"181\":1,\"226\":2,\"230\":2,\"240\":4,\"280\":1,\"305\":2,\"350\":1,\"351\":1,\"352\":6,\"357\":4,\"368\":2}}],[\"57\",{\"1\":{\"48\":1,\"150\":8}}],[\"5m\",{\"1\":{\"26\":1,\"40\":1,\"42\":1,\"51\":1,\"55\":1,\"67\":1,\"69\":1,\"95\":3,\"127\":1,\"128\":1,\"135\":2,\"138\":1,\"151\":1,\"214\":3,\"228\":1,\"248\":1,\"260\":1,\"261\":2,\"262\":2,\"369\":1,\"378\":3}}],[\"=<metric\",{\"1\":{\"269\":1}}],[\"=value则可以根据标签匹配排除时间序列\",{\"1\":{\"259\":1}}],[\"=两种完全匹配模式\",{\"1\":{\"259\":1}}],[\"=>2499568128\",{\"1\":{\"358\":1}}],[\"=>1744384\",{\"1\":{\"358\":2}}],[\"=>1634967552\",{\"1\":{\"244\":1,\"358\":2}}],[\"=>864551424\",{\"1\":{\"358\":1}}],[\"=>\",{\"1\":{\"268\":6,\"294\":2,\"357\":4}}],[\"=>0\",{\"1\":{\"244\":1,\"358\":2}}],[\"=~\",{\"1\":{\"128\":1,\"156\":1,\"169\":2,\"266\":2}}],[\"==>\",{\"1\":{\"305\":3}}],[\"==\",{\"1\":{\"67\":1,\"245\":1,\"246\":1,\"248\":1,\"359\":1,\"362\":1,\"363\":2,\"369\":1}}],[\"===参考信息===\",{\"1\":{\"51\":2}}],[\"===告警详情===\",{\"1\":{\"51\":2}}],[\"=====================\",{\"1\":{\"51\":4}}],[\"=\",{\"1\":{\"26\":8,\"27\":2,\"28\":3,\"31\":6,\"32\":9,\"33\":2,\"40\":4,\"49\":10,\"50\":4,\"51\":11,\"66\":1,\"69\":1,\"72\":2,\"85\":7,\"86\":1,\"89\":2,\"90\":6,\"91\":2,\"95\":9,\"96\":2,\"106\":6,\"110\":2,\"116\":2,\"126\":1,\"151\":1,\"160\":1,\"165\":3,\"166\":20,\"169\":3,\"187\":3,\"189\":3,\"207\":3,\"245\":1,\"248\":1,\"259\":5,\"260\":2,\"262\":1,\"269\":1,\"310\":4,\"314\":4,\"319\":2,\"321\":3,\"350\":12,\"351\":3,\"352\":8,\"359\":1,\"369\":1,\"378\":2}}],[\"|\",{\"1\":{\"26\":8,\"27\":2,\"40\":4,\"49\":10,\"50\":4,\"51\":10,\"66\":1,\"72\":2,\"109\":12,\"110\":12,\"111\":18,\"112\":12,\"150\":15,\"151\":11,\"159\":19,\"165\":3,\"167\":29,\"174\":1,\"187\":1,\"190\":1,\"210\":1,\"253\":1,\"255\":1,\"256\":3,\"257\":2,\"305\":1,\"310\":4,\"314\":4,\"319\":2,\"321\":3}}],[\"根据默认的匹配规则\",{\"1\":{\"363\":1}}],[\"根据比较的结果产生一个新的标量0\",{\"1\":{\"362\":1}}],[\"根据当前target实例\",{\"1\":{\"312\":1}}],[\"根据当前prometheus的数据采集情况\",{\"1\":{\"138\":1}}],[\"根据不同的数据中心聚合分析各自的数据\",{\"1\":{\"310\":1}}],[\"根据不同的场景演示了3种不同的高可用部署方案\",{\"1\":{\"157\":1}}],[\"根据时间序列的标签动态生成图例名称\",{\"1\":{\"126\":1}}],[\"根据target实例的地址\",{\"1\":{\"100\":1}}],[\"根据规则中的定义\",{\"1\":{\"72\":1}}],[\"根据路由规则将告警信息发送给相应的接收器\",{\"1\":{\"55\":1}}],[\"根据抑制规则的定义\",{\"1\":{\"36\":1}}],[\"根据标签匹配规则进入到不同的子路由\",{\"1\":{\"55\":1}}],[\"根据标签匹配\",{\"1\":{\"26\":1}}],[\"根据接收到告警的标签匹配相应的处理方式\",{\"1\":{\"26\":1}}],[\"根据需求的不同实现prometheus的扩容\",{\"1\":{\"1\":1}}],[\"来修改便签的匹配行为\",{\"1\":{\"366\":1}}],[\"来修改标签的匹配行为\",{\"1\":{\"250\":1}}],[\"来预测主机可用磁盘空间的是否在4个小时候被占满\",{\"1\":{\"239\":1}}],[\"来解决\",{\"1\":{\"178\":1}}],[\"来组织和管理一组相关的panel\",{\"1\":{\"123\":1}}],[\"来划分多个接收器\",{\"1\":{\"55\":1}}],[\"来完成\",{\"1\":{\"47\":1}}],[\"来定义告警的处理方式\",{\"1\":{\"26\":1}}],[\"来了解prometheus是什么\",{\"1\":{\"5\":1}}],[\"让pod实例能够以主机网络以及系统进程的形式运行\",{\"1\":{\"201\":1,\"205\":1}}],[\"让用户可以基于这两个接口对接将数据保存到任意第三方的存储服务中\",{\"1\":{\"162\":1}}],[\"让用户可以基于prometheus的告警处理模式实现更多的定制化需求\",{\"1\":{\"25\":1}}],[\"让用户可以从不同的数据源\",{\"1\":{\"126\":1}}],[\"让应用程序可以直接将内部的运行状态暴露给prometheus\",{\"1\":{\"115\":1}}],[\"让开发者可以打包他们的应用以及依赖包到一个可移植的容器中\",{\"1\":{\"104\":1}}],[\"让读者对prometheus有一个基本的认识以及概念\",{\"1\":{\"1\":1}}],[\"当文件中定义的内容发生变化时\",{\"1\":{\"307\":1}}],[\"当单实例prometheus\",{\"1\":{\"297\":1}}],[\"当单台prometheus\",{\"1\":{\"155\":1}}],[\"当问题产生之后\",{\"1\":{\"290\":1}}],[\"当问题发生后\",{\"1\":{\"289\":1}}],[\"当系统出现或者即将出现故障时\",{\"1\":{\"289\":1}}],[\"当系统管理员接收到告警以后可能还没来得及去处理问题\",{\"1\":{\"239\":1}}],[\"当这种网络需求无法直接满足时\",{\"1\":{\"279\":1}}],[\"当这些资源达到饱和后\",{\"1\":{\"234\":1}}],[\"当我们需要采集不同的监控指标\",{\"1\":{\"280\":1}}],[\"当我们需要监控某个业务当前正在处理的请求数量\",{\"1\":{\"89\":1}}],[\"当我们直接使用监控指标名称查询时\",{\"1\":{\"259\":1}}],[\"当返回数据类型resulttype为string时\",{\"1\":{\"256\":1}}],[\"当返回数据类型resulttype为scalar时\",{\"1\":{\"256\":1}}],[\"当返回数据类型resulttype为matrix时\",{\"1\":{\"256\":1}}],[\"当返回数据类型resulttype为vector时\",{\"1\":{\"256\":1}}],[\"当请求超时或者被中断时\",{\"1\":{\"253\":1}}],[\"当表达式无法执行时\",{\"1\":{\"253\":1}}],[\"当参数错误或者缺失时\",{\"1\":{\"253\":1}}],[\"当action设置为keep时\",{\"1\":{\"311\":1}}],[\"当api调用成功后\",{\"1\":{\"256\":1}}],[\"当api调用成功后将会返回2xx的http状态码\",{\"1\":{\"253\":1}}],[\"当api调用失败时可能返回以下几种不同的http状态码\",{\"1\":{\"253\":1}}],[\"当alertmanager集群启动完成后\",{\"1\":{\"150\":1}}],[\"当alertmanager接收到来自prometheus的告警消息后\",{\"1\":{\"148\":1}}],[\"当alertmanager单点失效后\",{\"1\":{\"147\":1}}],[\"当瞬时向量与标量之间进行数学运算时\",{\"1\":{\"244\":1}}],[\"当计算9分位数时\",{\"1\":{\"240\":1}}],[\"当磁盘空间只剩512mb时向相关人员发送告警通知\",{\"1\":{\"239\":1}}],[\"当中\",{\"1\":{\"238\":1}}],[\"当φ为0\",{\"1\":{\"226\":1,\"368\":1}}],[\"当relabel\",{\"1\":{\"312\":1}}],[\"当replicas大于1时\",{\"1\":{\"214\":1}}],[\"当role的配置为node时\",{\"1\":{\"189\":1}}],[\"当创建service时如果不指定任何的标签选择器\",{\"1\":{\"202\":1}}],[\"当创建service时如果指定了标签选择器\",{\"1\":{\"202\":1}}],[\"当某些pod发生故障之后\",{\"1\":{\"178\":1}}],[\"当某一个prometheus\",{\"1\":{\"147\":1}}],[\"当pod被创建时\",{\"1\":{\"178\":1}}],[\"当prometheus加载target实例完成后\",{\"1\":{\"309\":1}}],[\"当prometheus通过exporter采集到相应的监控指标样本数据后\",{\"1\":{\"259\":1}}],[\"当prometheus能够从kubernetes的apiserver中获取监控样本数据后\",{\"1\":{\"193\":1}}],[\"当prometheus\",{\"1\":{\"154\":1,\"155\":1}}],[\"当prometheus同时采集了多个主机节点的监控样本数据时\",{\"1\":{\"130\":1}}],[\"当prometheus与alertmanager关联之后\",{\"1\":{\"65\":1}}],[\"当configmap资源创建成功后\",{\"1\":{\"175\":1}}],[\"当cpu利用率达到告警规则触发条件\",{\"1\":{\"151\":1}}],[\"当数据写入成功后\",{\"1\":{\"167\":1}}],[\"当数据能够正常写入influxdb后可以看到prometheus相关的指标\",{\"1\":{\"167\":1}}],[\"当获取到样本数据后\",{\"1\":{\"164\":1}}],[\"当用户创建的prometheus中关联servicemonitor这类会影响配置文件内容的定义时\",{\"1\":{\"210\":1}}],[\"当用户在kubernetes中部署应用程序时\",{\"1\":{\"194\":1}}],[\"当用户发起查询请求后\",{\"1\":{\"164\":1}}],[\"当用户定义webhook用于接收告警信息后\",{\"1\":{\"27\":1}}],[\"当有新的silence产生时使用push\",{\"1\":{\"148\":1}}],[\"当有新的告警规则如果满足source\",{\"1\":{\"36\":1}}],[\"当有大量的target需要采样本时\",{\"1\":{\"145\":1}}],[\"当面板中value的值在0~0\",{\"1\":{\"144\":1}}],[\"当使用表达式count\",{\"1\":{\"264\":1}}],[\"当使用query\",{\"1\":{\"257\":1}}],[\"当使用kubernetes管理一个多节点的集群中\",{\"1\":{\"191\":1}}],[\"当使用deployment管理和部署应用程序时\",{\"1\":{\"174\":1}}],[\"当使用heatmap格式化数据后\",{\"1\":{\"141\":1}}],[\"当使用heatmap可视化histogram类型的监控指标时\",{\"1\":{\"141\":1}}],[\"当使用prometheus监控多个集群以及部署在集群中的应用和数据库服务\",{\"1\":{\"42\":1}}],[\"当需要找到当前系统请求量大于100次的处理模块\",{\"1\":{\"360\":1}}],[\"当需要统计对某些特定方法调用次数的统计时\",{\"1\":{\"352\":1}}],[\"当需要修改时\",{\"1\":{\"307\":1}}],[\"当需要查看主机cpu\",{\"1\":{\"136\":1}}],[\"当需要可视化当前系统中所有采集任务的监控任务运行状态时\",{\"1\":{\"131\":1}}],[\"当需要监控prometheus所有采集任务的状态时\",{\"1\":{\"130\":1}}],[\"当在一个panel中展示多条时间序列数据时\",{\"1\":{\"131\":1}}],[\"当对接prometheus时\",{\"1\":{\"128\":1}}],[\"当查询一段时间范围内的所有样本数据时\",{\"1\":{\"159\":1}}],[\"当查询到的样本数据量非常大时可以导致grafana渲染图标时出现一些性能问题\",{\"1\":{\"126\":1}}],[\"当查询的执行时间超过long\",{\"1\":{\"112\":1}}],[\"当选中的数据源类型为prometheus时\",{\"1\":{\"126\":1}}],[\"当选中数据源时\",{\"1\":{\"126\":1}}],[\"当没有指定版本的时候\",{\"1\":{\"117\":1}}],[\"当缓冲池无法满足时\",{\"1\":{\"111\":1}}],[\"当缓冲池的资源使用超出限制后\",{\"1\":{\"111\":1}}],[\"当所有可用连接都被占用时\",{\"1\":{\"110\":1}}],[\"当客户端发送一个查询语句后\",{\"1\":{\"109\":1}}],[\"当指标值为1时表示能够正常获取监控数据\",{\"1\":{\"108\":1}}],[\"当能够正常采集到cadvisor的样本数据后\",{\"1\":{\"106\":1}}],[\"当访问\",{\"1\":{\"96\":1,\"116\":1}}],[\"当调用collector实例register\",{\"1\":{\"86\":1}}],[\"当向该服务器发送获取样本数据的请求后\",{\"1\":{\"86\":1}}],[\"当监控容器时\",{\"1\":{\"85\":1}}],[\"当无法直接修改监控目标时\",{\"1\":{\"85\":1}}],[\"当告警从活动状态转换为非活动状态时\",{\"1\":{\"68\":1}}],[\"当告警被触发时\",{\"1\":{\"27\":1}}],[\"当满足触发条件后则会触发告警通知\",{\"1\":{\"65\":1}}],[\"当集群中已经安装prometheus\",{\"1\":{\"216\":1}}],[\"当集群中的alertmanager节点不在一台主机时\",{\"1\":{\"150\":1}}],[\"当集群中有数百个正在运行的服务实例\",{\"1\":{\"62\":1}}],[\"当集群不可访问时触发了一次告警\",{\"1\":{\"63\":1}}],[\"当然consul还提供了更多的api用于支持对服务的生命周期管理\",{\"1\":{\"305\":1}}],[\"当然作为开源软件\",{\"1\":{\"283\":1}}],[\"当然在学习promql之前\",{\"1\":{\"224\":1}}],[\"当然也可以尝试删除那些发生错误的块目录\",{\"1\":{\"161\":1}}],[\"当然对于prometheus部署方案需要用户根据监控规模以及自身的需求进行动态调整\",{\"1\":{\"157\":1}}],[\"当然对于命名而言\",{\"1\":{\"60\":1}}],[\"当然本地存储也带来了一些不好的地方\",{\"1\":{\"145\":1}}],[\"当然你也可以将value映射为任意的字符\",{\"1\":{\"144\":1}}],[\"当然用户也可以创建自己的组件\",{\"1\":{\"134\":1}}],[\"当然httpserver中并不存在什么黑魔法\",{\"1\":{\"86\":1}}],[\"当然这些定义都是通过yaml文件来统一管理的\",{\"1\":{\"60\":1}}],[\"当然如果当前接收人需要单独的smtp配置\",{\"1\":{\"50\":1}}],[\"当然\",{\"1\":{\"49\":1,\"133\":1}}],[\"当然实际场景下除了基础设施的监控需求以外\",{\"1\":{\"313\":1}}],[\"当然实际场景下\",{\"1\":{\"40\":1}}],[\"当静默规则生效以后\",{\"1\":{\"37\":1,\"39\":1}}],[\"当规则生效后则进行到active状态\",{\"1\":{\"37\":1,\"39\":1}}],[\"当已经发送的告警通知匹配到target\",{\"1\":{\"36\":1}}],[\"当故障发生时\",{\"1\":{\"25\":1}}],[\"当前target实例的访问地址<host>\",{\"1\":{\"309\":1}}],[\"当前系统时间\",{\"1\":{\"286\":1}}],[\"当前系统中某些事件发生的次数或者资源数量等\",{\"1\":{\"143\":1}}],[\"当前系统中所有服务的运行状态\",{\"1\":{\"143\":1}}],[\"当前在每一个job中主要使用了静态配置\",{\"1\":{\"280\":1}}],[\"当前在一家容器创业公司负责caas产品研发和设计\",{\"1\":{\"0\":1}}],[\"当前所有主机节点的内存使用率\",{\"1\":{\"245\":1}}],[\"当前节点中kubelet的访问地址\",{\"1\":{\"190\":1}}],[\"当前prometheus中remote\",{\"1\":{\"166\":1}}],[\"当前时间窗口内正在收集的样本数据\",{\"1\":{\"159\":1}}],[\"当前实例集群服务监听地址\",{\"1\":{\"149\":1}}],[\"当前alertmanager等待阶段结束后\",{\"1\":{\"148\":1}}],[\"当前的部署结构存在明显的单点故障风险\",{\"1\":{\"147\":1}}],[\"当前面板中会显示当前时间序列中所有样本的平均值\",{\"1\":{\"144\":1}}],[\"当前基础设施资源的使用量\",{\"1\":{\"143\":1}}],[\"当前表达式返回的当前主机cpu使用率的小数表示\",{\"1\":{\"138\":1}}],[\"当前内置了5种类型的面板\",{\"1\":{\"126\":1}}],[\"当前开放的连接\",{\"1\":{\"110\":3}}],[\"当前主机中各个磁盘的读取数据总量的瞬时向量\",{\"1\":{\"358\":1}}],[\"当前主机的内存总量\",{\"1\":{\"105\":1}}],[\"当前主机上容器的运行状态\",{\"1\":{\"105\":1}}],[\"当前http请求发生总次数为12次\",{\"1\":{\"95\":1}}],[\"当前一共发生了2次http请求\",{\"1\":{\"95\":1}}],[\"当前告警状态为pending\",{\"1\":{\"69\":1}}],[\"当前配置文件中定义了一个默认的接收者default\",{\"1\":{\"55\":1}}],[\"当前聊天机器人的头像地址\",{\"1\":{\"48\":1}}],[\"当前group接收到了新的告警\",{\"1\":{\"42\":1}}],[\"当前状态\",{\"0\":{\"143\":1},\"1\":{\"9\":1,\"21\":1,\"31\":2,\"95\":1}}],[\"如counter\",{\"1\":{\"352\":1}}],[\"如ansible\",{\"1\":{\"313\":1}}],[\"如grafana\",{\"1\":{\"295\":1}}],[\"如nagios\",{\"1\":{\"290\":1}}],[\"如nginx\",{\"1\":{\"234\":1}}],[\"如主机的cpu使用率\",{\"1\":{\"285\":1}}],[\"如服务器重启\",{\"1\":{\"238\":1}}],[\"如docker\",{\"1\":{\"179\":1,\"183\":1}}],[\"如上图所示\",{\"1\":{\"156\":1,\"169\":1,\"308\":1}}],[\"如上所示dns记录会返回当前可用的node\",{\"1\":{\"305\":1}}],[\"如上所示\",{\"1\":{\"40\":1,\"123\":1,\"130\":1,\"139\":1,\"144\":1,\"189\":1,\"190\":1,\"313\":1}}],[\"如rate\",{\"1\":{\"129\":1}}],[\"如prometheus\",{\"1\":{\"126\":1}}],[\"如pushover\",{\"1\":{\"43\":1}}],[\"如http\",{\"1\":{\"95\":1,\"100\":1,\"228\":1}}],[\"如html模板\",{\"1\":{\"26\":1}}],[\"如何让这些不同的prometheus\",{\"1\":{\"311\":1}}],[\"如何处理\",{\"1\":{\"308\":1}}],[\"如何使用prometheus\",{\"1\":{\"208\":1}}],[\"如何使用webhook扩展alertmanager\",{\"1\":{\"24\":1}}],[\"如何利用prometheus\",{\"1\":{\"208\":1}}],[\"如何监控和评估mysql服务的运行状态以及如何通过prometheus实现基于网络探测的黑盒监控\",{\"1\":{\"92\":1}}],[\"如何对已有的应用程序扩展prometheus监控支持\",{\"1\":{\"82\":1}}],[\"如何实现自定义的exporter程序\",{\"1\":{\"82\":1}}],[\"如下\",{\"1\":{\"349\":1}}],[\"如下命令\",{\"1\":{\"181\":1}}],[\"如下图所示是nagios监控系统的基本架构\",{\"1\":{\"290\":1}}],[\"如下图所示\",{\"1\":{\"69\":3,\"164\":1,\"190\":1,\"202\":1,\"238\":1,\"283\":1}}],[\"如下所示该标签最终也会保存到从该实例采集的样本数据中\",{\"1\":{\"309\":1}}],[\"如下所示\",{\"1\":{\"30\":1,\"34\":1,\"45\":1,\"48\":1,\"50\":1,\"60\":1,\"68\":1,\"77\":2,\"85\":1,\"89\":1,\"90\":3,\"91\":1,\"101\":1,\"102\":1,\"103\":1,\"105\":1,\"113\":1,\"126\":2,\"128\":1,\"130\":1,\"131\":3,\"133\":1,\"134\":1,\"135\":2,\"138\":4,\"139\":3,\"141\":4,\"142\":3,\"143\":2,\"144\":2,\"147\":3,\"148\":2,\"151\":1,\"159\":1,\"167\":1,\"179\":1,\"181\":2,\"183\":1,\"187\":2,\"189\":1,\"195\":2,\"199\":1,\"201\":1,\"202\":3,\"203\":2,\"207\":1,\"210\":1,\"213\":1,\"214\":3,\"216\":1,\"217\":1,\"221\":1,\"241\":1,\"268\":1,\"269\":1,\"282\":1,\"283\":1,\"286\":1,\"294\":1,\"316\":1,\"317\":1,\"318\":1}}],[\"如slack\",{\"1\":{\"43\":1}}],[\"如\",{\"1\":{\"30\":1,\"206\":1,\"259\":1}}],[\"如全局的smtp配置\",{\"1\":{\"26\":1}}],[\"如果匹配到的数据比较结果为true则保留\",{\"1\":{\"363\":1}}],[\"如果匹配到告警中包含标签team\",{\"1\":{\"42\":1}}],[\"如果比较结果为false则丢弃该样本\",{\"1\":{\"360\":1}}],[\"如果比较结果为true则保留样本\",{\"1\":{\"360\":1}}],[\"如果比较结果为true则保留\",{\"1\":{\"245\":1}}],[\"如果表达式http\",{\"1\":{\"357\":1}}],[\"如果relabel的操作只是为了产生一个临时变量\",{\"1\":{\"312\":1}}],[\"如果resolution的值为1\",{\"1\":{\"126\":1}}],[\"如果让这些prometheus\",{\"1\":{\"311\":1}}],[\"如果为每一个团队单独搭建一个prometheus\",{\"1\":{\"308\":1}}],[\"如果为false时\",{\"1\":{\"169\":1}}],[\"如果prometheus能够正常从node\",{\"1\":{\"287\":1}}],[\"如果prometheus的实例被重新调度\",{\"1\":{\"145\":1}}],[\"如果输入\",{\"1\":{\"287\":1}}],[\"如果描述样本特征的标签\",{\"1\":{\"262\":1}}],[\"如果是在两个标量之间使用布尔运算\",{\"1\":{\"246\":1}}],[\"如果大于等于1000则返回1\",{\"1\":{\"246\":1,\"361\":1}}],[\"如果大多数api请求都维持在100ms的响应时间范围内\",{\"1\":{\"230\":1}}],[\"如果没匹配到任何内容则不对target\",{\"1\":{\"310\":1}}],[\"如果没找到匹配元素\",{\"1\":{\"244\":1,\"245\":1,\"249\":1,\"365\":1}}],[\"如果没有使用ignoring\",{\"1\":{\"250\":1,\"366\":1}}],[\"如果没有则进入下一个阶段\",{\"1\":{\"148\":1}}],[\"如果没有明确的指标类型需要返回为untyped\",{\"1\":{\"116\":1}}],[\"如果基于原有阈值去触发告警\",{\"1\":{\"239\":1}}],[\"如果系统主要受限于磁盘i\",{\"1\":{\"234\":1}}],[\"如果系统主要受内存影响\",{\"1\":{\"234\":1}}],[\"如果不加区分计算这些请求的延迟\",{\"1\":{\"234\":1}}],[\"如果不需要侧边菜单栏\",{\"1\":{\"134\":1}}],[\"如果只需要计算整个应用的http请求总量\",{\"1\":{\"226\":1,\"368\":1}}],[\"如果细心的读者可能会发现\",{\"1\":{\"218\":1}}],[\"如果监控的target对象启用了basicauth认证\",{\"1\":{\"217\":1}}],[\"如果监控指标中还需要定义标签\",{\"1\":{\"89\":1}}],[\"如果查看prometheus配置信息\",{\"1\":{\"218\":1}}],[\"如果查看alerts页面\",{\"1\":{\"213\":1}}],[\"如果查看新建prometheus的pod实例yaml定义\",{\"1\":{\"210\":1}}],[\"如果你希望使用prometheus监控一些其他的资源\",{\"1\":{\"210\":1}}],[\"如果应用程序并没有通过\",{\"1\":{\"207\":1}}],[\"如果创建service的时\",{\"1\":{\"206\":1}}],[\"如果现在查看prometheus的target状态页面\",{\"1\":{\"187\":1}}],[\"如果在集群中部署的应用程序本身内置了对prometheus的监控支持\",{\"1\":{\"184\":1}}],[\"如果在等待时间内\",{\"1\":{\"42\":1}}],[\"如果要构建一个完整的监控体系\",{\"1\":{\"184\":1}}],[\"如果要覆盖默认的告警内容\",{\"1\":{\"49\":1}}],[\"如果升级后服务出现异常\",{\"1\":{\"181\":1}}],[\"如果部署应用程序时\",{\"1\":{\"178\":1}}],[\"如果该url启动了认证则可以通过basic\",{\"1\":{\"165\":1}}],[\"如果该目录下定义了main函数\",{\"1\":{\"150\":1}}],[\"如果本地存储由于某些原因出现了错误\",{\"1\":{\"161\":1}}],[\"如果集群状态未达到预期\",{\"1\":{\"150\":1}}],[\"如果已经发送则中断流水线\",{\"1\":{\"148\":1}}],[\"如果有多个匹配组\",{\"1\":{\"310\":1}}],[\"如果有则返回\",{\"1\":{\"148\":1}}],[\"如果有新的告警级别为severity=critical\",{\"1\":{\"36\":1}}],[\"如果希望servicemonitor可以关联任意命名空间下的标签\",{\"1\":{\"217\":1}}],[\"如果希望能够显示当前时间序列的样本值变化情况\",{\"1\":{\"144\":1}}],[\"如果希望面板能够根据不同的值显示不同的颜色的话\",{\"1\":{\"144\":1}}],[\"如果希望当前图表中的时间序列以不同的形式展示\",{\"1\":{\"138\":1}}],[\"如果cpu达不到预期\",{\"1\":{\"151\":1}}],[\"如果cpu超过50\",{\"1\":{\"138\":1}}],[\"如果continue为true\",{\"1\":{\"41\":1}}],[\"如果参数expr和name均是list类型\",{\"1\":{\"135\":1}}],[\"如果我们只希望采集数据中心dc1中的node\",{\"1\":{\"311\":1}}],[\"如果我们只需要查询所有http\",{\"1\":{\"259\":1}}],[\"如果我们可能还需要\",{\"1\":{\"308\":1}}],[\"如果我们想根据node\",{\"1\":{\"244\":1}}],[\"如果我们想要监控kube\",{\"1\":{\"202\":1}}],[\"如果我们希望集群内的应用程序\",{\"1\":{\"206\":1}}],[\"如果我们希望console\",{\"1\":{\"134\":1}}],[\"如果我们刷新浏览器可以看到以下内容\",{\"1\":{\"134\":1}}],[\"如果变量启用了multi\",{\"1\":{\"131\":1}}],[\"如果允许用户多选在promql表达式中应该使用标签的正则匹配模式\",{\"1\":{\"130\":1}}],[\"如果以prometheus作为数据源\",{\"1\":{\"123\":1}}],[\"如果innodb\",{\"1\":{\"111\":1}}],[\"如果一个客户端尝试连接至mysql\",{\"1\":{\"110\":1}}],[\"如果想查询多个环节下的时间序列序列可以使用如下表达式\",{\"1\":{\"259\":1}}],[\"如果想减少本地磁盘的容量需求\",{\"1\":{\"160\":1}}],[\"如果想永久化设置\",{\"1\":{\"110\":1}}],[\"如果想设置发送告警通知之前要等待时间\",{\"1\":{\"41\":1}}],[\"如果状态码为2xx\",{\"1\":{\"103\":1,\"318\":1}}],[\"如果http服务启用了安全认证\",{\"1\":{\"102\":1,\"317\":1}}],[\"如果需要覆盖默认的buckets\",{\"1\":{\"352\":1}}],[\"如果需要计算中位数φ取值为0\",{\"1\":{\"240\":1}}],[\"如果需要对nginx实例进行扩展\",{\"1\":{\"181\":1}}],[\"如果需要对prometheus\",{\"1\":{\"160\":1}}],[\"如果需要在graph中显示histogram类型的监控指标\",{\"1\":{\"139\":1}}],[\"如果需要定制化菜单的内容\",{\"1\":{\"134\":1}}],[\"如果需要指定自定义的桶分布\",{\"1\":{\"90\":1}}],[\"如果需要将这些标签反应到样本上\",{\"1\":{\"85\":1}}],[\"如果用户部署的应用程序内置了对prometheus的支持\",{\"1\":{\"180\":1}}],[\"如果用户为该图表自定义了alert\",{\"1\":{\"138\":1}}],[\"如果用户需要指定http返回状态码\",{\"1\":{\"103\":1,\"318\":1}}],[\"如果用户使用了gradle构建项目\",{\"1\":{\"86\":1}}],[\"如果用户想定义自己的告警计算周期\",{\"1\":{\"66\":1}}],[\"如果使用gradle作为项目构建工具\",{\"1\":{\"85\":1}}],[\"如果1分钟后告警条件持续满足\",{\"1\":{\"69\":1}}],[\"如果接收到的告警符合静默的配置\",{\"1\":{\"64\":1}}],[\"如果满足promql定义的规则\",{\"1\":{\"278\":1}}],[\"如果满足告警触发条件就会向alertmanager发送告警信息\",{\"1\":{\"60\":1}}],[\"如果满足group\",{\"1\":{\"42\":1}}],[\"如果所有的邮件配置使用了相同的smtp配置\",{\"1\":{\"50\":1}}],[\"如果当前行以\",{\"1\":{\"116\":2}}],[\"如果当前收件人需要接受告警恢复的通知的话\",{\"1\":{\"50\":1}}],[\"如果当前告警匹配不到任何的子节点\",{\"1\":{\"41\":1}}],[\"如果告警中包含service标签\",{\"1\":{\"42\":1}}],[\"如果告警时来源于数据库服务如mysql或者cassandra\",{\"1\":{\"42\":1}}],[\"如果警报已经成功发送通知\",{\"1\":{\"41\":1}}],[\"如果新的告警通知满足静默规则的设置\",{\"1\":{\"37\":1,\"39\":1}}],[\"如果对于标签这个词\",{\"1\":{\"4\":1}}],[\"如果标注了英文\",{\"1\":{\"4\":1}}],[\"理解和掌握promql是prometheus入门的第一课\",{\"1\":{\"258\":1}}],[\"理解kubernetes的工作机制\",{\"1\":{\"171\":1}}],[\"理解alertmanager特性\",{\"1\":{\"24\":1}}],[\"理解时间序列\",{\"0\":{\"267\":1},\"1\":{\"8\":1,\"20\":1}}],[\"理解时间序列小节\",{\"1\":{\"3\":1}}],[\"vs\",{\"0\":{\"323\":1,\"328\":1,\"333\":1,\"338\":1,\"342\":1},\"1\":{\"313\":1}}],[\"vendor=\",{\"1\":{\"349\":1}}],[\"vector2\",{\"1\":{\"247\":3,\"250\":1,\"364\":3,\"366\":1}}],[\"vector1\",{\"1\":{\"247\":3,\"250\":1,\"364\":3,\"366\":1}}],[\"vector\",{\"1\":{\"213\":1,\"238\":3,\"239\":1,\"240\":1,\"241\":2,\"255\":1,\"256\":2,\"268\":1}}],[\"verify为true即可\",{\"1\":{\"199\":1}}],[\"verify\",{\"1\":{\"195\":1,\"199\":1,\"200\":1}}],[\"verbs\",{\"1\":{\"186\":3,\"219\":3}}],[\"very\",{\"1\":{\"48\":1}}],[\"versioninfoexports\",{\"1\":{\"350\":1}}],[\"version=\",{\"1\":{\"349\":1}}],[\"version=2\",{\"1\":{\"273\":1}}],[\"version=0\",{\"1\":{\"54\":1,\"117\":1}}],[\"versions\",{\"1\":{\"103\":1,\"318\":1}}],[\"versions和valid\",{\"1\":{\"103\":1,\"318\":1}}],[\"version\",{\"1\":{\"27\":1,\"28\":2,\"99\":4,\"103\":1,\"105\":7,\"108\":1,\"167\":3,\"187\":2,\"273\":2,\"305\":2,\"318\":1,\"349\":1}}],[\"vim\",{\"1\":{\"374\":1}}],[\"virtual\",{\"1\":{\"188\":4,\"201\":4,\"205\":4}}],[\"victorops\",{\"1\":{\"26\":3,\"43\":2}}],[\"vm\",{\"1\":{\"181\":2,\"396\":1}}],[\"v\",{\"1\":{\"157\":3,\"238\":3,\"239\":1,\"241\":2,\"268\":1,\"274\":1,\"396\":1}}],[\"v5\",{\"1\":{\"140\":1}}],[\"v5版本以后更推荐使用heatmap面板的方式展示histogram样本数据\",{\"1\":{\"139\":1}}],[\"v4\",{\"1\":{\"140\":1}}],[\"v3\",{\"1\":{\"105\":1}}],[\"v0\",{\"1\":{\"105\":1,\"285\":1,\"373\":1}}],[\"volume\",{\"1\":{\"214\":2,\"400\":1}}],[\"volumes\",{\"1\":{\"175\":1,\"187\":1,\"189\":1,\"210\":1}}],[\"volumemounts\",{\"1\":{\"175\":1}}],[\"volume=\",{\"1\":{\"105\":4}}],[\"void\",{\"1\":{\"86\":1,\"89\":2,\"90\":3,\"91\":1,\"93\":2,\"94\":2,\"95\":4,\"96\":1,\"349\":1,\"350\":2,\"352\":4}}],[\"v1访问\",{\"1\":{\"252\":1}}],[\"v1beta1\",{\"1\":{\"175\":1,\"181\":1,\"186\":2,\"195\":1,\"201\":1,\"203\":1,\"205\":1,\"219\":2}}],[\"v1\",{\"1\":{\"85\":2,\"86\":2,\"150\":3,\"174\":1,\"175\":1,\"181\":2,\"186\":1,\"187\":2,\"190\":3,\"195\":1,\"199\":2,\"200\":1,\"203\":1,\"205\":1,\"206\":2,\"207\":1,\"210\":1,\"213\":2,\"214\":2,\"216\":1,\"217\":5,\"218\":2,\"219\":2,\"254\":2,\"255\":2,\"257\":2,\"305\":3}}],[\"validate\",{\"1\":{\"199\":1,\"314\":3}}],[\"valid\",{\"1\":{\"72\":1,\"103\":3,\"314\":2,\"318\":3}}],[\"value形式的标签组成\",{\"1\":{\"325\":1}}],[\"value2\",{\"1\":{\"294\":2}}],[\"value1\",{\"1\":{\"294\":2}}],[\"value只包含一个唯一的样本\",{\"1\":{\"256\":1}}],[\"value>\",{\"1\":{\"256\":6,\"269\":1}}],[\"value或者include\",{\"1\":{\"131\":1}}],[\"value是一个float格式的数据\",{\"1\":{\"116\":1}}],[\"valueof\",{\"1\":{\"95\":4,\"350\":1}}],[\"value\",{\"1\":{\"67\":2,\"69\":2,\"105\":2,\"109\":2,\"110\":2,\"111\":3,\"112\":2,\"116\":3,\"135\":5,\"144\":2,\"149\":1,\"151\":2,\"166\":2,\"255\":2,\"256\":1,\"268\":2,\"310\":3}}],[\"values包含当前事件序列的一组样本\",{\"1\":{\"256\":1}}],[\"values会为每一个唯一的样本值输出一个时间序列\",{\"1\":{\"226\":1,\"368\":1}}],[\"values用于时间序列中每一个样本值出现的次数\",{\"1\":{\"226\":1,\"368\":1}}],[\"values中可以设置是否显示当前时间序列的最小值\",{\"1\":{\"138\":1}}],[\"values函数\",{\"1\":{\"131\":1}}],[\"values\",{\"1\":{\"67\":1,\"130\":3,\"131\":1,\"226\":3,\"256\":1,\"257\":2,\"310\":3,\"368\":3}}],[\"variables\",{\"1\":{\"110\":3,\"112\":1,\"123\":1,\"128\":1}}],[\"variable\",{\"1\":{\"109\":2,\"110\":2,\"111\":3,\"112\":2}}],[\"var\",{\"1\":{\"28\":1,\"31\":1,\"33\":1,\"105\":4,\"166\":1,\"186\":2,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2}}],[\"v$version\",{\"1\":{\"54\":1,\"273\":1}}],[\"v2\",{\"1\":{\"26\":1,\"85\":1,\"86\":1,\"175\":1}}],[\"v=lrftpnzq3kw\",{\"1\":{\"17\":1}}],[\"vulcan\",{\"1\":{\"16\":1}}],[\"1d844bce06a7\",{\"1\":{\"305\":1}}],[\"1d\",{\"1\":{\"261\":2}}],[\"1434417561287\",{\"1\":{\"268\":3}}],[\"1434417560938\",{\"1\":{\"268\":3}}],[\"1435781460\",{\"1\":{\"257\":2}}],[\"1435781445\",{\"1\":{\"257\":2}}],[\"1435781430\",{\"1\":{\"257\":2}}],[\"1435781451\",{\"1\":{\"255\":2}}],[\"144\",{\"1\":{\"203\":1}}],[\"144320\",{\"1\":{\"116\":2}}],[\"14s\",{\"1\":{\"187\":1}}],[\"14\",{\"1\":{\"151\":6,\"273\":6}}],[\"1表示健康\",{\"1\":{\"144\":1}}],[\"1版本中heatmap完善了对prometheus的支持\",{\"1\":{\"140\":1}}],[\"172\",{\"1\":{\"310\":1}}],[\"175\",{\"1\":{\"251\":1,\"367\":1}}],[\"1744384\",{\"1\":{\"244\":1,\"358\":1}}],[\"17\",{\"1\":{\"105\":1,\"117\":1}}],[\"1e567c2\",{\"1\":{\"105\":1}}],[\"19s\",{\"1\":{\"223\":1}}],[\"1984896e+08\",{\"1\":{\"201\":1,\"205\":1}}],[\"196kib\",{\"1\":{\"104\":1}}],[\"192\",{\"1\":{\"57\":1,\"58\":1,\"169\":3,\"181\":1,\"187\":3,\"189\":3,\"199\":2,\"201\":2,\"203\":1,\"205\":2,\"206\":4,\"207\":3,\"280\":1,\"375\":1,\"378\":1}}],[\"133d\",{\"1\":{\"192\":2}}],[\"131d\",{\"1\":{\"175\":1,\"181\":3}}],[\"1326\",{\"1\":{\"109\":1}}],[\"13\",{\"1\":{\"95\":1,\"187\":1}}],[\"130860\",{\"1\":{\"16\":1}}],[\"188\",{\"1\":{\"150\":3,\"151\":3}}],[\"18\",{\"1\":{\"93\":1}}],[\"189xxxx8325\",{\"1\":{\"30\":1}}],[\"11e8\",{\"1\":{\"207\":1}}],[\"112\",{\"1\":{\"181\":1}}],[\"117332275\",{\"1\":{\"99\":1}}],[\"11\",{\"1\":{\"93\":1,\"151\":21,\"169\":2,\"257\":1}}],[\"1s\",{\"1\":{\"67\":1}}],[\"1m\",{\"1\":{\"66\":1,\"69\":2,\"72\":1,\"106\":5,\"116\":1,\"151\":2,\"181\":4,\"216\":2,\"217\":3,\"267\":1,\"286\":1,\"307\":1}}],[\"1h\",{\"1\":{\"55\":1,\"229\":1}}],[\"109\",{\"1\":{\"203\":1}}],[\"10250\",{\"1\":{\"187\":1,\"189\":1,\"199\":1}}],[\"102400\",{\"1\":{\"230\":1}}],[\"1024的对数\",{\"1\":{\"142\":1}}],[\"1024\",{\"1\":{\"142\":1,\"244\":2}}],[\"103\",{\"1\":{\"181\":1}}],[\"104\",{\"1\":{\"181\":1}}],[\"105\",{\"1\":{\"181\":1}}],[\"101\",{\"1\":{\"175\":1}}],[\"1016\",{\"1\":{\"109\":1}}],[\"1000\",{\"1\":{\"246\":1,\"360\":1,\"378\":1}}],[\"100的地址信息\",{\"1\":{\"199\":1}}],[\"100\",{\"1\":{\"151\":2,\"181\":1,\"187\":3,\"189\":3,\"199\":2,\"201\":2,\"205\":2,\"206\":5,\"207\":3,\"230\":1,\"236\":1,\"248\":1,\"360\":1,\"361\":1,\"369\":1,\"396\":1}}],[\"100392\",{\"1\":{\"116\":1}}],[\"10的对数\",{\"1\":{\"142\":1}}],[\"107670803000001\",{\"1\":{\"95\":2}}],[\"10\",{\"1\":{\"57\":1,\"58\":1,\"90\":1,\"95\":3,\"105\":1,\"109\":1,\"112\":1,\"126\":1,\"130\":4,\"142\":1,\"150\":16,\"175\":2,\"181\":5,\"192\":2,\"202\":2,\"203\":1,\"206\":1,\"228\":1,\"255\":2,\"257\":1,\"264\":1,\"273\":6,\"280\":1,\"305\":1,\"352\":1,\"375\":1,\"378\":1}}],[\"10m\",{\"1\":{\"51\":1,\"66\":1,\"67\":1}}],[\"10s\",{\"1\":{\"42\":1,\"55\":2,\"105\":8,\"151\":1,\"181\":1,\"210\":3,\"214\":1,\"218\":2,\"273\":1,\"307\":1}}],[\"126\",{\"1\":{\"360\":1}}],[\"120\",{\"1\":{\"238\":1,\"250\":2,\"251\":2,\"366\":2,\"367\":2}}],[\"12t03\",{\"1\":{\"151\":3}}],[\"12t02\",{\"1\":{\"150\":7}}],[\"125\",{\"1\":{\"150\":1}}],[\"128\",{\"1\":{\"139\":1}}],[\"12\",{\"1\":{\"95\":1,\"150\":1,\"151\":1,\"169\":1,\"218\":1}}],[\"121\",{\"1\":{\"93\":1}}],[\"1234\",{\"1\":{\"86\":3,\"87\":1,\"166\":1,\"349\":2}}],[\"1234|click\",{\"1\":{\"48\":1}}],[\"12h\",{\"1\":{\"51\":1,\"214\":1}}],[\"127\",{\"1\":{\"40\":1,\"55\":1,\"69\":2,\"86\":2,\"87\":1,\"91\":1,\"99\":1,\"100\":3,\"149\":2,\"150\":4,\"151\":8,\"178\":1,\"188\":1,\"305\":16}}],[\"1\",{\"1\":{\"40\":1,\"55\":1,\"67\":1,\"69\":2,\"85\":1,\"86\":2,\"87\":1,\"89\":1,\"90\":3,\"91\":1,\"95\":4,\"96\":1,\"99\":4,\"100\":3,\"103\":2,\"104\":1,\"105\":3,\"108\":1,\"109\":3,\"110\":3,\"111\":3,\"112\":2,\"116\":2,\"117\":2,\"127\":1,\"128\":1,\"134\":2,\"135\":1,\"138\":2,\"139\":1,\"142\":1,\"144\":1,\"149\":3,\"150\":6,\"151\":8,\"156\":1,\"159\":1,\"166\":5,\"167\":5,\"175\":5,\"178\":1,\"181\":19,\"186\":4,\"187\":5,\"188\":3,\"190\":1,\"192\":1,\"195\":2,\"197\":1,\"199\":2,\"200\":1,\"201\":9,\"202\":1,\"203\":4,\"205\":9,\"206\":3,\"207\":1,\"213\":1,\"214\":1,\"216\":6,\"218\":3,\"223\":2,\"226\":1,\"230\":2,\"240\":2,\"241\":7,\"246\":1,\"248\":1,\"255\":1,\"257\":4,\"260\":6,\"273\":2,\"280\":1,\"282\":1,\"287\":3,\"290\":1,\"305\":22,\"310\":1,\"318\":2,\"349\":2,\"352\":3,\"357\":2,\"361\":1,\"363\":2,\"368\":1,\"369\":1,\"373\":6,\"397\":1}}],[\"1540798e+09\",{\"1\":{\"230\":1}}],[\"15t12\",{\"1\":{\"218\":1}}],[\"15d\",{\"1\":{\"160\":1}}],[\"15s\",{\"1\":{\"151\":2,\"169\":1,\"174\":2,\"187\":2,\"190\":2,\"201\":1,\"205\":1,\"273\":2,\"307\":2,\"377\":1}}],[\"1518145642\",{\"1\":{\"357\":4}}],[\"1518146427\",{\"1\":{\"244\":4,\"358\":10}}],[\"1518096837\",{\"1\":{\"260\":2}}],[\"1518096832\",{\"1\":{\"260\":2}}],[\"1518096827\",{\"1\":{\"260\":2}}],[\"1518096822\",{\"1\":{\"260\":2}}],[\"1518096817\",{\"1\":{\"260\":2}}],[\"1518096812\",{\"1\":{\"259\":2,\"260\":2}}],[\"151\",{\"1\":{\"110\":1}}],[\"15535a1e09b3a307b46d90400423d5b262ec84dc55b91ca9e7dd886f4f764ab3\",{\"1\":{\"105\":1}}],[\"15\",{\"1\":{\"31\":1,\"51\":3,\"54\":1,\"130\":4,\"151\":9,\"192\":1,\"202\":1,\"273\":2,\"285\":5,\"305\":2,\"373\":6}}],[\"156xxxx8827\",{\"1\":{\"30\":1}}],[\"166d\",{\"1\":{\"202\":2}}],[\"1649622016e+10\",{\"1\":{\"188\":1}}],[\"164d\",{\"1\":{\"187\":1}}],[\"1600\",{\"1\":{\"230\":1}}],[\"160\",{\"1\":{\"181\":1}}],[\"168\",{\"1\":{\"57\":1,\"58\":1,\"169\":3,\"181\":2,\"187\":3,\"189\":3,\"199\":3,\"201\":2,\"205\":2,\"206\":5,\"207\":3,\"280\":1,\"375\":1,\"378\":1,\"396\":2}}],[\"16\",{\"1\":{\"13\":1,\"139\":1}}],[\"federation\",{\"1\":{\"297\":1}}],[\"federate\",{\"1\":{\"156\":1,\"169\":4,\"357\":2}}],[\"f77fc78b6\",{\"1\":{\"203\":1}}],[\"full\",{\"1\":{\"150\":2}}],[\"function\",{\"1\":{\"135\":1}}],[\"func\",{\"1\":{\"28\":2,\"31\":1,\"32\":1,\"33\":3,\"166\":2}}],[\"f\",{\"1\":{\"150\":2,\"151\":1,\"166\":1,\"174\":1,\"175\":1,\"181\":2,\"186\":2,\"187\":1,\"195\":1,\"201\":1,\"205\":1,\"210\":1,\"213\":1,\"214\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":2,\"223\":1,\"393\":8,\"400\":1}}],[\"float\",{\"1\":{\"240\":1}}],[\"flush\",{\"1\":{\"350\":2}}],[\"fluid\",{\"1\":{\"134\":1}}],[\"fluentd\",{\"1\":{\"114\":1}}],[\"flags\",{\"1\":{\"305\":2}}],[\"flag\",{\"1\":{\"33\":5}}],[\"fragment\",{\"1\":{\"319\":1}}],[\"fraction\",{\"1\":{\"167\":1}}],[\"frees\",{\"1\":{\"167\":1}}],[\"free\",{\"1\":{\"111\":2,\"229\":1,\"239\":1,\"244\":3,\"245\":2}}],[\"frontend\",{\"1\":{\"42\":2,\"213\":1,\"214\":1,\"217\":2,\"218\":1,\"219\":1}}],[\"from>\",{\"1\":{\"50\":1}}],[\"from\",{\"1\":{\"26\":1,\"45\":1,\"48\":1,\"50\":2,\"109\":1,\"111\":2,\"112\":1,\"214\":1,\"273\":1,\"310\":1}}],[\"fsync操作的总次数为216次\",{\"1\":{\"230\":1}}],[\"fsync处理的处理时间\",{\"1\":{\"230\":1}}],[\"fsync\",{\"1\":{\"230\":9}}],[\"fs\",{\"1\":{\"105\":4,\"106\":2}}],[\"f51fd4d4f410965d3a0fd7e9f3250218911c1505e12960fb6dd7b889e75fc114\",{\"1\":{\"105\":1}}],[\"fabxc\",{\"1\":{\"217\":1}}],[\"fail\",{\"1\":{\"103\":6,\"314\":6,\"318\":6}}],[\"failed\",{\"1\":{\"99\":4,\"214\":1,\"218\":1}}],[\"false>\",{\"1\":{\"321\":2}}],[\"false\",{\"1\":{\"30\":2,\"31\":1,\"33\":1,\"40\":1,\"49\":2,\"50\":1,\"51\":2,\"93\":1,\"103\":3,\"160\":1,\"165\":1,\"195\":1,\"246\":1,\"305\":5,\"318\":3,\"319\":1,\"350\":1,\"361\":1,\"362\":1}}],[\"four\",{\"1\":{\"234\":1}}],[\"found\",{\"1\":{\"214\":1,\"305\":1}}],[\"follow\",{\"1\":{\"103\":1,\"318\":1}}],[\"foo\",{\"1\":{\"85\":1,\"86\":1,\"130\":3,\"351\":1}}],[\"footer\",{\"1\":{\"49\":2}}],[\"forbidden\",{\"1\":{\"218\":1}}],[\"forward访问任意pod实例\",{\"1\":{\"217\":1}}],[\"forward访问prometheus实例\",{\"1\":{\"216\":1}}],[\"forward将alertmanager映射到本地\",{\"1\":{\"214\":1}}],[\"forward\",{\"1\":{\"210\":1,\"214\":1,\"216\":1,\"217\":1}}],[\"forward在本地访问新建的prometheus实例\",{\"1\":{\"210\":1}}],[\"format方式为time\",{\"1\":{\"142\":1}}],[\"format需要定义为time\",{\"1\":{\"141\":1}}],[\"format模板则将会控制y轴中的显示内容\",{\"1\":{\"141\":1}}],[\"format模板化图例\",{\"1\":{\"138\":1}}],[\"format为\",{\"1\":{\"138\":1}}],[\"formatter\",{\"1\":{\"135\":2}}],[\"format用于控制如何格式化每条时间序列的图例信息\",{\"1\":{\"126\":1}}],[\"format\",{\"1\":{\"31\":1,\"51\":3,\"77\":1,\"116\":1,\"126\":1}}],[\"for\",{\"1\":{\"16\":1,\"31\":1,\"48\":1,\"51\":1,\"66\":2,\"67\":6,\"69\":2,\"99\":2,\"103\":1,\"134\":1,\"135\":2,\"151\":2,\"160\":1,\"166\":3,\"199\":1,\"214\":1,\"273\":1,\"310\":2,\"318\":1,\"321\":1,\"350\":1}}],[\"finish\",{\"1\":{\"350\":1}}],[\"finaly\",{\"1\":{\"116\":1}}],[\"finally\",{\"1\":{\"90\":1,\"352\":2}}],[\"final\",{\"1\":{\"89\":2,\"90\":5,\"95\":4,\"99\":1,\"103\":1,\"230\":1,\"318\":1,\"350\":3,\"351\":1,\"352\":6}}],[\"filteredmetricfamilysamples\",{\"1\":{\"350\":1}}],[\"filename=prometheus\",{\"1\":{\"273\":2}}],[\"file指定令牌文件\",{\"1\":{\"102\":1,\"317\":1}}],[\"file=alertmanager\",{\"1\":{\"214\":1}}],[\"file=\",{\"1\":{\"99\":1,\"106\":1,\"108\":1,\"149\":2,\"150\":4,\"151\":2,\"175\":1,\"307\":1}}],[\"file\",{\"1\":{\"72\":1,\"102\":1,\"150\":1,\"165\":4,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"273\":2,\"307\":6,\"312\":2,\"317\":1}}],[\"file用于指定alertmanager配置文件路径\",{\"1\":{\"56\":1}}],[\"filesystem\",{\"1\":{\"229\":1,\"239\":1,\"286\":1}}],[\"files定义recoding\",{\"1\":{\"72\":1}}],[\"files\",{\"1\":{\"45\":1,\"66\":2,\"69\":1,\"72\":1,\"151\":1,\"181\":1,\"218\":1,\"273\":1,\"307\":2,\"312\":1}}],[\"field\",{\"1\":{\"253\":1}}],[\"first\",{\"1\":{\"230\":1,\"273\":1}}],[\"firing\",{\"1\":{\"49\":2,\"51\":1,\"67\":2,\"150\":2,\"151\":2}}],[\"fix\",{\"1\":{\"5\":1,\"118\":1,\"119\":1}}],[\"fixed\",{\"1\":{\"1\":1}}],[\"fmt\",{\"1\":{\"31\":6,\"32\":3,\"166\":3}}],[\"rf\",{\"1\":{\"373\":1}}],[\"rm\",{\"1\":{\"373\":1}}],[\"rrs\",{\"1\":{\"314\":3}}],[\"rcodes\",{\"1\":{\"314\":1}}],[\"rcvd\",{\"1\":{\"305\":1}}],[\"rd\",{\"1\":{\"305\":1}}],[\"rsyslog等等\",{\"1\":{\"298\":1}}],[\"right\",{\"1\":{\"251\":2,\"367\":2}}],[\"right来确定哪一个向量具有更高的基数\",{\"1\":{\"251\":1,\"367\":1}}],[\"rickshaw\",{\"1\":{\"135\":1}}],[\"rbd\",{\"0\":{\"396\":1}}],[\"rbrs2\",{\"1\":{\"187\":4}}],[\"rbacenable=true\",{\"1\":{\"397\":1}}],[\"rbac\",{\"1\":{\"186\":5,\"219\":7,\"223\":2,\"393\":1}}],[\"rkt\",{\"1\":{\"179\":1,\"183\":1}}],[\"r\",{\"1\":{\"166\":2}}],[\"rpc\",{\"1\":{\"116\":8}}],[\"rw\",{\"1\":{\"105\":1}}],[\"rails的dashboard解决方案promdash\",{\"1\":{\"299\":1}}],[\"rabbitmq\",{\"1\":{\"114\":1,\"298\":1}}],[\"rate5m中只包含一个标签method\",{\"1\":{\"251\":1,\"367\":1}}],[\"rate5m包含两个标签method和code\",{\"1\":{\"251\":1,\"367\":1}}],[\"rate5m\",{\"1\":{\"250\":10,\"251\":2,\"366\":10,\"367\":2}}],[\"rate函数可以直接计算区间向量v在时间窗口内平均增长速率\",{\"1\":{\"238\":1}}],[\"rate<\",{\"1\":{\"135\":1}}],[\"rate\",{\"1\":{\"95\":3,\"106\":4,\"109\":2,\"111\":1,\"112\":1,\"135\":2,\"228\":1,\"238\":1,\"282\":3}}],[\"range查询promql表达式当前或者一定时间范围内的计算结果\",{\"1\":{\"254\":1}}],[\"ranges\",{\"1\":{\"164\":1}}],[\"range\",{\"1\":{\"31\":1,\"51\":2,\"141\":1,\"144\":1,\"160\":2,\"166\":3,\"230\":17,\"238\":3,\"239\":1,\"246\":1,\"257\":5,\"361\":1}}],[\"ram\",{\"1\":{\"16\":1}}],[\"rust等\",{\"1\":{\"114\":1}}],[\"ruby\",{\"1\":{\"114\":1,\"298\":1,\"347\":1}}],[\"runc等提供容器运行时环境\",{\"1\":{\"179\":1,\"183\":1}}],[\"runtime=\",{\"1\":{\"349\":1}}],[\"runtime\",{\"1\":{\"179\":1,\"183\":1,\"187\":1,\"218\":1,\"349\":1}}],[\"runs\",{\"1\":{\"139\":1}}],[\"running\",{\"1\":{\"110\":1,\"150\":2,\"175\":1,\"181\":6,\"186\":1,\"187\":2,\"201\":1,\"203\":1,\"205\":1,\"206\":1,\"214\":3,\"216\":2,\"217\":3,\"223\":1,\"305\":1}}],[\"running可以查看当前mysql实例的连接情况\",{\"1\":{\"110\":1}}],[\"runnable\",{\"1\":{\"90\":1}}],[\"run\",{\"0\":{\"400\":1},\"1\":{\"28\":1,\"90\":1,\"93\":2,\"96\":1,\"104\":1,\"105\":3,\"150\":1,\"186\":2,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"274\":1,\"283\":1,\"396\":1}}],[\"rulefiles\",{\"1\":{\"218\":1}}],[\"rule规则文件的访问路径\",{\"1\":{\"72\":1}}],[\"rule规则支持这种后台计算的方式\",{\"1\":{\"71\":1}}],[\"rule\",{\"1\":{\"66\":3,\"69\":1,\"72\":2,\"151\":1,\"213\":2,\"218\":1,\"273\":1}}],[\"rule>\",{\"1\":{\"26\":1,\"36\":1}}],[\"ruleselector\",{\"1\":{\"213\":1,\"214\":1}}],[\"rules可以查看当前以加载的规则文件\",{\"1\":{\"69\":1}}],[\"rules内容如下\",{\"1\":{\"69\":1}}],[\"rules定义一组告警的抑制规则\",{\"1\":{\"36\":1}}],[\"rules\",{\"0\":{\"72\":1},\"1\":{\"26\":2,\"36\":1,\"51\":1,\"55\":1,\"66\":1,\"67\":1,\"69\":4,\"72\":3,\"151\":5,\"186\":1,\"213\":6,\"214\":1,\"218\":1,\"219\":1,\"273\":4}}],[\"rules优化性能\",{\"0\":{\"71\":1},\"1\":{\"8\":1,\"20\":1}}],[\"refresh\",{\"1\":{\"307\":1}}],[\"references\",{\"1\":{\"75\":1}}],[\"red方法可以有效的帮助用户衡量云原生以及微服务应用下的用户体验问题\",{\"1\":{\"235\":1}}],[\"red方法是weave\",{\"1\":{\"235\":1}}],[\"red方法\",{\"0\":{\"235\":1}}],[\"redis\",{\"1\":{\"114\":1,\"115\":1,\"298\":1}}],[\"redirect\",{\"1\":{\"99\":1,\"103\":1,\"318\":1}}],[\"redirects\",{\"1\":{\"99\":5,\"103\":1,\"318\":1}}],[\"rethinkdb\",{\"1\":{\"298\":1}}],[\"retain\",{\"1\":{\"160\":1}}],[\"retention\",{\"1\":{\"159\":1,\"160\":3,\"167\":1}}],[\"returns\",{\"1\":{\"99\":3}}],[\"return\",{\"1\":{\"28\":1,\"31\":1,\"32\":5,\"33\":1,\"85\":2,\"94\":1,\"95\":1,\"96\":1,\"135\":1,\"166\":3,\"350\":1,\"351\":1}}],[\"remote\",{\"0\":{\"163\":1,\"164\":1},\"1\":{\"154\":1,\"162\":2,\"163\":1,\"164\":1,\"165\":5,\"166\":1,\"167\":5}}],[\"renderer\",{\"1\":{\"135\":1}}],[\"render\",{\"1\":{\"135\":1}}],[\"revision\",{\"1\":{\"105\":1,\"207\":1}}],[\"repo\",{\"1\":{\"397\":1}}],[\"repalce操作允许用户根据target的metadata标签重写或者写入新的标签键值对\",{\"1\":{\"310\":1}}],[\"replica\",{\"1\":{\"218\":2}}],[\"replicas=4\",{\"1\":{\"181\":1}}],[\"replicas\",{\"1\":{\"175\":1,\"181\":1,\"186\":1,\"195\":1,\"203\":1,\"214\":1,\"217\":1}}],[\"replace行为会根据regex的配置匹配source\",{\"1\":{\"310\":1}}],[\"replace和label\",{\"1\":{\"241\":1}}],[\"replace以外\",{\"1\":{\"241\":1}}],[\"replace的具体参数如下\",{\"1\":{\"241\":1}}],[\"replace标签为时间序列添加额外的标签\",{\"1\":{\"241\":1}}],[\"replace\",{\"1\":{\"130\":1,\"190\":2,\"201\":4,\"207\":5,\"218\":7,\"241\":2,\"310\":5}}],[\"replacement\",{\"1\":{\"100\":1,\"190\":4,\"192\":1,\"196\":1,\"197\":2,\"199\":2,\"200\":3,\"201\":1,\"202\":1,\"203\":4,\"207\":1,\"214\":2,\"218\":10,\"241\":1,\"310\":2}}],[\"representation\",{\"1\":{\"116\":2}}],[\"repeated\",{\"1\":{\"166\":5}}],[\"repeat选项设置完成后\",{\"1\":{\"131\":1}}],[\"repeat\",{\"1\":{\"40\":1,\"42\":1,\"51\":1,\"55\":1,\"131\":1,\"214\":1}}],[\"regular\",{\"1\":{\"310\":3}}],[\"regexp\",{\"1\":{\"103\":2,\"314\":6,\"318\":2}}],[\"regexp用户可以定义一组正则表达式\",{\"1\":{\"103\":1,\"318\":1}}],[\"regexp和fail\",{\"1\":{\"103\":1,\"318\":1}}],[\"regex\",{\"1\":{\"99\":4,\"130\":2,\"156\":1,\"190\":4,\"192\":1,\"196\":2,\"197\":3,\"199\":4,\"200\":4,\"201\":4,\"202\":1,\"203\":7,\"207\":6,\"214\":2,\"218\":10,\"241\":1,\"310\":7,\"311\":1,\"312\":1}}],[\"registration\",{\"1\":{\"351\":1}}],[\"registry\",{\"1\":{\"91\":2,\"94\":2,\"350\":2}}],[\"registoer\",{\"1\":{\"89\":1}}],[\"register\",{\"1\":{\"86\":2,\"89\":2,\"90\":5,\"95\":4,\"96\":1,\"350\":7,\"351\":1,\"352\":6}}],[\"recursion\",{\"1\":{\"305\":1}}],[\"recent\",{\"1\":{\"165\":1}}],[\"received\",{\"1\":{\"150\":3,\"151\":3}}],[\"receivedbytes\",{\"1\":{\"90\":2,\"352\":4}}],[\"receive\",{\"1\":{\"28\":1,\"105\":1,\"106\":1,\"166\":1,\"273\":1}}],[\"receiver由于这里没有设置接收方式\",{\"1\":{\"55\":1}}],[\"receiver中\",{\"1\":{\"50\":1}}],[\"receiver添加webhook配置\",{\"1\":{\"34\":1}}],[\"receiver`\",{\"1\":{\"28\":1}}],[\"receiver\",{\"1\":{\"27\":1,\"28\":1,\"34\":1,\"40\":2,\"42\":5,\"50\":3,\"51\":1,\"55\":3,\"150\":5,\"151\":2,\"214\":1}}],[\"receivers\",{\"1\":{\"26\":2,\"34\":1,\"40\":1,\"43\":1,\"45\":2,\"49\":1,\"50\":1,\"51\":1,\"55\":2,\"150\":1,\"214\":1}}],[\"recorded\",{\"1\":{\"72\":1}}],[\"record\",{\"1\":{\"72\":3}}],[\"releases\",{\"1\":{\"54\":1,\"273\":1,\"285\":1,\"373\":1}}],[\"relabel\",{\"1\":{\"23\":2,\"100\":1,\"156\":1,\"165\":1,\"190\":2,\"192\":1,\"196\":1,\"197\":1,\"199\":3,\"200\":2,\"201\":1,\"202\":1,\"203\":2,\"207\":2,\"214\":1,\"218\":2,\"310\":3,\"311\":2,\"312\":2}}],[\"relabeling最基本的应用场景就是基于target实例中包含的metadata标签\",{\"1\":{\"310\":1}}],[\"relabeling作用时机\",{\"1\":{\"309\":1}}],[\"relabeling保留符合规则的endpoint\",{\"1\":{\"207\":1}}],[\"relabeling\",{\"1\":{\"23\":3}}],[\"read|node\",{\"1\":{\"266\":1}}],[\"read获取主机磁盘io的总量\",{\"1\":{\"244\":1}}],[\"ready=\",{\"1\":{\"207\":2}}],[\"ready\",{\"1\":{\"175\":1,\"181\":2,\"186\":1,\"187\":1,\"201\":2,\"203\":1,\"205\":2,\"206\":1,\"214\":2,\"216\":1,\"217\":1,\"223\":1,\"273\":1}}],[\"readall\",{\"1\":{\"166\":1}}],[\"readresponse\",{\"1\":{\"166\":1}}],[\"readrequest\",{\"1\":{\"166\":1}}],[\"read和remote\",{\"1\":{\"166\":1}}],[\"read具体配置如下所示\",{\"1\":{\"165\":1}}],[\"read配置\",{\"1\":{\"165\":1}}],[\"read中配置的url发起查询请求\",{\"1\":{\"164\":1}}],[\"read的特性\",{\"1\":{\"145\":1}}],[\"reads的增长率情况来判断缓冲池大小是否合理\",{\"1\":{\"111\":1}}],[\"reads的数量\",{\"1\":{\"111\":2}}],[\"reads的值开始增加\",{\"1\":{\"111\":1}}],[\"reads即记录了从磁盘读取数据的请求数量\",{\"1\":{\"111\":1}}],[\"reads\",{\"1\":{\"105\":1,\"106\":1,\"111\":6}}],[\"read\",{\"0\":{\"164\":1},\"1\":{\"45\":1,\"111\":7,\"162\":1,\"164\":2,\"165\":2,\"167\":6,\"244\":1,\"358\":3}}],[\"re验证当前告警标签的值是否满足正则表达式的内容\",{\"1\":{\"41\":1}}],[\"re规则\",{\"1\":{\"36\":1}}],[\"re\",{\"1\":{\"36\":2,\"40\":1,\"41\":1,\"42\":1}}],[\"reset\",{\"1\":{\"350\":1}}],[\"rest\",{\"1\":{\"234\":1}}],[\"restarts\",{\"1\":{\"175\":1,\"181\":2,\"186\":1,\"201\":1,\"203\":1,\"205\":1,\"206\":1,\"214\":2,\"216\":1,\"217\":1,\"223\":1}}],[\"restart\",{\"1\":{\"150\":1,\"377\":1}}],[\"resource\",{\"1\":{\"221\":1}}],[\"resources\",{\"1\":{\"186\":2,\"193\":1,\"210\":1,\"213\":1,\"214\":1,\"216\":1,\"218\":1,\"219\":3}}],[\"resolution选项\",{\"1\":{\"126\":1}}],[\"resolved为true即可\",{\"1\":{\"50\":1}}],[\"resolved用于指定是否在告警消除时发送回执消息\",{\"1\":{\"27\":1}}],[\"resolved\",{\"1\":{\"27\":2,\"49\":2,\"50\":2,\"51\":4}}],[\"resolve\",{\"1\":{\"26\":1,\"51\":1,\"55\":1,\"99\":1,\"214\":1}}],[\"resulting\",{\"1\":{\"310\":1}}],[\"result响应格式如下\",{\"1\":{\"256\":4}}],[\"resulttype\",{\"1\":{\"255\":1,\"256\":1,\"257\":2}}],[\"results\",{\"1\":{\"166\":1}}],[\"result函数\",{\"1\":{\"130\":1}}],[\"result\",{\"1\":{\"72\":2,\"130\":2,\"255\":1,\"256\":1,\"257\":2}}],[\"responsewriter\",{\"1\":{\"166\":1}}],[\"response\",{\"1\":{\"32\":2,\"94\":4,\"95\":11,\"99\":3,\"135\":1,\"195\":3,\"314\":1,\"321\":2,\"350\":10}}],[\"resp\",{\"1\":{\"32\":4}}],[\"reqbuf\",{\"1\":{\"166\":2}}],[\"req\",{\"1\":{\"32\":3,\"90\":3,\"166\":3,\"352\":4}}],[\"requested\",{\"1\":{\"305\":1}}],[\"requesturi\",{\"1\":{\"95\":7}}],[\"requestcounter\",{\"1\":{\"95\":3}}],[\"requesttimer\",{\"1\":{\"90\":2,\"95\":2,\"352\":4}}],[\"requestlatencyhistogram\",{\"1\":{\"95\":2}}],[\"requestlatency\",{\"1\":{\"90\":7,\"95\":2,\"352\":4}}],[\"request\",{\"1\":{\"51\":1,\"66\":2,\"67\":4,\"90\":7,\"94\":4,\"95\":15,\"99\":1,\"116\":9,\"135\":3,\"156\":1,\"166\":2,\"193\":2,\"217\":4,\"240\":15,\"253\":1,\"261\":4,\"262\":1,\"266\":4,\"268\":6,\"269\":1,\"294\":2,\"352\":6}}],[\"requests的值\",{\"1\":{\"111\":1}}],[\"requests的监控指标\",{\"1\":{\"89\":1}}],[\"requests记录了正常从缓冲池读取数据的请求数量\",{\"1\":{\"111\":1}}],[\"requests我们可以直接查询应用当前正在处理中的http请求数量\",{\"1\":{\"95\":1}}],[\"requests\",{\"1\":{\"27\":1,\"72\":2,\"89\":5,\"90\":5,\"95\":33,\"111\":5,\"210\":1,\"213\":1,\"214\":1,\"216\":1,\"217\":2,\"218\":1,\"219\":1,\"226\":6,\"228\":3,\"246\":3,\"250\":4,\"251\":2,\"259\":9,\"260\":4,\"264\":1,\"269\":2,\"273\":1,\"325\":3,\"351\":1,\"352\":10,\"357\":7,\"360\":5,\"361\":3,\"366\":4,\"367\":2,\"368\":6}}],[\"required\",{\"1\":{\"135\":2,\"165\":1}}],[\"require\",{\"1\":{\"26\":1,\"50\":1}}],[\"roles\",{\"1\":{\"187\":1}}],[\"roleref\",{\"1\":{\"186\":1,\"219\":1}}],[\"role\",{\"1\":{\"186\":1,\"187\":6,\"189\":1,\"190\":2,\"192\":1,\"196\":1,\"197\":1,\"199\":3,\"200\":2,\"201\":1,\"202\":1,\"203\":3,\"207\":3,\"213\":2,\"214\":2,\"218\":1,\"310\":1}}],[\"rollout\",{\"1\":{\"181\":1}}],[\"row这些对象以外\",{\"1\":{\"123\":1}}],[\"row\",{\"1\":{\"109\":2,\"110\":2,\"111\":3,\"112\":2,\"131\":1}}],[\"root\",{\"1\":{\"108\":1}}],[\"rootfs\",{\"1\":{\"105\":1}}],[\"ro\",{\"1\":{\"105\":3}}],[\"robot\",{\"1\":{\"30\":1,\"33\":1}}],[\"robustperception\",{\"1\":{\"16\":2}}],[\"routes\",{\"1\":{\"40\":1,\"42\":1,\"51\":1}}],[\"route的完整定义如下\",{\"1\":{\"40\":1}}],[\"router\",{\"1\":{\"28\":3}}],[\"route\",{\"1\":{\"26\":3,\"40\":2,\"42\":1,\"50\":1,\"51\":1,\"55\":3,\"150\":1,\"214\":1}}],[\"k8s\",{\"1\":{\"186\":3,\"219\":5,\"223\":2}}],[\"kind\",{\"1\":{\"174\":1,\"175\":2,\"181\":2,\"186\":5,\"187\":1,\"190\":1,\"195\":2,\"201\":1,\"203\":2,\"205\":2,\"206\":2,\"207\":1,\"210\":1,\"213\":2,\"214\":2,\"216\":1,\"217\":5,\"218\":3,\"219\":6}}],[\"kafka\",{\"1\":{\"114\":1}}],[\"kato\",{\"1\":{\"16\":1}}],[\"katosys\",{\"1\":{\"16\":1}}],[\"keep\",{\"1\":{\"156\":1,\"192\":1,\"196\":1,\"197\":1,\"201\":1,\"202\":1,\"203\":3,\"207\":2,\"214\":2,\"218\":2,\"310\":1,\"311\":1,\"312\":1}}],[\"kernelversion=\",{\"1\":{\"105\":1}}],[\"kernel\",{\"1\":{\"105\":1,\"187\":1}}],[\"key\",{\"1\":{\"26\":2,\"27\":1,\"51\":1,\"217\":2}}],[\"kubeconfig\",{\"1\":{\"181\":1}}],[\"kubectl默认关联default命名空间\",{\"1\":{\"181\":1}}],[\"kubectl\",{\"1\":{\"174\":1,\"175\":3,\"181\":11,\"186\":4,\"187\":5,\"189\":1,\"192\":2,\"195\":1,\"201\":3,\"202\":2,\"203\":2,\"205\":3,\"206\":3,\"210\":3,\"213\":1,\"214\":5,\"216\":4,\"217\":3,\"218\":1,\"219\":2,\"223\":3,\"393\":8}}],[\"kubelet任务采集状态\",{\"1\":{\"199\":1}}],[\"kubelet组件还内置了对cadvisor的支持\",{\"1\":{\"200\":1}}],[\"kubelet组件的正常运行直接关系到该节点是否能够正常的被kubernetes集群正常使用\",{\"1\":{\"199\":1}}],[\"kubelet组件运行在kubernetes集群的各个节点中\",{\"1\":{\"199\":1}}],[\"kubelet内置了对cadvisor的支持\",{\"1\":{\"180\":1}}],[\"kubelet\",{\"1\":{\"179\":1,\"183\":1,\"193\":3,\"198\":2,\"199\":6}}],[\"kubenetes是一款由google开发的开源的容器编排工具\",{\"1\":{\"171\":1,\"177\":1}}],[\"kube\",{\"1\":{\"15\":1,\"130\":1,\"178\":1,\"179\":4,\"180\":2,\"181\":1,\"183\":4,\"184\":2,\"202\":2,\"397\":2}}],[\"kubernetes掌握并管理着所有的容器以及服务信息\",{\"1\":{\"313\":1}}],[\"kubernetes等进行集成实现自动发现instance实例\",{\"1\":{\"280\":1}}],[\"kubernetes还允许用户添加自己的自定义资源\",{\"1\":{\"221\":1}}],[\"kubernetes就会自动找到该选择器对应的pod实例的访问信息\",{\"1\":{\"206\":1}}],[\"kubernetes下service负载均衡原理\",{\"0\":{\"206\":1}}],[\"kubernetes下的服务发现\",{\"0\":{\"185\":1},\"1\":{\"3\":1,\"10\":1,\"22\":1}}],[\"kubernetes会默认在命名空间下创建一个名为kubernetes的服务\",{\"1\":{\"202\":1}}],[\"kubernetes会监听集群中所有的pod变化情况\",{\"1\":{\"202\":1}}],[\"kubernetes插件或者用户应用\",{\"1\":{\"202\":1}}],[\"kubernetes作为一个中央化的任务调度系统\",{\"1\":{\"191\":1}}],[\"kubernetes作为开源的容器编排工具\",{\"1\":{\"180\":1,\"182\":1}}],[\"kubernetes依托于google丰富的大规模应用管理经验\",{\"1\":{\"181\":1}}],[\"kubernetes环境准备完成后\",{\"1\":{\"181\":1}}],[\"kubernetes组件\",{\"1\":{\"180\":1}}],[\"kubernetes核心组件\",{\"1\":{\"180\":1}}],[\"kubernetes的controller\",{\"1\":{\"221\":1}}],[\"kubernetes的访问授权\",{\"0\":{\"186\":1}}],[\"kubernetes的最终目标还是需要为业务服务\",{\"1\":{\"180\":1,\"184\":1}}],[\"kubernetes的核心组件主要由两部分组成\",{\"1\":{\"179\":1,\"183\":1}}],[\"kubernetes是否能够快速的完成pod的调度以及启动\",{\"1\":{\"180\":1,\"184\":1}}],[\"kubernetes监控策略\",{\"0\":{\"180\":1}}],[\"kubernetes监控实战\",{\"0\":{\"171\":1}}],[\"kubernetes架构\",{\"0\":{\"183\":1},\"1\":{\"179\":1,\"183\":1}}],[\"kubernetes架构模型\",{\"0\":{\"179\":1}}],[\"kubernetes定义了namespace\",{\"1\":{\"178\":1}}],[\"kubernetes中管理的所有资源都可以通过yaml文件进行描述\",{\"1\":{\"181\":1}}],[\"kubernetes中的dashboard本身也是通过deployment进行部署的\",{\"1\":{\"181\":1}}],[\"kubernetes中定义了单独的资源ingress\",{\"1\":{\"178\":1}}],[\"kubernetes中提供了多种controller的实现\",{\"1\":{\"178\":1}}],[\"kubernetes将这一问题划分为两个问题域\",{\"1\":{\"178\":1}}],[\"kubernetes将一系列的主机看做是一个受管理的海量资源\",{\"1\":{\"177\":1}}],[\"kubernetes应用管理模型\",{\"0\":{\"178\":1},\"1\":{\"178\":1}}],[\"kubernetest前身是google的内部工具borg\",{\"1\":{\"177\":1}}],[\"kubernetes与promethues有着十分相似的历程\",{\"1\":{\"172\":1}}],[\"kubernetes可以极大的简化应用的管理和部署复杂度\",{\"1\":{\"171\":1}}],[\"kubernetes集群\",{\"1\":{\"169\":1}}],[\"kubernetes\",{\"0\":{\"15\":1,\"396\":1,\"403\":1},\"1\":{\"0\":1,\"15\":2,\"175\":1,\"181\":7,\"186\":2,\"187\":40,\"189\":21,\"190\":14,\"192\":15,\"196\":8,\"197\":10,\"199\":17,\"200\":13,\"201\":10,\"202\":13,\"203\":25,\"207\":43,\"214\":3,\"218\":13,\"232\":1,\"277\":1,\"310\":3,\"395\":1}}],[\"ywrtaw4=\",{\"1\":{\"217\":1}}],[\"yaml中使用了default命名空间\",{\"1\":{\"223\":1}}],[\"yaml中prometheus的定义如下所示\",{\"1\":{\"218\":2}}],[\"yaml文件\",{\"1\":{\"213\":1,\"216\":1,\"273\":1}}],[\"yaml文件并添加以下内容\",{\"1\":{\"210\":1}}],[\"yaml文件中所有namespace定义\",{\"1\":{\"223\":1}}],[\"yaml文件中\",{\"1\":{\"210\":1,\"217\":1,\"219\":1}}],[\"yaml用于描述部署相关的内容\",{\"1\":{\"203\":1}}],[\"yaml\",{\"1\":{\"189\":1,\"210\":3,\"213\":1,\"214\":4,\"216\":1,\"217\":2,\"218\":2,\"219\":3,\"223\":1}}],[\"yaxisformatter\",{\"1\":{\"135\":2}}],[\"y的unit可以让graph面板自动格式化样本值\",{\"1\":{\"138\":1}}],[\"y轴会直接显示当前样本的值\",{\"1\":{\"138\":1}}],[\"ytitle\",{\"1\":{\"135\":2}}],[\"yunits\",{\"1\":{\"135\":2}}],[\"yunl\",{\"1\":{\"34\":1}}],[\"yunlzheng\",{\"1\":{\"28\":1,\"29\":1,\"31\":1,\"32\":2,\"33\":1}}],[\"yhoverformatter\",{\"1\":{\"135\":2}}],[\"y\",{\"1\":{\"116\":2,\"135\":4,\"142\":1,\"260\":1}}],[\"yml并在scrape\",{\"1\":{\"287\":1}}],[\"yml如下\",{\"1\":{\"190\":1,\"377\":1}}],[\"yml的文件定义service资源\",{\"1\":{\"181\":1}}],[\"yml文件\",{\"1\":{\"174\":1,\"175\":1,\"181\":1,\"186\":2,\"192\":1,\"201\":1,\"205\":1}}],[\"yml添加remote\",{\"1\":{\"167\":1}}],[\"yml定义如下\",{\"1\":{\"167\":1}}],[\"yml\",{\"1\":{\"58\":1,\"69\":1,\"99\":2,\"106\":2,\"108\":2,\"149\":2,\"150\":5,\"151\":3,\"174\":2,\"175\":2,\"181\":2,\"186\":2,\"187\":2,\"190\":1,\"195\":1,\"201\":1,\"205\":1,\"273\":5,\"274\":2,\"307\":2,\"377\":1,\"393\":8}}],[\"yml配置文件中\",{\"1\":{\"280\":1}}],[\"yml配置文件\",{\"1\":{\"55\":1,\"199\":1}}],[\"ycombinator\",{\"1\":{\"16\":1}}],[\"yourclass\",{\"1\":{\"89\":2,\"90\":2,\"352\":4}}],[\"yourcustomcollector2\",{\"1\":{\"85\":1,\"86\":1}}],[\"yourcustomcollector\",{\"1\":{\"85\":1,\"86\":1,\"351\":3}}],[\"your\",{\"1\":{\"85\":1,\"89\":2,\"90\":3,\"352\":4}}],[\"youtube\",{\"1\":{\"17\":1}}],[\"you\",{\"1\":{\"1\":2,\"5\":2,\"16\":1,\"118\":2,\"119\":2}}],[\"b16\",{\"1\":{\"349\":1}}],[\"b\",{\"1\":{\"240\":1}}],[\"bs\",{\"1\":{\"134\":2}}],[\"browser\",{\"1\":{\"181\":1,\"276\":1,\"287\":1}}],[\"brew\",{\"1\":{\"181\":1,\"395\":1}}],[\"brand\",{\"1\":{\"134\":2}}],[\"brattain\",{\"1\":{\"105\":1}}],[\"brianbrazil\",{\"1\":{\"16\":1}}],[\"but\",{\"1\":{\"305\":1}}],[\"button>\",{\"1\":{\"134\":1}}],[\"button\",{\"1\":{\"134\":1}}],[\"bundle\",{\"1\":{\"223\":1}}],[\"buck\",{\"1\":{\"167\":1}}],[\"bucket和http\",{\"1\":{\"240\":1}}],[\"bucket为例\",{\"1\":{\"240\":1}}],[\"bucket均可用于统计以下各种类型api响应时间的分布情况\",{\"1\":{\"193\":1}}],[\"bucket分布情况\",{\"1\":{\"142\":1}}],[\"bucket\",{\"1\":{\"95\":16,\"116\":6,\"135\":1,\"139\":11,\"141\":1,\"217\":1,\"230\":12,\"240\":7}}],[\"buckets\",{\"1\":{\"90\":1,\"95\":1,\"141\":1,\"352\":3}}],[\"busybox\",{\"1\":{\"105\":1}}],[\"buildroot\",{\"1\":{\"187\":1}}],[\"build\",{\"1\":{\"89\":2,\"90\":5,\"95\":5,\"305\":1,\"352\":6}}],[\"buffers\",{\"1\":{\"378\":1}}],[\"bufferpoolsexports\",{\"1\":{\"350\":1}}],[\"buffer文本具有更好的可读性\",{\"1\":{\"116\":1}}],[\"buffer规范做详细的阐述\",{\"1\":{\"116\":1}}],[\"buffer规范\",{\"1\":{\"116\":1}}],[\"buffer\",{\"1\":{\"31\":7,\"87\":5,\"111\":31,\"116\":1,\"349\":5}}],[\"bad\",{\"1\":{\"253\":1}}],[\"banner\",{\"1\":{\"195\":3}}],[\"base64编码后的用户名\",{\"1\":{\"217\":1}}],[\"base64编码后的密码\",{\"1\":{\"217\":1}}],[\"base64\",{\"1\":{\"210\":1}}],[\"based同步告警发送状态\",{\"1\":{\"148\":1}}],[\"based方式在集群中传播gossip信息\",{\"1\":{\"148\":1}}],[\"based从集群其它节点同步silence状态\",{\"1\":{\"148\":1}}],[\"based的实现中节点a会随机的向节点b发起询问是否有新的状态需要同步\",{\"1\":{\"148\":1}}],[\"based的格式版本\",{\"1\":{\"117\":1}}],[\"based当集群中某一节点a完成一个工作后\",{\"1\":{\"148\":1}}],[\"based\",{\"1\":{\"148\":1,\"186\":1,\"310\":1}}],[\"based和pull\",{\"1\":{\"148\":1}}],[\"base\",{\"1\":{\"142\":4,\"160\":1}}],[\"basename\",{\"1\":{\"95\":5}}],[\"bash\",{\"1\":{\"114\":1,\"298\":1,\"347\":1}}],[\"basicauth\",{\"1\":{\"217\":1}}],[\"basic\",{\"1\":{\"102\":2,\"165\":2,\"217\":3,\"317\":2}}],[\"baidu\",{\"1\":{\"100\":2}}],[\"batch\",{\"1\":{\"91\":1}}],[\"bar\",{\"1\":{\"85\":1,\"86\":1,\"134\":3,\"138\":1,\"217\":1,\"351\":1}}],[\"backlink\",{\"1\":{\"27\":1}}],[\"because\",{\"1\":{\"199\":1}}],[\"bearer\",{\"1\":{\"165\":6,\"187\":6,\"190\":2,\"192\":1,\"199\":3,\"200\":2,\"202\":1}}],[\"beanstalkd\",{\"1\":{\"114\":1}}],[\"beta\",{\"1\":{\"187\":2,\"189\":2}}],[\"between\",{\"1\":{\"156\":1,\"310\":1}}],[\"better\",{\"1\":{\"134\":1}}],[\"be\",{\"1\":{\"72\":2,\"135\":6,\"166\":1}}],[\"been\",{\"1\":{\"67\":1,\"93\":1}}],[\"be6pl897f\",{\"1\":{\"48\":3,\"49\":1}}],[\"before\",{\"1\":{\"23\":2,\"72\":1}}],[\"boundary\",{\"1\":{\"159\":1}}],[\"bootstrap\",{\"1\":{\"305\":1}}],[\"boot应用程序中使用client\",{\"1\":{\"97\":1}}],[\"boot为例\",{\"1\":{\"93\":1}}],[\"boot\",{\"1\":{\"86\":1,\"93\":1,\"286\":1,\"350\":1}}],[\"boolean\",{\"1\":{\"94\":1,\"95\":3,\"350\":1}}],[\"boolvar\",{\"1\":{\"33\":1}}],[\"bool\",{\"1\":{\"31\":1,\"33\":1,\"246\":2,\"361\":1,\"362\":1,\"363\":1}}],[\"bottomk支持参数\",{\"1\":{\"226\":1,\"368\":1}}],[\"bottomk\",{\"1\":{\"226\":1,\"368\":1}}],[\"bot\",{\"1\":{\"48\":1}}],[\"body\",{\"1\":{\"32\":1,\"102\":1,\"166\":1,\"317\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"350\":1}}],[\"bytes\",{\"1\":{\"31\":2,\"32\":2,\"87\":5,\"90\":2,\"95\":1,\"105\":10,\"106\":5,\"135\":1,\"160\":2,\"167\":6,\"188\":4,\"201\":4,\"205\":4,\"244\":7,\"245\":6,\"266\":2,\"349\":5,\"352\":4,\"358\":8}}],[\"by则正好相反\",{\"1\":{\"226\":1,\"368\":1}}],[\"by等属性\",{\"1\":{\"42\":1}}],[\"by中定义标签名称\",{\"1\":{\"42\":1}}],[\"by来定义分组规则\",{\"1\":{\"42\":1}}],[\"by\",{\"1\":{\"40\":2,\"42\":2,\"50\":1,\"51\":2,\"55\":1,\"69\":1,\"72\":2,\"95\":1,\"99\":1,\"105\":1,\"111\":4,\"135\":2,\"151\":1,\"166\":1,\"214\":1,\"226\":1,\"248\":1,\"262\":2,\"368\":1,\"369\":1,\"378\":3}}],[\"by规则可能会包含多条告警信息alert\",{\"1\":{\"28\":1}}],[\"bit\",{\"1\":{\"319\":1}}],[\"bitnami\",{\"1\":{\"15\":1}}],[\"bind\",{\"1\":{\"298\":1,\"350\":1}}],[\"bindjson\",{\"1\":{\"28\":1}}],[\"bin\",{\"1\":{\"26\":1,\"51\":1,\"150\":1,\"167\":2,\"175\":1,\"285\":1,\"373\":2,\"374\":1}}],[\"blocks\",{\"1\":{\"160\":2}}],[\"block\",{\"1\":{\"104\":1,\"159\":1,\"160\":3}}],[\"blockbox返回的样本数据中也会包含指标probe\",{\"1\":{\"103\":1,\"318\":1}}],[\"blockbox\",{\"1\":{\"101\":1,\"102\":1,\"114\":1,\"316\":1,\"317\":1}}],[\"blob\",{\"1\":{\"16\":1,\"45\":1,\"75\":2}}],[\"blog\",{\"1\":{\"14\":1,\"18\":1}}],[\"blackbox还支持对tcp\",{\"1\":{\"103\":1}}],[\"blackbox\",{\"0\":{\"98\":1},\"1\":{\"9\":1,\"21\":1,\"99\":4,\"100\":2,\"195\":13,\"196\":1,\"197\":1,\"198\":2,\"203\":15,\"232\":1,\"393\":1}}],[\"df\",{\"1\":{\"319\":1}}],[\"ds\",{\"1\":{\"307\":3,\"312\":1}}],[\"dst\",{\"1\":{\"241\":2}}],[\"dc的值\",{\"1\":{\"310\":1}}],[\"dc表明了当前实例所在的consul数据中心\",{\"1\":{\"310\":1}}],[\"dc=\",{\"1\":{\"310\":2}}],[\"dc\",{\"1\":{\"305\":1,\"310\":3,\"311\":1}}],[\"dc1\",{\"1\":{\"305\":4,\"310\":2,\"311\":1}}],[\"d7b590ba\",{\"1\":{\"305\":2}}],[\"django\",{\"1\":{\"298\":1}}],[\"dg9vcg==\",{\"1\":{\"217\":1}}],[\"d+$|dm\",{\"1\":{\"378\":1}}],[\"d+\",{\"1\":{\"201\":2,\"207\":2}}],[\"draft\",{\"0\":{\"401\":1}}],[\"draw\",{\"1\":{\"138\":3}}],[\"drop行为\",{\"1\":{\"311\":1}}],[\"drop过滤target实例\",{\"0\":{\"311\":1}}],[\"drop\",{\"1\":{\"310\":2}}],[\"drilldown\",{\"1\":{\"135\":1}}],[\"drilldown定义一个连接直接跳转到graph页面\",{\"1\":{\"135\":1}}],[\"db=prometheus\",{\"1\":{\"167\":1}}],[\"db\",{\"1\":{\"109\":2}}],[\"due\",{\"1\":{\"99\":4}}],[\"durations\",{\"1\":{\"217\":1}}],[\"duration为例\",{\"1\":{\"139\":1}}],[\"duration\",{\"1\":{\"99\":11,\"116\":17,\"135\":4,\"139\":16,\"141\":1,\"160\":3,\"167\":3,\"217\":3,\"230\":9,\"240\":15}}],[\"during\",{\"1\":{\"60\":1}}],[\"dns探针\",{\"0\":{\"314\":1}}],[\"dns\",{\"1\":{\"99\":7,\"103\":1,\"181\":1,\"232\":1,\"305\":1,\"314\":1}}],[\"daemon\",{\"1\":{\"350\":2}}],[\"daemonthreadfactory\",{\"1\":{\"350\":1}}],[\"daemonsets\",{\"1\":{\"201\":1,\"205\":1}}],[\"daemonsets等\",{\"1\":{\"193\":4}}],[\"daemonset会确保在集群中所有\",{\"1\":{\"201\":1,\"205\":1}}],[\"daemonset的管理方式类似于操作系统中的守护进程\",{\"1\":{\"201\":1,\"205\":1}}],[\"daemonset\",{\"1\":{\"178\":1,\"201\":4,\"205\":4,\"393\":1}}],[\"damenset\",{\"1\":{\"221\":1}}],[\"dashlist和text相对比较特殊\",{\"1\":{\"126\":1}}],[\"dashlist\",{\"1\":{\"126\":1}}],[\"dashboard是一个nodeport类型的service\",{\"1\":{\"181\":1}}],[\"dashboard变量\",{\"1\":{\"128\":1}}],[\"dashboards网站\",{\"1\":{\"283\":1}}],[\"dashboards\",{\"1\":{\"123\":1}}],[\"dashboard\",{\"0\":{\"123\":1},\"1\":{\"123\":1,\"181\":4,\"283\":2}}],[\"date\",{\"1\":{\"117\":1,\"181\":1,\"201\":1,\"205\":1}}],[\"datacenter\",{\"1\":{\"305\":3}}],[\"data节点格式如下\",{\"1\":{\"256\":1}}],[\"datasource\",{\"1\":{\"129\":1}}],[\"database=prometheus\",{\"1\":{\"167\":1}}],[\"database=database\",{\"1\":{\"108\":1}}],[\"database\",{\"1\":{\"42\":3,\"103\":1,\"108\":1,\"318\":1}}],[\"data\",{\"0\":{\"122\":1},\"1\":{\"32\":2,\"48\":1,\"51\":1,\"106\":1,\"108\":2,\"111\":1,\"122\":1,\"125\":1,\"126\":1,\"134\":2,\"135\":2,\"149\":2,\"150\":3,\"151\":2,\"159\":1,\"160\":2,\"174\":1,\"187\":1,\"190\":1,\"210\":1,\"217\":1,\"253\":3,\"255\":1,\"257\":1,\"273\":2,\"307\":1}}],[\"darwin\",{\"1\":{\"54\":2,\"273\":3,\"285\":4}}],[\"danger\",{\"1\":{\"49\":2}}],[\"d\",{\"1\":{\"30\":1,\"48\":1,\"108\":1,\"150\":3,\"166\":1,\"167\":1,\"260\":1,\"283\":1,\"305\":3,\"396\":1}}],[\"dig\",{\"1\":{\"305\":3}}],[\"digitalocean\",{\"1\":{\"13\":1,\"16\":1}}],[\"discovery的方式动态管理监控目标\",{\"1\":{\"276\":1}}],[\"discovery\",{\"1\":{\"218\":1,\"292\":1}}],[\"discovery发现的实例\",{\"1\":{\"187\":1}}],[\"discovery页面可以查看到当前prometheus通过kubernetes发现的所有资源对象了\",{\"1\":{\"187\":1}}],[\"disk插件可以用于检查磁盘空间\",{\"1\":{\"290\":1}}],[\"disk\",{\"1\":{\"150\":2,\"160\":1,\"244\":4,\"266\":2,\"286\":1,\"358\":8,\"378\":1}}],[\"diskrunningfull\",{\"1\":{\"150\":5}}],[\"display选项中的最后一个是thresholds\",{\"1\":{\"138\":1}}],[\"display选项\",{\"1\":{\"138\":1}}],[\"display\",{\"1\":{\"134\":1,\"141\":1}}],[\"displays\",{\"1\":{\"99\":1}}],[\"div>\",{\"1\":{\"134\":3,\"135\":1}}],[\"dir=\",{\"1\":{\"305\":1}}],[\"dirty\",{\"1\":{\"111\":1}}],[\"directory\",{\"1\":{\"160\":1}}],[\"direct\",{\"1\":{\"87\":1,\"349\":1}}],[\"dingtalkrobot\",{\"1\":{\"32\":2}}],[\"dingtalkmarkdown\",{\"1\":{\"31\":3}}],[\"dingtalk\",{\"1\":{\"28\":1,\"29\":1,\"30\":1,\"31\":2,\"32\":2,\"33\":3}}],[\"demo\",{\"1\":{\"396\":1}}],[\"debug\",{\"1\":{\"305\":1}}],[\"del\",{\"1\":{\"250\":1,\"366\":1}}],[\"delta\",{\"1\":{\"229\":1}}],[\"deleted\",{\"1\":{\"187\":1}}],[\"delete\",{\"1\":{\"109\":1,\"187\":1}}],[\"delete的总量衡量当前服务器写操作的总次数\",{\"1\":{\"109\":1}}],[\"describe命令查看该alertmanager的pod实例状态\",{\"1\":{\"214\":1}}],[\"describe\",{\"1\":{\"206\":1}}],[\"description=node\",{\"1\":{\"374\":1}}],[\"description用于描述告警的详细信息\",{\"1\":{\"67\":1}}],[\"description\",{\"1\":{\"31\":1,\"66\":2,\"67\":2,\"69\":2,\"151\":2}}],[\"desired\",{\"1\":{\"181\":1,\"201\":1,\"205\":1,\"216\":1}}],[\"deploymeht\",{\"1\":{\"181\":1}}],[\"deployment能够确保prometheus的pod能够按照预期的状态在集群中运行\",{\"1\":{\"201\":1,\"205\":1}}],[\"deployments\",{\"1\":{\"181\":2,\"193\":4,\"217\":1}}],[\"deployment\",{\"1\":{\"175\":4,\"178\":1,\"179\":1,\"181\":26,\"183\":1,\"186\":3,\"195\":2,\"203\":1,\"217\":1,\"223\":1,\"393\":3}}],[\"dependencies\",{\"1\":{\"93\":1,\"349\":1}}],[\"dedup阶段则会判断当前alertmanager数据库中该通知是否已经发送\",{\"1\":{\"148\":1}}],[\"deduplicate\",{\"1\":{\"27\":1}}],[\"detection\",{\"1\":{\"135\":1}}],[\"detach=\",{\"1\":{\"187\":1,\"189\":1}}],[\"detach=true\",{\"1\":{\"105\":1}}],[\"detail\",{\"1\":{\"135\":2}}],[\"details\",{\"1\":{\"18\":1,\"48\":1}}],[\"decode\",{\"1\":{\"166\":1}}],[\"decimals用于配置这些值显示时保留的小数位\",{\"1\":{\"138\":1}}],[\"dec\",{\"1\":{\"89\":2,\"95\":1,\"352\":2}}],[\"device=\",{\"1\":{\"244\":2,\"358\":8}}],[\"device\",{\"1\":{\"106\":2,\"378\":2}}],[\"dev\",{\"1\":{\"55\":1,\"58\":2,\"69\":2,\"150\":4,\"151\":2,\"305\":2,\"308\":1}}],[\"devops\",{\"1\":{\"16\":1}}],[\"definitions\",{\"1\":{\"45\":1}}],[\"defined\",{\"1\":{\"51\":1}}],[\"define\",{\"1\":{\"45\":1,\"51\":1,\"134\":2}}],[\"defer\",{\"1\":{\"32\":1}}],[\"defaultthreadfactory\",{\"1\":{\"350\":1}}],[\"defaultmode\",{\"1\":{\"210\":1}}],[\"defaults\",{\"1\":{\"135\":13,\"273\":2}}],[\"defaultregistry中所有的collector实例的collect\",{\"1\":{\"350\":1}}],[\"defaultregistry中\",{\"1\":{\"350\":1}}],[\"defaultregistry\",{\"1\":{\"91\":1}}],[\"defaultrobot\",{\"1\":{\"33\":4}}],[\"defaultexports\",{\"1\":{\"87\":1,\"93\":1,\"349\":2,\"350\":1}}],[\"defaultexport的initialize方法注册该模块中所有的collector实例\",{\"1\":{\"87\":1}}],[\"default\",{\"1\":{\"26\":8,\"27\":2,\"28\":1,\"34\":1,\"40\":4,\"42\":1,\"45\":1,\"49\":16,\"50\":7,\"51\":16,\"66\":1,\"72\":2,\"150\":3,\"151\":1,\"165\":3,\"181\":1,\"186\":2,\"190\":2,\"192\":4,\"195\":1,\"196\":1,\"197\":1,\"199\":2,\"200\":1,\"202\":4,\"203\":4,\"206\":1,\"207\":1,\"217\":2,\"218\":3,\"273\":3,\"310\":4,\"314\":4,\"319\":2,\"321\":3}}],[\"double\",{\"1\":{\"352\":1}}],[\"dont\",{\"1\":{\"319\":1}}],[\"dom\",{\"1\":{\"135\":1}}],[\"down\",{\"1\":{\"67\":2}}],[\"downloads\",{\"1\":{\"305\":1}}],[\"download\",{\"1\":{\"54\":2,\"103\":1,\"273\":2,\"285\":2,\"318\":1,\"373\":1}}],[\"do\",{\"1\":{\"32\":1,\"160\":1}}],[\"doesn\",{\"1\":{\"199\":1}}],[\"does\",{\"1\":{\"16\":1}}],[\"document\",{\"1\":{\"135\":1}}],[\"documentation\",{\"1\":{\"16\":1,\"75\":2,\"167\":1}}],[\"dockerversion=\",{\"1\":{\"105\":1}}],[\"docker\",{\"1\":{\"104\":2,\"105\":9,\"108\":2,\"114\":2,\"167\":4,\"187\":1,\"199\":1,\"274\":1,\"283\":1,\"396\":1,\"400\":1}}],[\"docker是一个开源的应用容器引擎\",{\"1\":{\"104\":1}}],[\"docs\",{\"1\":{\"15\":1}}],[\"0版本\",{\"1\":{\"288\":2}}],[\"0<φ<1\",{\"1\":{\"240\":1}}],[\"0<=\",{\"1\":{\"95\":1}}],[\"0的job配置\",{\"1\":{\"218\":1}}],[\"0的版本也已经不再支持protocol\",{\"1\":{\"116\":1}}],[\"03\",{\"1\":{\"150\":8,\"151\":4}}],[\"06\",{\"1\":{\"117\":1,\"150\":9}}],[\"08002717c1c9\",{\"1\":{\"207\":1}}],[\"08\",{\"1\":{\"117\":1}}],[\"0之前的版本还支持protocol\",{\"1\":{\"116\":1}}],[\"07\",{\"1\":{\"255\":2,\"257\":2}}],[\"0703125\",{\"1\":{\"116\":1,\"267\":1,\"286\":1}}],[\"075\",{\"1\":{\"90\":1,\"95\":1,\"352\":1}}],[\"09\",{\"1\":{\"105\":1}}],[\"0b\",{\"1\":{\"104\":2}}],[\"004\",{\"1\":{\"350\":1}}],[\"0000\",{\"1\":{\"285\":1}}],[\"000001\",{\"1\":{\"159\":3}}],[\"000002\",{\"1\":{\"159\":1}}],[\"000000\",{\"1\":{\"112\":1}}],[\"0001\",{\"1\":{\"217\":1}}],[\"001\",{\"1\":{\"195\":1}}],[\"00以来的毫秒数\",{\"1\":{\"116\":1}}],[\"00\",{\"1\":{\"104\":1,\"109\":2,\"110\":1,\"111\":2,\"112\":2,\"116\":2,\"257\":1}}],[\"003261666\",{\"1\":{\"95\":1}}],[\"003261666s\",{\"1\":{\"95\":1}}],[\"005\",{\"1\":{\"90\":1,\"95\":2,\"352\":1}}],[\"029495508\",{\"1\":{\"95\":1}}],[\"029495508s\",{\"1\":{\"95\":1}}],[\"025\",{\"1\":{\"90\":1,\"95\":2,\"352\":1}}],[\"02\",{\"1\":{\"51\":3,\"111\":1,\"187\":1}}],[\"01t20\",{\"1\":{\"255\":2,\"257\":2}}],[\"017316173\",{\"1\":{\"230\":1}}],[\"014458005s\",{\"1\":{\"230\":1}}],[\"014458005\",{\"1\":{\"230\":1}}],[\"012352463\",{\"1\":{\"230\":2}}],[\"01bkgtzq1hhwhv8fbjxw1y3w0k\",{\"1\":{\"159\":1}}],[\"01bkgtzq1syqjtr4pb43c8pd98\",{\"1\":{\"159\":1}}],[\"01bkgv7jbm69t2g1bgbgm6kb12\",{\"1\":{\"159\":1}}],[\"011633673\",{\"1\":{\"99\":2}}],[\"01为误差\",{\"1\":{\"90\":1}}],[\"01\",{\"1\":{\"51\":3,\"90\":2,\"95\":3,\"110\":1,\"116\":3,\"352\":3}}],[\"055551141\",{\"1\":{\"99\":1}}],[\"052404983\",{\"1\":{\"95\":1}}],[\"052404983s\",{\"1\":{\"95\":1}}],[\"05为误差\",{\"1\":{\"90\":1}}],[\"05\",{\"1\":{\"31\":1,\"51\":3,\"90\":2,\"95\":2,\"99\":1,\"116\":2,\"250\":1,\"251\":2,\"352\":3,\"366\":1,\"367\":2}}],[\"0\",{\"1\":{\"14\":1,\"30\":1,\"40\":2,\"51\":12,\"55\":2,\"66\":1,\"67\":2,\"69\":6,\"85\":2,\"86\":11,\"87\":7,\"90\":8,\"91\":4,\"93\":11,\"95\":49,\"99\":11,\"100\":6,\"103\":1,\"104\":2,\"105\":5,\"109\":6,\"110\":2,\"111\":5,\"112\":4,\"116\":6,\"117\":1,\"138\":3,\"144\":1,\"149\":6,\"150\":12,\"151\":20,\"167\":4,\"175\":2,\"178\":2,\"181\":14,\"186\":3,\"187\":6,\"188\":2,\"189\":1,\"192\":2,\"193\":1,\"195\":1,\"199\":1,\"201\":1,\"202\":2,\"203\":1,\"205\":1,\"206\":1,\"214\":7,\"216\":2,\"217\":5,\"218\":3,\"223\":1,\"226\":1,\"230\":13,\"239\":1,\"240\":3,\"245\":1,\"246\":1,\"250\":2,\"251\":4,\"255\":1,\"257\":2,\"273\":3,\"285\":4,\"287\":1,\"290\":1,\"305\":38,\"310\":1,\"318\":1,\"349\":21,\"350\":1,\"352\":8,\"361\":1,\"366\":2,\"367\":4,\"368\":1,\"373\":5,\"396\":1}}],[\"049736019\",{\"1\":{\"99\":1}}],[\"04\",{\"1\":{\"13\":1,\"31\":1,\"51\":3,\"250\":1,\"251\":1,\"305\":1,\"366\":1,\"367\":1}}],[\"2c1b\",{\"1\":{\"305\":1}}],[\"22\",{\"1\":{\"305\":2}}],[\"2a911bdf67d5\",{\"1\":{\"305\":2}}],[\"23\",{\"1\":{\"305\":1}}],[\"23t14\",{\"1\":{\"273\":6}}],[\"236\",{\"1\":{\"175\":1}}],[\"2节当中\",{\"1\":{\"267\":1}}],[\"21287\",{\"1\":{\"259\":1}}],[\"21\",{\"1\":{\"250\":1,\"251\":1,\"310\":1,\"366\":1,\"367\":1}}],[\"216\",{\"1\":{\"230\":1}}],[\"260\",{\"1\":{\"230\":1}}],[\"2693\",{\"1\":{\"116\":1}}],[\"2字节大小\",{\"1\":{\"160\":1}}],[\"2hz55\",{\"1\":{\"216\":1,\"223\":1}}],[\"2h\",{\"1\":{\"160\":1,\"229\":1,\"239\":1}}],[\"2nd\",{\"1\":{\"156\":1}}],[\"271\",{\"1\":{\"150\":1}}],[\"27\",{\"1\":{\"150\":8}}],[\"2906\",{\"1\":{\"117\":1}}],[\"2m\",{\"1\":{\"109\":2,\"111\":1,\"112\":1,\"126\":1,\"129\":1,\"181\":1,\"238\":4,\"282\":3}}],[\"28\",{\"1\":{\"105\":1,\"325\":1}}],[\"2xx\",{\"1\":{\"99\":3,\"100\":4,\"101\":1,\"102\":1,\"103\":3,\"195\":2,\"196\":1,\"197\":1,\"203\":2,\"316\":1,\"317\":1,\"318\":3}}],[\"240\",{\"1\":{\"218\":1}}],[\"24054\",{\"1\":{\"116\":1}}],[\"24\",{\"1\":{\"93\":3,\"250\":2,\"251\":1,\"366\":2,\"367\":1,\"396\":1}}],[\"255\",{\"1\":{\"175\":1}}],[\"25600\",{\"1\":{\"230\":1}}],[\"256\",{\"1\":{\"139\":1}}],[\"25\",{\"1\":{\"90\":1,\"95\":1,\"206\":1,\"352\":1}}],[\"20889\",{\"1\":{\"259\":1}}],[\"20\",{\"1\":{\"130\":2}}],[\"2016年5月继kubernetes之后成为第二个正式加入cncf基金会的项目\",{\"1\":{\"288\":1}}],[\"2017年底发布了基于全新存储层的2\",{\"1\":{\"288\":1}}],[\"2017\",{\"1\":{\"187\":1}}],[\"2018\",{\"1\":{\"117\":1,\"150\":1,\"151\":1,\"305\":2}}],[\"20131114\",{\"1\":{\"26\":1}}],[\"200\",{\"1\":{\"95\":21,\"99\":1,\"103\":1,\"110\":2,\"117\":1,\"135\":1,\"217\":1,\"246\":2,\"259\":2,\"260\":2,\"266\":1,\"268\":4,\"294\":2,\"318\":1,\"357\":4,\"360\":3,\"361\":2}}],[\"2006\",{\"1\":{\"51\":3}}],[\"2\",{\"1\":{\"14\":1,\"54\":1,\"85\":1,\"90\":2,\"93\":1,\"95\":5,\"103\":1,\"109\":2,\"116\":3,\"139\":2,\"142\":2,\"159\":2,\"166\":1,\"167\":1,\"175\":1,\"192\":1,\"195\":1,\"197\":1,\"202\":1,\"203\":1,\"214\":8,\"217\":6,\"230\":2,\"240\":2,\"241\":1,\"246\":2,\"280\":2,\"285\":5,\"290\":1,\"305\":1,\"310\":1,\"318\":1,\"352\":1,\"356\":2,\"362\":2}}],[\"outgoing\",{\"1\":{\"305\":1}}],[\"outputstreamwriter\",{\"1\":{\"350\":2}}],[\"output\",{\"1\":{\"72\":1}}],[\"ol\",{\"1\":{\"285\":1}}],[\"o的状态\",{\"1\":{\"234\":1}}],[\"o不断攀升\",{\"1\":{\"111\":1}}],[\"osw\",{\"1\":{\"350\":4}}],[\"os=\",{\"1\":{\"187\":1,\"189\":1}}],[\"osversion=\",{\"1\":{\"105\":1}}],[\"os\",{\"1\":{\"105\":1,\"187\":1,\"350\":3}}],[\"o\",{\"1\":{\"104\":2,\"187\":1,\"189\":1,\"202\":1,\"206\":1,\"234\":1}}],[\"object>的secret中\",{\"1\":{\"210\":1}}],[\"object\",{\"1\":{\"94\":2,\"95\":7}}],[\"observeduration\",{\"1\":{\"90\":1,\"95\":2,\"352\":2}}],[\"observe\",{\"1\":{\"90\":1,\"352\":2}}],[\"over\",{\"1\":{\"99\":1,\"105\":1}}],[\"overrides效果\",{\"1\":{\"138\":1}}],[\"overrides\",{\"1\":{\"138\":1}}],[\"overrides控制\",{\"1\":{\"138\":1}}],[\"overrides和thresholds\",{\"1\":{\"138\":1}}],[\"override\",{\"1\":{\"93\":1,\"94\":3,\"95\":7,\"96\":2}}],[\"overwrite\",{\"1\":{\"72\":1}}],[\"other\",{\"1\":{\"85\":1,\"86\":4,\"351\":1}}],[\"others\",{\"0\":{\"16\":1}}],[\"occurred\",{\"1\":{\"48\":1}}],[\"ok\",{\"1\":{\"30\":1,\"117\":1,\"290\":1,\"350\":2}}],[\"oapi\",{\"1\":{\"30\":1}}],[\"offset\",{\"1\":{\"261\":2}}],[\"often\",{\"1\":{\"72\":1}}],[\"of\",{\"1\":{\"27\":1,\"48\":2,\"67\":2,\"72\":3,\"87\":1,\"93\":2,\"99\":5,\"105\":1,\"109\":1,\"116\":2,\"135\":11,\"139\":1,\"160\":3,\"188\":1,\"210\":1,\"217\":1,\"230\":2,\"273\":1,\"310\":2,\"314\":2,\"319\":2,\"321\":2,\"349\":1}}],[\"oracle\",{\"1\":{\"349\":1}}],[\"ordered\",{\"1\":{\"166\":1}}],[\"order\",{\"1\":{\"166\":1}}],[\"org\",{\"1\":{\"96\":1,\"134\":1}}],[\"or\",{\"1\":{\"27\":1,\"51\":1,\"72\":1,\"90\":1,\"99\":2,\"103\":1,\"135\":1,\"247\":2,\"248\":1,\"318\":1,\"321\":1,\"364\":2,\"369\":1}}],[\"opt\",{\"1\":{\"305\":1}}],[\"option\",{\"1\":{\"166\":1}}],[\"option选项\",{\"1\":{\"144\":1}}],[\"option选项的变量\",{\"1\":{\"131\":1}}],[\"options配置\",{\"1\":{\"138\":1}}],[\"options则设置各个展示模式下的相关样式\",{\"1\":{\"138\":1}}],[\"options用于设置当前图标的展示形式\",{\"1\":{\"138\":1}}],[\"options中可以设置图例的显示方式以及展示位置\",{\"1\":{\"138\":1}}],[\"options\",{\"1\":{\"135\":1,\"138\":1,\"305\":1}}],[\"options选项中可以指定该变量的下拉框是否支持多选\",{\"1\":{\"130\":1}}],[\"optional\",{\"1\":{\"135\":14}}],[\"optimization\",{\"1\":{\"14\":1}}],[\"opcode\",{\"1\":{\"305\":1}}],[\"op>\",{\"1\":{\"226\":1,\"250\":2,\"251\":4,\"366\":2,\"367\":4,\"368\":1}}],[\"opaque\",{\"1\":{\"217\":1}}],[\"opening\",{\"1\":{\"181\":1}}],[\"opentsdb\",{\"0\":{\"333\":1},\"1\":{\"122\":1,\"167\":1}}],[\"operator部署状态\",{\"1\":{\"223\":1}}],[\"operator通过deployment的形式进行部署\",{\"1\":{\"223\":1}}],[\"operator通过statefulset的方式创建的alertmanager实例\",{\"1\":{\"214\":1}}],[\"operator之前需要先替换一下bundle\",{\"1\":{\"223\":1}}],[\"operator之后\",{\"1\":{\"216\":1}}],[\"operator进行rbac授权\",{\"1\":{\"223\":1}}],[\"operator创建一个单独的命名空间monitoring\",{\"1\":{\"223\":1}}],[\"operator创建的prometheus实例\",{\"1\":{\"216\":1}}],[\"operator创建的prometheus实例中使用自定义配置文件\",{\"1\":{\"210\":1}}],[\"operator非常简单\",{\"1\":{\"223\":1}}],[\"operator能够监听和管理kubernetes资源同时也创建了单独的serviceaccount以及相关的授权动作\",{\"1\":{\"223\":1}}],[\"operator能够帮助用户自动化的创建以及管理prometheus\",{\"1\":{\"222\":1}}],[\"operator能做什么\",{\"0\":{\"222\":1},\"1\":{\"222\":1}}],[\"operator目前提供的️4类资源\",{\"1\":{\"222\":1}}],[\"operator为我们提供了哪些自定义的kubernetes资源\",{\"1\":{\"222\":1}}],[\"operator负责监听这些自定义资源的变化\",{\"1\":{\"221\":1}}],[\"operator架构\",{\"1\":{\"221\":1}}],[\"operator完成相关配置变更后\",{\"1\":{\"219\":1}}],[\"operator中\",{\"1\":{\"217\":1}}],[\"operator中使用自定义配置\",{\"0\":{\"210\":1},\"1\":{\"10\":1,\"22\":1}}],[\"operator使用了自定义资源类型servicemonitor来描述监控对象的信息\",{\"1\":{\"217\":1}}],[\"operator在配置文件中添加了以下配置\",{\"1\":{\"214\":1}}],[\"operator会自动通过集群的方式创建alertmanager\",{\"1\":{\"214\":1}}],[\"operator会自动管理\",{\"1\":{\"210\":1}}],[\"operator管理alertmanager实例\",{\"1\":{\"214\":1}}],[\"operator定义和管理alertmanager相关的内容\",{\"1\":{\"214\":1}}],[\"operator将原本手动管理的工作全部变成声明式的管理模式\",{\"1\":{\"214\":1}}],[\"operator模式中\",{\"1\":{\"213\":1}}],[\"operator的deployment实例\",{\"1\":{\"223\":1}}],[\"operator的源码\",{\"1\":{\"223\":1}}],[\"operator的架构示意图\",{\"1\":{\"221\":1}}],[\"operator的工作原理\",{\"0\":{\"221\":1}}],[\"operator的自定义资源类型管理了prometheus的实例\",{\"1\":{\"214\":1}}],[\"operator的能力范围之内\",{\"1\":{\"210\":1}}],[\"operator的主要概念\",{\"1\":{\"208\":1}}],[\"operator对于job的配置只适用于在kubernetes中部署和管理的应用程序\",{\"1\":{\"210\":1}}],[\"operator自动通过statefulset创建的prometheus实例\",{\"1\":{\"216\":1}}],[\"operator自动完成\",{\"1\":{\"210\":1}}],[\"operator自动化管理监控配置\",{\"1\":{\"208\":1}}],[\"operator自动化运维prometheus\",{\"1\":{\"208\":1}}],[\"operator我们通过声明式的创建如prometheus\",{\"1\":{\"210\":1}}],[\"operator简化在kubernetes下部署和管理prmetheus的复杂度\",{\"1\":{\"208\":1}}],[\"operator简化在kubernetes下部署和管理promethues的过程\",{\"1\":{\"171\":1}}],[\"operator搭建prometheus联邦集群\",{\"1\":{\"75\":1}}],[\"operator有了一个基本的认识\",{\"1\":{\"75\":1}}],[\"operator\",{\"0\":{\"208\":1,\"220\":1,\"223\":1,\"394\":1,\"397\":1},\"1\":{\"10\":2,\"16\":1,\"22\":2,\"75\":2,\"208\":1,\"216\":1,\"220\":2,\"223\":7,\"397\":2}}],[\"operator实现对prometheus的管理\",{\"1\":{\"1\":1}}],[\"opsgenie\",{\"1\":{\"26\":3,\"43\":2}}],[\"online\",{\"1\":{\"374\":2}}],[\"only\",{\"1\":{\"134\":1,\"253\":1,\"319\":1}}],[\"once\",{\"1\":{\"273\":1}}],[\"one\",{\"1\":{\"135\":1,\"249\":4,\"273\":1,\"365\":4}}],[\"on\",{\"1\":{\"13\":1,\"67\":1,\"100\":1,\"230\":1,\"250\":1,\"251\":2,\"285\":1,\"299\":1,\"310\":1,\"319\":1,\"366\":1,\"367\":2}}],[\"works\",{\"1\":{\"319\":1}}],[\"written返回当前主机中各个磁盘的写入数据总量的瞬时向量\",{\"1\":{\"358\":1}}],[\"written\",{\"1\":{\"244\":1,\"266\":1,\"310\":1,\"358\":4}}],[\"written和node\",{\"1\":{\"244\":1}}],[\"writeto\",{\"1\":{\"350\":2}}],[\"write004\",{\"1\":{\"350\":1}}],[\"write|\",{\"1\":{\"167\":7}}],[\"write服务\",{\"1\":{\"166\":1}}],[\"writerequest\",{\"1\":{\"166\":2}}],[\"write的http服务\",{\"1\":{\"166\":2}}],[\"write和remote\",{\"1\":{\"145\":1,\"165\":2}}],[\"writes\",{\"1\":{\"105\":1,\"106\":1}}],[\"writestring\",{\"1\":{\"31\":4}}],[\"write\",{\"0\":{\"163\":1},\"1\":{\"16\":1,\"159\":1,\"162\":1,\"163\":2,\"165\":2,\"167\":5}}],[\"wtlsn\",{\"1\":{\"187\":1}}],[\"wjqcl\",{\"1\":{\"175\":1,\"186\":1}}],[\"w\",{\"1\":{\"166\":4,\"260\":1}}],[\"wide\",{\"1\":{\"187\":1,\"202\":1,\"206\":1}}],[\"width\",{\"1\":{\"135\":2}}],[\"will\",{\"1\":{\"135\":2}}],[\"wildcard\",{\"1\":{\"45\":1}}],[\"windows\",{\"1\":{\"104\":1}}],[\"with\",{\"1\":{\"72\":1,\"85\":2,\"100\":3,\"105\":1,\"135\":1,\"319\":1,\"351\":2}}],[\"within\",{\"1\":{\"72\":1,\"166\":1}}],[\"without用于从计算结果中移除列举的标签\",{\"1\":{\"226\":1,\"368\":1}}],[\"without|by\",{\"1\":{\"226\":1,\"368\":1}}],[\"without\",{\"1\":{\"69\":1,\"106\":5,\"109\":1,\"126\":1,\"127\":1,\"128\":1,\"138\":1,\"151\":1,\"226\":1,\"282\":2,\"368\":1,\"378\":2}}],[\"wiki\",{\"1\":{\"45\":2}}],[\"wise2c\",{\"1\":{\"34\":1,\"95\":1}}],[\"when\",{\"1\":{\"51\":1,\"305\":1,\"321\":1}}],[\"whether\",{\"1\":{\"27\":1,\"51\":1,\"99\":2,\"103\":1,\"108\":1,\"318\":1,\"321\":1}}],[\"which\",{\"1\":{\"45\":1,\"116\":2,\"160\":1,\"310\":3}}],[\"what\",{\"1\":{\"1\":1,\"5\":1,\"118\":1,\"119\":1}}],[\"west\",{\"1\":{\"397\":1}}],[\"web以及dropwizard等的实现\",{\"1\":{\"350\":1}}],[\"web以及servlet的支持\",{\"1\":{\"86\":1}}],[\"webmvcconfigureradapter\",{\"1\":{\"94\":1,\"96\":1}}],[\"web界面中的alerts菜单查看当前prometheus下的所有告警规则\",{\"1\":{\"68\":1}}],[\"webhhook支持的其它自定义参数\",{\"1\":{\"49\":1}}],[\"webhhook地址作为slack\",{\"1\":{\"49\":1}}],[\"webhhook的基本使用方式后\",{\"1\":{\"49\":1}}],[\"webhhook还支持一些其他的参数\",{\"1\":{\"48\":1}}],[\"webhhook配置\",{\"1\":{\"48\":1}}],[\"webhookbot\",{\"1\":{\"48\":3}}],[\"webhook的工作方式很简单\",{\"1\":{\"48\":1}}],[\"webhooks配置和使用方式\",{\"1\":{\"48\":1}}],[\"webhooks的应用\",{\"1\":{\"48\":1}}],[\"webhooks\",{\"0\":{\"48\":1},\"1\":{\"48\":1}}],[\"webhook服务之后\",{\"1\":{\"34\":1}}],[\"webhook机器人创建成功后\",{\"1\":{\"30\":1}}],[\"webhook中获取\",{\"1\":{\"29\":1}}],[\"webhook接收来自alertmanager的post请求\",{\"1\":{\"28\":1}}],[\"webhook\",{\"1\":{\"27\":1,\"28\":2,\"31\":1,\"32\":2,\"33\":2,\"34\":2,\"40\":1,\"43\":1,\"55\":1,\"150\":13,\"151\":8,\"214\":3}}],[\"webhook还可以与其他第三方系统集成实现运维自动化\",{\"1\":{\"27\":1}}],[\"web\",{\"1\":{\"40\":2,\"46\":1,\"55\":2,\"133\":2,\"149\":2,\"150\":3,\"151\":3,\"214\":2,\"217\":4,\"218\":2,\"273\":1}}],[\"weixin\",{\"1\":{\"26\":1,\"51\":1}}],[\"wechat\",{\"1\":{\"26\":3,\"51\":19}}],[\"wan\",{\"1\":{\"305\":3}}],[\"wantedby=multi\",{\"1\":{\"374\":1}}],[\"wants=network\",{\"1\":{\"374\":1}}],[\"want\",{\"1\":{\"16\":1}}],[\"wal\",{\"1\":{\"159\":3,\"230\":9}}],[\"was\",{\"1\":{\"99\":2,\"103\":1,\"318\":1}}],[\"warning\",{\"1\":{\"55\":1,\"150\":1,\"290\":1,\"305\":1}}],[\"wait阶段可以确保集群状态一致\",{\"1\":{\"148\":1}}],[\"wait参数设置等待时间\",{\"1\":{\"42\":1}}],[\"wait\",{\"1\":{\"40\":1,\"42\":2,\"51\":1,\"55\":1,\"214\":1}}],[\"watch\",{\"1\":{\"17\":1,\"186\":2,\"219\":1}}],[\"www\",{\"1\":{\"13\":1,\"16\":3,\"17\":1,\"144\":1,\"305\":1}}],[\"humanizeexact\",{\"1\":{\"135\":1}}],[\"humanize\",{\"1\":{\"135\":1}}],[\"humanizenosmallprefix\",{\"1\":{\"135\":2}}],[\"hub\",{\"1\":{\"114\":1}}],[\"h3>\",{\"1\":{\"135\":2}}],[\"h1>\",{\"1\":{\"135\":1}}],[\"href=\",{\"1\":{\"134\":3}}],[\"hdfs\",{\"1\":{\"114\":1}}],[\"handle\",{\"1\":{\"350\":1}}],[\"handlefunc\",{\"1\":{\"166\":1}}],[\"handler=\",{\"1\":{\"246\":2,\"259\":2,\"260\":2,\"269\":2,\"325\":3,\"357\":4,\"360\":3,\"361\":2}}],[\"handler\",{\"1\":{\"94\":4,\"95\":10,\"226\":1,\"368\":1}}],[\"handlerinterceptoradapter\",{\"1\":{\"94\":1,\"95\":4}}],[\"ha部署结构\",{\"1\":{\"150\":1,\"151\":1}}],[\"ha\",{\"0\":{\"402\":1},\"1\":{\"145\":1,\"150\":4,\"151\":3,\"154\":1}}],[\"haproxy\",{\"1\":{\"114\":1,\"298\":1}}],[\"have\",{\"1\":{\"93\":1}}],[\"haskell\",{\"1\":{\"298\":1}}],[\"haskeel\",{\"1\":{\"114\":1}}],[\"hash值\",{\"1\":{\"312\":1}}],[\"hash=\",{\"1\":{\"207\":1}}],[\"hashmod\",{\"1\":{\"156\":1,\"312\":2}}],[\"hash\",{\"1\":{\"156\":2,\"167\":1,\"310\":1,\"312\":4}}],[\"has\",{\"1\":{\"48\":1,\"67\":3,\"93\":1,\"116\":2}}],[\"home\",{\"1\":{\"372\":1}}],[\"hold\",{\"1\":{\"253\":1}}],[\"horbor\",{\"1\":{\"169\":1}}],[\"honor\",{\"1\":{\"156\":1,\"169\":1}}],[\"hover\",{\"1\":{\"135\":2,\"138\":1}}],[\"hours\",{\"1\":{\"167\":2}}],[\"hour\",{\"1\":{\"135\":1}}],[\"hotspot是如果实现对jvm相关运行指标的监控的\",{\"1\":{\"351\":1}}],[\"hotspot是对hotspot\",{\"1\":{\"349\":1}}],[\"hotspot中提供的defaultexporter\",{\"1\":{\"93\":1}}],[\"hotspot\",{\"1\":{\"87\":3,\"93\":1,\"349\":2,\"350\":1}}],[\"hotspot为例\",{\"1\":{\"87\":1}}],[\"host标签的值为exporter实例的ip地址\",{\"1\":{\"241\":1}}],[\"host=\",{\"1\":{\"229\":1,\"241\":3}}],[\"hostpid\",{\"1\":{\"201\":1,\"205\":1}}],[\"hostport\",{\"1\":{\"201\":1,\"205\":1}}],[\"hostnetwork\",{\"1\":{\"201\":1,\"205\":1}}],[\"hostname=\",{\"1\":{\"187\":2,\"189\":2}}],[\"hoststats\",{\"1\":{\"151\":1}}],[\"hoststatsalert\",{\"1\":{\"69\":1,\"151\":1}}],[\"host1|host2|host3\",{\"1\":{\"128\":1}}],[\"host\",{\"1\":{\"102\":1,\"207\":1,\"241\":1,\"283\":1,\"317\":1}}],[\"hostmemusagealert\",{\"1\":{\"69\":1,\"151\":1}}],[\"hostcpuusagealert显示由一条告警处于活动状态\",{\"1\":{\"69\":1}}],[\"hostcpuusagealert\",{\"1\":{\"69\":1,\"151\":2}}],[\"hooks\",{\"1\":{\"48\":3,\"49\":1}}],[\"hook定义为一个webhook地址\",{\"1\":{\"40\":1}}],[\"hook的receiver接收\",{\"1\":{\"40\":1}}],[\"hook\",{\"1\":{\"40\":2,\"55\":2}}],[\"how\",{\"0\":{\"400\":1},\"1\":{\"13\":1,\"15\":1,\"16\":1,\"72\":1,\"99\":1,\"160\":1}}],[\"h\",{\"1\":{\"28\":2,\"30\":1,\"33\":6,\"260\":1}}],[\"hide属性则用于指定在渲染界面时是否隐藏该变量的下拉框\",{\"1\":{\"129\":1}}],[\"histogram是一个自带buckets区间的用于统计分布的对象\",{\"1\":{\"352\":1}}],[\"histogram和summary都是为了能够解决这样问题的存在\",{\"1\":{\"230\":1}}],[\"histogram和summary主要用于统计和分析样本的分布情况\",{\"1\":{\"230\":1}}],[\"histogram数据可视化\",{\"1\":{\"139\":1}}],[\"histogram用于统计样本数据的分布情况\",{\"1\":{\"139\":1}}],[\"histogram会自动创建3个指标\",{\"1\":{\"95\":1}}],[\"histogramrequesttimer\",{\"1\":{\"95\":3}}],[\"histogram主要用于在指定分布范围内\",{\"1\":{\"95\":1}}],[\"histogram\",{\"1\":{\"90\":2,\"95\":21,\"116\":3,\"139\":1,\"217\":2,\"227\":1,\"230\":1,\"240\":3,\"352\":6}}],[\"hipchat\",{\"1\":{\"26\":3,\"43\":2}}],[\"highest\",{\"1\":{\"135\":1}}],[\"higherrorrate\",{\"1\":{\"66\":1}}],[\"high\",{\"1\":{\"16\":1,\"66\":1,\"67\":1,\"69\":2,\"151\":2}}],[\"hex\",{\"1\":{\"135\":1}}],[\"height\",{\"1\":{\"135\":2}}],[\"here\",{\"1\":{\"89\":2,\"90\":3,\"103\":1,\"273\":1,\"318\":1,\"352\":4}}],[\"here>\",{\"1\":{\"48\":1}}],[\"helm\",{\"0\":{\"395\":1},\"1\":{\"395\":2,\"397\":3}}],[\"help开始\",{\"1\":{\"116\":1}}],[\"help\",{\"1\":{\"33\":1,\"85\":3,\"86\":6,\"87\":1,\"89\":2,\"90\":5,\"93\":3,\"95\":4,\"99\":11,\"103\":2,\"105\":2,\"108\":1,\"109\":2,\"111\":3,\"112\":1,\"116\":6,\"139\":1,\"188\":2,\"201\":1,\"205\":1,\"217\":1,\"227\":1,\"230\":2,\"240\":1,\"267\":2,\"286\":2,\"318\":2,\"349\":3,\"351\":2,\"352\":6}}],[\"hello\",{\"1\":{\"26\":1,\"50\":1}}],[\"heap\",{\"1\":{\"167\":2}}],[\"heapmap\",{\"1\":{\"141\":2}}],[\"head>\",{\"1\":{\"134\":1}}],[\"head组件的定义\",{\"1\":{\"134\":1}}],[\"head\",{\"1\":{\"134\":4,\"160\":1}}],[\"headers\",{\"1\":{\"32\":1,\"50\":1,\"102\":2,\"317\":2}}],[\"header\",{\"1\":{\"32\":2,\"134\":1,\"319\":1}}],[\"heatmap会\\b自动根据用户定义的bucket范围对prometheus中查询到的样本数据进行分布统计\",{\"1\":{\"142\":1}}],[\"heatmap示例\",{\"1\":{\"141\":1}}],[\"heatmap是grafana\",{\"1\":{\"140\":1}}],[\"heatmap\",{\"1\":{\"123\":1,\"126\":1,\"141\":2}}],[\"heatmap面板\",{\"0\":{\"140\":1},\"1\":{\"9\":1,\"21\":1}}],[\"httpurlconnection\",{\"1\":{\"350\":2}}],[\"httpexchange\",{\"1\":{\"350\":1}}],[\"httpmetrichandler主要负责响应prometheus\",{\"1\":{\"350\":1}}],[\"httpmetrichandler\",{\"1\":{\"350\":1}}],[\"httphandler\",{\"1\":{\"350\":1}}],[\"http创建一个简单的httpserver\",{\"1\":{\"349\":1}}],[\"http或者https\",{\"1\":{\"309\":1}}],[\"http响应200\",{\"1\":{\"234\":1}}],[\"http响应状态码等等和站点访问质量相关的监控指标\",{\"1\":{\"99\":1}}],[\"http服务\",{\"1\":{\"114\":1}}],[\"http服务通常会以不同的形式对外展现\",{\"1\":{\"102\":1,\"317\":1}}],[\"http协议版本以及是否启用ssl作为控制探针探测行为成功与否的标准以外\",{\"1\":{\"103\":1,\"318\":1}}],[\"http头信息\",{\"1\":{\"102\":1,\"317\":1}}],[\"http请求状态码为500的在所有请求中的比例\",{\"1\":{\"250\":1,\"366\":1}}],[\"http请求方法\",{\"1\":{\"102\":1,\"317\":1}}],[\"http请求响应时间\",{\"1\":{\"95\":5}}],[\"http探针是进行黑盒监控时最常用的探针之一\",{\"1\":{\"101\":1,\"316\":1}}],[\"http探针\",{\"0\":{\"101\":1,\"316\":1}}],[\"http2x\",{\"1\":{\"100\":1}}],[\"http2xx\",{\"1\":{\"100\":3}}],[\"http包实现与dingtalk群机器人的交互\",{\"1\":{\"32\":1}}],[\"http\",{\"1\":{\"26\":1,\"27\":5,\"28\":3,\"32\":3,\"33\":2,\"34\":1,\"40\":1,\"55\":1,\"57\":1,\"67\":1,\"72\":2,\"86\":1,\"87\":1,\"95\":31,\"99\":35,\"100\":7,\"101\":3,\"102\":9,\"103\":17,\"116\":8,\"117\":1,\"135\":4,\"144\":1,\"150\":4,\"166\":11,\"167\":3,\"169\":1,\"190\":1,\"195\":6,\"196\":1,\"197\":1,\"201\":1,\"203\":2,\"205\":1,\"207\":1,\"214\":2,\"217\":3,\"218\":1,\"226\":6,\"228\":2,\"232\":1,\"234\":1,\"240\":11,\"246\":3,\"250\":10,\"251\":4,\"255\":1,\"257\":1,\"259\":7,\"260\":3,\"261\":4,\"262\":1,\"264\":1,\"266\":3,\"268\":6,\"269\":3,\"273\":1,\"294\":2,\"305\":2,\"306\":1,\"316\":3,\"317\":9,\"318\":17,\"325\":3,\"350\":2,\"357\":6,\"360\":4,\"361\":3,\"366\":10,\"367\":4,\"368\":6}}],[\"httpservletresponse\",{\"1\":{\"94\":2,\"95\":7}}],[\"httpservletrequest\",{\"1\":{\"94\":2,\"95\":7}}],[\"httpserver中则创建了一个httpmetrichandler用于来处理prometheus抓取监控样本数据的请求\",{\"1\":{\"350\":1}}],[\"httpserver中提供的一个简单的能够处理prometheus监控请求的http服务器实现\",{\"1\":{\"349\":1}}],[\"httpserver在接收到http请求之后\",{\"1\":{\"86\":1}}],[\"httpserver处理流程\",{\"1\":{\"86\":1}}],[\"httpserver\",{\"1\":{\"86\":3,\"349\":3,\"350\":1}}],[\"httpserver模块实现了一个简单的http服务器\",{\"1\":{\"86\":1}}],[\"https\",{\"1\":{\"13\":1,\"14\":1,\"15\":2,\"16\":8,\"17\":1,\"18\":1,\"26\":5,\"30\":1,\"45\":2,\"48\":4,\"49\":1,\"51\":1,\"54\":1,\"75\":2,\"99\":1,\"100\":2,\"123\":1,\"181\":1,\"187\":1,\"189\":1,\"190\":3,\"192\":2,\"199\":4,\"200\":2,\"202\":2,\"207\":2,\"223\":1,\"273\":1,\"285\":1,\"305\":1,\"373\":1,\"397\":1}}],[\"html下载对应操作系统版本的软件包\",{\"1\":{\"305\":1}}],[\"html文件均使用了go\",{\"1\":{\"134\":1}}],[\"html文件中\",{\"1\":{\"134\":1}}],[\"html文件中还未填充任何内容\",{\"1\":{\"133\":1}}],[\"html文件\",{\"1\":{\"133\":1}}],[\"html文件后\",{\"1\":{\"133\":1}}],[\"html\",{\"1\":{\"16\":1,\"50\":2}}],[\"什么是prometheus\",{\"0\":{\"220\":1},\"1\":{\"10\":1,\"22\":1}}],[\"联邦集群的特性可以帮助用户根据不同的监控规模对prometheus部署架构进行调整\",{\"1\":{\"170\":1}}],[\"联邦集群的特性可以让prometheus将样本采集任务划分到不同的prometheus实例中\",{\"1\":{\"145\":1}}],[\"联邦集群的核心在于每一个prometheus\",{\"1\":{\"169\":1}}],[\"联邦集群\",{\"0\":{\"155\":1,\"168\":1},\"1\":{\"9\":1,\"21\":1,\"155\":1,\"157\":1,\"169\":1}}],[\"本节将带领读者在kubernetes中部署node\",{\"1\":{\"204\":1}}],[\"本示例部署结构如下所示\",{\"1\":{\"151\":1}}],[\"本地电脑\",{\"1\":{\"292\":1}}],[\"本地webhook服务可以直接从github获取\",{\"1\":{\"150\":1}}],[\"本地存储配置\",{\"0\":{\"160\":1}}],[\"本地存储\",{\"0\":{\"159\":1},\"1\":{\"9\":1,\"21\":1}}],[\"本小节将带读者了解一些常用的内置函数以及相关的使用场景和用法\",{\"1\":{\"237\":1}}],[\"本小节将带领读者了解promrtheus提供的client\",{\"1\":{\"97\":1}}],[\"本小节将以spring\",{\"1\":{\"93\":1}}],[\"本小节\",{\"1\":{\"92\":1}}],[\"本章小结\",{\"0\":{\"271\":1}}],[\"本章内容\",{\"1\":{\"270\":1}}],[\"本章作为全书的开篇\",{\"1\":{\"270\":1}}],[\"本章将带领读者探秘prometheus的自定义查询语言promql\",{\"1\":{\"224\":1}}],[\"本章\",{\"1\":{\"208\":1}}],[\"本章中将介绍prometheus是如何通过服务发现机制完美解决云原生场景下的监控挑战的\",{\"1\":{\"302\":1}}],[\"本章中\",{\"1\":{\"171\":1}}],[\"本章的最后部分会讨论如何实现alertmanager的高可用部署\",{\"1\":{\"145\":1}}],[\"本章的主要内容\",{\"1\":{\"82\":1,\"118\":1,\"145\":1,\"171\":1,\"208\":1,\"224\":1,\"302\":1}}],[\"本章学习的内容就主要解决以上问题\",{\"1\":{\"118\":1}}],[\"本章主要内容\",{\"1\":{\"24\":1}}],[\"本章我们将带领读者探索prometheus的告警处理机制\",{\"1\":{\"24\":1}}],[\"本书则重点放在prometheus的高级实践\",{\"1\":{\"1\":1}}],[\"本书主要分为三个部分\",{\"1\":{\"1\":1}}],[\"本书是一本介绍prometheus以及周边相关技术的实践书籍\",{\"1\":{\"1\":1}}],[\"集合运算符\",{\"0\":{\"364\":1}}],[\"集群资源用量\",{\"1\":{\"232\":1}}],[\"集群节点资源用量监控\",{\"1\":{\"184\":1}}],[\"集群节点状态监控\",{\"1\":{\"184\":1}}],[\"集群内的prometheus能够非常简单的通过域名\",{\"1\":{\"195\":1}}],[\"集群内的应用就可以通过使用service的名称作为dns域名进行相互访问\",{\"1\":{\"178\":1}}],[\"集群内的应用如何通信\",{\"1\":{\"178\":1}}],[\"集群内应用和应用之间访问时提供内部的负载均衡\",{\"1\":{\"180\":1}}],[\"集群服务运行在8002端口\",{\"1\":{\"149\":1}}],[\"集群服务地址运行在8001端口\",{\"1\":{\"149\":1}}],[\"集群与高可用\",{\"0\":{\"145\":1},\"1\":{\"9\":1,\"21\":1}}],[\"集成到应用中的\",{\"1\":{\"115\":1}}],[\"集成钉钉\",{\"1\":{\"8\":1,\"20\":1}}],[\"集成企业微信\",{\"1\":{\"8\":1,\"20\":1}}],[\"集成slack\",{\"1\":{\"8\":1,\"20\":1}}],[\"集成邮件系统\",{\"1\":{\"8\":1,\"20\":1}}],[\"guest\",{\"1\":{\"310\":1}}],[\"guava\",{\"1\":{\"87\":1}}],[\"guage这样的构造器均可实现自定义监控指标\",{\"1\":{\"352\":1}}],[\"guage的所有样本值\",{\"1\":{\"85\":1}}],[\"guage的监控指标\",{\"1\":{\"85\":1}}],[\"guage\",{\"1\":{\"85\":1,\"86\":4}}],[\"gnocchi\",{\"1\":{\"167\":1}}],[\"gmt\",{\"1\":{\"117\":1}}],[\"gmail\",{\"1\":{\"50\":1}}],[\"gluster\",{\"1\":{\"114\":1}}],[\"glob>\",{\"1\":{\"66\":1,\"72\":1}}],[\"global\",{\"1\":{\"26\":2,\"27\":1,\"33\":1,\"49\":2,\"50\":2,\"51\":4,\"55\":1,\"66\":1,\"72\":2,\"109\":18,\"110\":11,\"111\":21,\"112\":6,\"151\":1,\"156\":1,\"174\":1,\"187\":1,\"190\":1,\"210\":1,\"214\":1,\"218\":1,\"273\":4,\"305\":1,\"307\":1,\"377\":1,\"397\":1}}],[\"gauage等构造监控指标以外\",{\"1\":{\"96\":1}}],[\"gauge是一个可增可减的仪表盘\",{\"1\":{\"352\":1}}],[\"gauge类型的指标侧重于反应系统的当前状态\",{\"1\":{\"229\":1}}],[\"gauge对象主要包含两个方法inc\",{\"1\":{\"89\":1}}],[\"gauge继承自collector\",{\"1\":{\"89\":1}}],[\"gaugemetricfamily\",{\"1\":{\"85\":3,\"96\":3,\"351\":3}}],[\"gauge\",{\"0\":{\"138\":1,\"229\":1},\"1\":{\"85\":3,\"86\":10,\"87\":1,\"88\":1,\"89\":4,\"93\":1,\"95\":2,\"99\":11,\"103\":2,\"105\":9,\"108\":1,\"111\":1,\"116\":1,\"188\":2,\"201\":1,\"205\":1,\"217\":1,\"227\":1,\"267\":1,\"286\":2,\"318\":2,\"349\":2,\"351\":2,\"352\":3}}],[\"gateway\",{\"1\":{\"95\":1}}],[\"gatewayapplication\",{\"1\":{\"93\":1}}],[\"garbagecollectors\",{\"1\":{\"350\":5}}],[\"garbagecollectormxbean\",{\"1\":{\"350\":2}}],[\"garbagecollectorexports\",{\"1\":{\"350\":4}}],[\"garbage\",{\"1\":{\"93\":1,\"349\":1,\"350\":1}}],[\"gccollection\",{\"1\":{\"350\":3}}],[\"gc=\",{\"1\":{\"93\":4,\"349\":4}}],[\"gc\",{\"1\":{\"87\":1,\"93\":6,\"167\":5,\"349\":6,\"350\":6}}],[\"generation=\",{\"1\":{\"207\":1}}],[\"general中的repeat选项\",{\"1\":{\"131\":1}}],[\"general\",{\"1\":{\"126\":1,\"141\":1}}],[\"generic\",{\"1\":{\"26\":1,\"109\":1,\"111\":2,\"112\":1,\"214\":1}}],[\"getcollectiontime\",{\"1\":{\"350\":1}}],[\"getcollectioncount\",{\"1\":{\"350\":1}}],[\"getname\",{\"1\":{\"350\":1}}],[\"getgarbagecollectormxbeans\",{\"1\":{\"350\":1}}],[\"getresponsebody\",{\"1\":{\"350\":2}}],[\"getresponseheaders\",{\"1\":{\"350\":3}}],[\"getrequesturi\",{\"1\":{\"95\":1,\"350\":1}}],[\"getrawquery\",{\"1\":{\"350\":1}}],[\"get命令查看当前deployment的部署进度\",{\"1\":{\"181\":1}}],[\"get命令获取blackbox\",{\"1\":{\"99\":1}}],[\"get会自动将其编译成可执行文件\",{\"1\":{\"150\":1}}],[\"get的方式对目标服务进行探测\",{\"1\":{\"101\":1,\"316\":1}}],[\"getstatus\",{\"1\":{\"95\":1}}],[\"getmethod\",{\"1\":{\"95\":1}}],[\"get\",{\"1\":{\"85\":1,\"89\":2,\"95\":21,\"99\":2,\"102\":1,\"103\":2,\"134\":1,\"149\":1,\"150\":1,\"160\":1,\"167\":1,\"175\":2,\"181\":5,\"186\":4,\"187\":3,\"189\":1,\"192\":2,\"193\":1,\"199\":1,\"201\":2,\"202\":2,\"203\":2,\"205\":2,\"206\":2,\"214\":2,\"216\":2,\"217\":2,\"219\":3,\"223\":1,\"246\":2,\"250\":4,\"251\":2,\"255\":1,\"257\":1,\"259\":3,\"260\":2,\"266\":1,\"268\":4,\"317\":1,\"318\":2,\"350\":1,\"357\":4,\"360\":3,\"361\":2,\"366\":4,\"367\":2,\"400\":1}}],[\"gzipoutputstream\",{\"1\":{\"350\":2}}],[\"gzip\",{\"1\":{\"117\":1,\"350\":1}}],[\"gz\",{\"1\":{\"54\":2,\"273\":2,\"285\":2,\"373\":3}}],[\"gt\",{\"1\":{\"51\":10}}],[\"ghost\",{\"1\":{\"48\":1}}],[\"given\",{\"1\":{\"72\":1,\"87\":1,\"93\":1,\"349\":2,\"350\":1}}],[\"git\",{\"1\":{\"223\":2}}],[\"gitlab等源码管理服务\",{\"1\":{\"29\":1}}],[\"github地址\",{\"1\":{\"348\":1}}],[\"github源码\",{\"1\":{\"177\":1}}],[\"github\",{\"1\":{\"15\":1,\"16\":3,\"28\":2,\"29\":1,\"31\":1,\"32\":2,\"33\":1,\"45\":1,\"54\":1,\"75\":2,\"114\":1,\"149\":1,\"150\":1,\"166\":4,\"167\":1,\"181\":1,\"218\":1,\"223\":1,\"273\":1,\"285\":1,\"349\":1,\"373\":1,\"400\":1}}],[\"gin\",{\"1\":{\"28\":6,\"33\":2}}],[\"got\",{\"1\":{\"305\":1}}],[\"gokit等\",{\"1\":{\"277\":1}}],[\"golden\",{\"1\":{\"234\":1}}],[\"golang\",{\"1\":{\"134\":1,\"166\":1}}],[\"golang这样的编程语言\",{\"1\":{\"5\":1}}],[\"goroutines\",{\"1\":{\"167\":1}}],[\"goreman\",{\"1\":{\"149\":1,\"150\":1,\"151\":1,\"400\":2}}],[\"go会自动把相关的源码编译成可执行文件\",{\"1\":{\"167\":1}}],[\"gogo\",{\"1\":{\"166\":1}}],[\"gossip机制\",{\"1\":{\"148\":1}}],[\"gossip机制的关键在于两点\",{\"1\":{\"148\":1}}],[\"gossip机制为多个alertmanager之间提供了信息传递的机制\",{\"1\":{\"147\":1}}],[\"gossip会通知其他alertmanager实例当前告警已经发送\",{\"1\":{\"148\":1}}],[\"gossip分布式协议\",{\"1\":{\"148\":1}}],[\"gossip是分布式系统中被广泛使用的协议\",{\"1\":{\"148\":1}}],[\"gossip协议同步状态类似于流言或者病毒的传播\",{\"1\":{\"148\":1}}],[\"gossip协议\",{\"0\":{\"148\":1}}],[\"gossip\",{\"1\":{\"147\":1,\"305\":1}}],[\"google运维解密\",{\"1\":{\"289\":1}}],[\"google\",{\"1\":{\"105\":2}}],[\"good\",{\"1\":{\"49\":2}}],[\"go\",{\"1\":{\"99\":1,\"114\":1,\"149\":1,\"150\":9,\"151\":3,\"166\":1,\"167\":14,\"218\":2,\"273\":6,\"285\":1,\"286\":1,\"298\":1,\"347\":1,\"400\":1}}],[\"gonic\",{\"1\":{\"28\":1}}],[\"gonic框架创建用于接收webhook通知的web服务\",{\"1\":{\"28\":1}}],[\"g\",{\"1\":{\"27\":1,\"45\":1}}],[\"grok\",{\"1\":{\"114\":1}}],[\"group=node\",{\"1\":{\"374\":1}}],[\"group修饰符只能在比较和数学运算符中使用\",{\"1\":{\"251\":1,\"367\":1}}],[\"grouped\",{\"1\":{\"134\":1}}],[\"group的具体配置项如下所示\",{\"1\":{\"72\":1}}],[\"group>\",{\"1\":{\"72\":1}}],[\"groups\",{\"1\":{\"66\":1,\"67\":1,\"69\":1,\"72\":2,\"151\":1,\"213\":1,\"310\":2}}],[\"grouplabels`\",{\"1\":{\"28\":1}}],[\"grouplabels\",{\"1\":{\"27\":1,\"28\":1,\"45\":4}}],[\"group\",{\"1\":{\"27\":1,\"40\":4,\"42\":5,\"50\":1,\"51\":3,\"55\":3,\"72\":2,\"214\":3,\"251\":6,\"367\":6}}],[\"groupkey\",{\"1\":{\"27\":1,\"28\":2,\"31\":4}}],[\"gradle中添加依赖\",{\"1\":{\"349\":1}}],[\"gradle添加simpleclient依赖\",{\"1\":{\"85\":1}}],[\"graph还可以非常方便的支持多个数据之间的对比\",{\"1\":{\"136\":1}}],[\"graph函数显示可视化图表以外\",{\"1\":{\"135\":1}}],[\"graph函数\",{\"1\":{\"135\":1}}],[\"graph\",{\"1\":{\"123\":1,\"126\":1,\"134\":1,\"135\":10,\"259\":1,\"260\":1,\"282\":1,\"283\":1}}],[\"graphite使用whisper的格式将时间序列数据存储在本地磁盘中\",{\"1\":{\"326\":1}}],[\"graphite中的监控指标通过一组基于\",{\"1\":{\"325\":1}}],[\"graphite和prometheus一样\",{\"1\":{\"325\":1}}],[\"graphite专注于时序数据库本身\",{\"1\":{\"324\":1}}],[\"graphite\",{\"0\":{\"323\":1},\"1\":{\"114\":1,\"122\":1,\"167\":1,\"298\":1}}],[\"graph面板重新计算了bucket边界\",{\"1\":{\"139\":1}}],[\"graph面板则会在\\b图表中显示一条阈值\",{\"1\":{\"138\":1}}],[\"graph面板支持如日期\",{\"1\":{\"138\":1}}],[\"graph面板会从时间序列中获取样本数据\",{\"1\":{\"138\":1}}],[\"graph面板通过折线图或者柱状图的形式\",{\"1\":{\"137\":1}}],[\"graph面板与prometheus\",{\"0\":{\"137\":1}}],[\"graph面板天生适用于prometheus中gauge和counter类型监控指标的监控数据可视化\",{\"1\":{\"136\":1}}],[\"graph面板是最常用的一种可视化面板\",{\"1\":{\"136\":1}}],[\"graph面板和heatmap面板的数据可视化\",{\"1\":{\"126\":1}}],[\"graph面板\",{\"0\":{\"136\":1},\"1\":{\"9\":1,\"21\":1,\"136\":1}}],[\"grafana中所有的dashboard通过json进行共享\",{\"1\":{\"283\":1}}],[\"grafana中所有的面板均以插件的形式进行使用\",{\"1\":{\"126\":1}}],[\"grafana社区鼓励用户分享dashboard通过https\",{\"1\":{\"283\":1}}],[\"grafana向导\",{\"1\":{\"283\":1}}],[\"grafana是一个开源的可视化平台\",{\"1\":{\"283\":1}}],[\"grafana目前支持6种不同的变量类型\",{\"1\":{\"129\":1}}],[\"grafana通过将变量渲染为一个下拉框选项\",{\"1\":{\"128\":1}}],[\"grafana通过插件的形式提供了多种\\b\\bpanel的实现\",{\"1\":{\"123\":1}}],[\"grafana能够方便的将prometheus返回的数据进行可视化展示\",{\"1\":{\"127\":1}}],[\"grafana会自动根据样本的\\b中的le标签\",{\"1\":{\"141\":1}}],[\"grafana会自动将$node的值格式化为如\",{\"1\":{\"128\":1}}],[\"grafana会根据当前用户的选择\",{\"1\":{\"131\":1}}],[\"grafana会将prometeus返回的10个样本数据合并成一个点\",{\"1\":{\"126\":1}}],[\"grafana会加载当前组织中添加的所有数据源\",{\"1\":{\"126\":1}}],[\"grafana支持通过模板的方式\",{\"1\":{\"126\":1}}],[\"grafana提供了对promql的完整支持\",{\"1\":{\"126\":1,\"283\":1}}],[\"grafana则用于需要查询grafana自身状态时使用\",{\"1\":{\"126\":1}}],[\"grafana除了提供灵活的可视化定制能力以外\",{\"1\":{\"124\":1}}],[\"grafana还提供了几个有用的函数\",{\"1\":{\"130\":1}}],[\"grafana还专门为dashboard提供了一个共享服务\",{\"1\":{\"123\":1}}],[\"grafana还允许用户为dashboard定义templating\",{\"1\":{\"123\":1}}],[\"grafana\",{\"1\":{\"123\":2,\"283\":3,\"399\":1,\"400\":1}}],[\"grafana便可以轻松的实现对这些\\b数据的可视化工作\",{\"1\":{\"122\":1}}],[\"grafana官方提供了对\",{\"1\":{\"122\":1}}],[\"grafana基本概念\",{\"0\":{\"121\":1}}],[\"grafana简介\",{\"0\":{\"120\":1}}],[\"grafana与数据可视化\",{\"0\":{\"125\":1},\"1\":{\"9\":1,\"21\":1}}],[\"grafana的基本概念\",{\"1\":{\"9\":1,\"21\":1}}],[\"常量\",{\"1\":{\"129\":1}}],[\"常用的如\",{\"1\":{\"123\":1}}],[\"常用exporter的使用\",{\"1\":{\"82\":1}}],[\"常用exporter\",{\"0\":{\"92\":1},\"1\":{\"9\":1,\"21\":1,\"114\":1}}],[\"常见指标如\",{\"1\":{\"229\":1}}],[\"常见的如http探针\",{\"1\":{\"289\":1}}],[\"常见的监控指标\",{\"1\":{\"228\":1}}],[\"常见的黑盒监控包括http探针\",{\"1\":{\"98\":1}}],[\"常见拼写错误\",{\"1\":{\"4\":1}}],[\"屏蔽告警通知\",{\"0\":{\"35\":1},\"1\":{\"8\":1,\"20\":1}}],[\"自动创建endpoint资源\",{\"1\":{\"206\":1}}],[\"自动创建一个到多个panel实例\",{\"1\":{\"131\":1}}],[\"自动的找到这些\\bcadvisor的采集目标\",{\"1\":{\"188\":1}}],[\"自动的发现那些需要监控的资源和服务\",{\"1\":{\"5\":1}}],[\"自定义exporter实战\",{\"0\":{\"347\":1}}],[\"自定义serviceaccount\",{\"0\":{\"219\":1}}],[\"自定义remote\",{\"0\":{\"166\":1}}],[\"自定义菜单\",{\"1\":{\"134\":1}}],[\"自定义探针行为\",{\"0\":{\"103\":1,\"318\":1}}],[\"自定义http请求\",{\"0\":{\"102\":1,\"317\":1}}],[\"自定义监控指标\",{\"0\":{\"95\":1}}],[\"自定义collector\",{\"0\":{\"85\":1,\"351\":1}}],[\"自定义标签\",{\"1\":{\"66\":1}}],[\"自定义消息\",{\"1\":{\"48\":1}}],[\"自定义可复用的模板文件\",{\"1\":{\"45\":1}}],[\"自定义告警模板\",{\"0\":{\"45\":1}}],[\"自定义机器人\",{\"1\":{\"30\":1}}],[\"自定义webhook群机器人\",{\"0\":{\"30\":1}}],[\"自定义prometheus告警规则\",{\"0\":{\"65\":1},\"1\":{\"8\":1,\"20\":1}}],[\"4大黄金信号\",{\"1\":{\"235\":1}}],[\"4个黄金指标可以在服务级别帮助衡量终端用户体验\",{\"1\":{\"234\":1}}],[\"4个黄金指标\",{\"0\":{\"234\":1},\"1\":{\"235\":1}}],[\"4个黄金指标和use方法\",{\"0\":{\"231\":1},\"1\":{\"8\":1,\"20\":1,\"224\":1}}],[\"452108433z\",{\"1\":{\"218\":1}}],[\"45m\",{\"1\":{\"181\":3,\"216\":1}}],[\"48\",{\"1\":{\"218\":1}}],[\"4ce5\",{\"1\":{\"207\":1}}],[\"4s\",{\"1\":{\"203\":1}}],[\"4m\",{\"1\":{\"187\":2,\"206\":2}}],[\"4193\",{\"1\":{\"190\":1}}],[\"4194的形式覆盖\",{\"1\":{\"190\":1}}],[\"4194\",{\"1\":{\"188\":1,\"190\":1}}],[\"41\",{\"1\":{\"151\":6}}],[\"44\",{\"1\":{\"150\":9}}],[\"443即可\",{\"1\":{\"202\":1}}],[\"443\",{\"1\":{\"111\":2,\"175\":1,\"181\":1,\"190\":2,\"192\":3,\"199\":2,\"200\":1,\"202\":2}}],[\"4096\",{\"1\":{\"305\":1}}],[\"409600\",{\"1\":{\"230\":1}}],[\"404\",{\"1\":{\"250\":2,\"251\":2,\"253\":1,\"268\":2,\"366\":2,\"367\":2}}],[\"40s以内\",{\"1\":{\"193\":1}}],[\"405638714z\",{\"1\":{\"150\":1}}],[\"400\",{\"1\":{\"230\":1}}],[\"400mi\",{\"1\":{\"210\":1,\"213\":1,\"214\":1,\"216\":1,\"218\":1,\"219\":1}}],[\"400212246z\",{\"1\":{\"150\":1}}],[\"40004678z\",{\"1\":{\"150\":1}}],[\"4785\",{\"1\":{\"268\":1}}],[\"4748\",{\"1\":{\"268\":1}}],[\"47\",{\"1\":{\"117\":1,\"305\":1}}],[\"4773\",{\"1\":{\"116\":1}}],[\"46750749b97bae47921d49dccdf9011b503e954312b8cffdec6268c249afa2dd\",{\"1\":{\"105\":1}}],[\"499531z\",{\"1\":{\"273\":1}}],[\"499484z\",{\"1\":{\"273\":1}}],[\"49\",{\"1\":{\"105\":1}}],[\"422\",{\"1\":{\"253\":1}}],[\"420\",{\"1\":{\"210\":1}}],[\"4286002507\",{\"1\":{\"207\":1}}],[\"42s\",{\"1\":{\"175\":1}}],[\"42\",{\"1\":{\"85\":1,\"86\":1,\"206\":1,\"351\":1}}],[\"4h\",{\"1\":{\"40\":1,\"42\":1}}],[\"4\",{\"1\":{\"27\":1,\"85\":2,\"86\":2,\"90\":1,\"99\":1,\"105\":2,\"117\":1,\"139\":1,\"142\":1,\"156\":1,\"159\":1,\"187\":1,\"229\":1,\"239\":1,\"260\":6,\"273\":1,\"280\":2,\"312\":2,\"351\":1}}],[\"43\",{\"1\":{\"16\":1,\"150\":6}}],[\"4月变更内容\",{\"1\":{\"3\":1}}],[\"最新的grafana可视化工具也已经提供了完整的prometheus支持\",{\"1\":{\"299\":1}}],[\"最终的运算结果如下\",{\"1\":{\"251\":1,\"367\":1}}],[\"最简单的方式就是按照请求延迟的范围进行分组\",{\"1\":{\"230\":1}}],[\"最大值\",{\"1\":{\"226\":1,\"368\":1}}],[\"最小值\",{\"1\":{\"226\":1,\"368\":1}}],[\"最直接的方式就是停止prometheus并且删除data目录中的所有记录\",{\"1\":{\"161\":1}}],[\"最直接的方式\",{\"1\":{\"147\":1}}],[\"最直观的配置方式\",{\"1\":{\"100\":1}}],[\"最主要的需要了解的就是metrics设置的使用\",{\"1\":{\"126\":1}}],[\"最主要的能力就是定义动态panel的能力\",{\"1\":{\"126\":1}}],[\"最重要的工作就是实现对数据的增\",{\"1\":{\"109\":1}}],[\"最多只能配置其中的一个\",{\"1\":{\"99\":1}}],[\"最佳实践\",{\"0\":{\"231\":1},\"1\":{\"8\":1,\"20\":1}}],[\"最后对于复杂类型的表达式\",{\"1\":{\"369\":1}}],[\"最后prometheus\",{\"1\":{\"276\":1}}],[\"最后除以时间120秒得到node\",{\"1\":{\"238\":1}}],[\"最后查看service的详细信息\",{\"1\":{\"206\":1}}],[\"最后则是将该账号与角色进行绑定\",{\"1\":{\"186\":1}}],[\"最后本地存储也导致prometheus无法进行弹性扩展\",{\"1\":{\"145\":1}}],[\"最后其管理也有一定的成本\",{\"1\":{\"120\":1}}],[\"最后需要提醒的时\",{\"1\":{\"103\":1,\"318\":1}}],[\"最后通过labelmap将该节点上的自定义标签\",{\"1\":{\"190\":1}}],[\"最后通过\",{\"1\":{\"95\":1}}],[\"最后通过register\",{\"1\":{\"95\":1}}],[\"最后格式化为prometheus的标准输出\",{\"1\":{\"86\":1}}],[\"最后\",{\"1\":{\"1\":1,\"178\":1,\"180\":1,\"184\":1,\"203\":1}}],[\"amazonaws\",{\"1\":{\"397\":1}}],[\"amd64\",{\"1\":{\"54\":2,\"187\":1,\"189\":1,\"273\":3,\"285\":4,\"373\":5}}],[\"aa\",{\"1\":{\"305\":1}}],[\"a82a\",{\"1\":{\"207\":1}}],[\"affinity\",{\"1\":{\"206\":1}}],[\"after=network\",{\"1\":{\"374\":1}}],[\"after\",{\"1\":{\"160\":1}}],[\"aftercompletion\",{\"1\":{\"94\":2,\"95\":6}}],[\"against\",{\"1\":{\"310\":3}}],[\"age\",{\"1\":{\"175\":2,\"181\":5,\"186\":1,\"187\":1,\"192\":2,\"201\":2,\"202\":2,\"203\":2,\"205\":2,\"206\":2,\"214\":2,\"216\":2,\"217\":1,\"223\":1}}],[\"agent\",{\"1\":{\"51\":3,\"305\":6}}],[\"ago\",{\"1\":{\"167\":1}}],[\"according\",{\"1\":{\"273\":1}}],[\"access\",{\"1\":{\"30\":1,\"186\":1}}],[\"action>\",{\"1\":{\"310\":1}}],[\"actions\",{\"1\":{\"310\":2}}],[\"action\",{\"1\":{\"156\":2,\"190\":4,\"192\":1,\"193\":1,\"196\":2,\"197\":2,\"199\":3,\"200\":2,\"201\":6,\"202\":1,\"203\":6,\"207\":8,\"214\":2,\"218\":10,\"310\":5,\"311\":1,\"312\":3}}],[\"active\",{\"1\":{\"150\":3,\"151\":3}}],[\"a3服务\",{\"1\":{\"150\":1}}],[\"a3\",{\"1\":{\"150\":4,\"151\":1}}],[\"a1\",{\"1\":{\"150\":6,\"151\":1}}],[\"a2重启a2\",{\"1\":{\"150\":1}}],[\"a2\",{\"1\":{\"150\":3,\"151\":1}}],[\"a2启动时需要定义\",{\"1\":{\"149\":1}}],[\"a2组成集群\",{\"1\":{\"149\":1}}],[\"axes\\b设置\\b\",{\"1\":{\"142\":1}}],[\"axes设置\\b\",{\"1\":{\"141\":1}}],[\"axes\",{\"1\":{\"141\":1}}],[\"axes选项\",{\"1\":{\"138\":1}}],[\"axis\",{\"1\":{\"135\":6,\"142\":1}}],[\"a><\",{\"1\":{\"134\":2}}],[\"a>\",{\"1\":{\"134\":1}}],[\"aws\",{\"1\":{\"114\":1}}],[\"ab公司开发\",{\"1\":{\"107\":1}}],[\"abstract\",{\"1\":{\"90\":1}}],[\"aborted\",{\"1\":{\"110\":3}}],[\"above\",{\"1\":{\"67\":1,\"69\":2,\"151\":2}}],[\"about\",{\"1\":{\"27\":1,\"51\":1}}],[\"available\",{\"1\":{\"181\":1,\"201\":1,\"205\":1,\"305\":1,\"310\":2}}],[\"availability\",{\"1\":{\"16\":1}}],[\"average\",{\"1\":{\"105\":9,\"116\":1,\"267\":1,\"286\":1}}],[\"avg\",{\"1\":{\"69\":1,\"126\":1,\"127\":1,\"128\":1,\"138\":1,\"151\":1,\"226\":1,\"248\":1,\"262\":1,\"282\":2,\"368\":1,\"369\":1,\"378\":2}}],[\"alive\",{\"1\":{\"305\":1}}],[\"alpha\",{\"1\":{\"187\":2,\"189\":2}}],[\"alpine\",{\"1\":{\"105\":1}}],[\"alter\",{\"1\":{\"109\":2}}],[\"alermanager会将数据保存到本地中\",{\"1\":{\"56\":1}}],[\"alert=hostcpuusagealert\",{\"1\":{\"151\":3}}],[\"alert=diskrunningfull\",{\"1\":{\"150\":3}}],[\"alerting\",{\"1\":{\"58\":1,\"151\":2,\"214\":1,\"218\":1,\"273\":1}}],[\"alert菜单下可以查看alertmanager接收到的告警内容\",{\"1\":{\"57\":1}}],[\"alertname=\",{\"1\":{\"68\":1}}],[\"alertname\",{\"1\":{\"36\":1,\"40\":1,\"42\":1,\"45\":2,\"50\":1,\"51\":3,\"55\":2,\"150\":5,\"151\":1}}],[\"alertmanaer\",{\"1\":{\"28\":1,\"29\":1,\"31\":1,\"32\":2,\"33\":1}}],[\"alertmanager即prometheus体系中的告警处理中心\",{\"1\":{\"278\":1}}],[\"alertmanager即prometheus体系中告警的统一处理中心\",{\"1\":{\"24\":1}}],[\"alertmanagerwh\",{\"1\":{\"214\":1}}],[\"alertmanager集群状态\",{\"1\":{\"150\":1,\"214\":1}}],[\"alertmanager2\",{\"1\":{\"149\":1,\"150\":2}}],[\"alertmanager基于gossip实现的集群机制虽然不能保证所有实例上的数据时刻保持一致\",{\"1\":{\"148\":1}}],[\"alertmanager启动阶段基于pull\",{\"1\":{\"148\":1}}],[\"alertmanager启动后可以通过9093端口访问\",{\"1\":{\"57\":1}}],[\"alertmanager引入了gossip机制\",{\"1\":{\"147\":1}}],[\"alertmanager也可以自动将这些告警合并为一个通知向receiver发送\",{\"1\":{\"147\":1}}],[\"alertmanager也支持用户定义和使用自己的模板\",{\"1\":{\"45\":1}}],[\"alertmanager成为单点\",{\"1\":{\"147\":1}}],[\"alertmanager作为prometheus体系中的告警处理中心\",{\"1\":{\"145\":1}}],[\"alertmanager作为一个独立的组件\",{\"1\":{\"60\":1}}],[\"alertmanager则不会发送告警通知\",{\"1\":{\"64\":1}}],[\"alertmanager除了提供基本的告警通知能力以外\",{\"1\":{\"61\":1}}],[\"alertmanager特性\",{\"0\":{\"61\":1},\"1\":{\"61\":1,\"147\":1}}],[\"alertmanager可以对这些告警信息进行进一步的处理\",{\"1\":{\"60\":1}}],[\"alertmanager可以对告警通知进行分组\",{\"1\":{\"42\":1}}],[\"alertmanagers\",{\"1\":{\"58\":1,\"151\":2,\"214\":2,\"273\":1}}],[\"alertmanager页面\",{\"1\":{\"57\":1}}],[\"alertmanager解压后会包含一个默认的alertmanager\",{\"1\":{\"55\":1}}],[\"alertmanager最新版本的下载地址可以从prometheus官方网站https\",{\"1\":{\"54\":1}}],[\"alertmanager和prometheus\",{\"1\":{\"52\":1}}],[\"alertmanager已经内置了对企业微信的支持\",{\"1\":{\"51\":1}}],[\"alertmanager内置了对smtp协议的支持\",{\"1\":{\"50\":1}}],[\"alertmanager将会按照标签product和environment对告警进行分组\",{\"1\":{\"42\":1}}],[\"alertmanager会根据当前alertmanager在集群中所在的顺序\",{\"1\":{\"148\":1}}],[\"alertmanager会判断当前通知是否匹配到任何的静默规则\",{\"1\":{\"148\":1}}],[\"alertmanager会开始加载该规则并且设置状态为pending\",{\"1\":{\"37\":1,\"39\":1}}],[\"alertmanager会按照以下格式向这些url地址发送http\",{\"1\":{\"27\":1}}],[\"alertmanager的配置主要包含两个部分\",{\"1\":{\"55\":1}}],[\"alertmanager的通知模板基于go的模板系统\",{\"1\":{\"45\":1}}],[\"alertmanager的通知方式中还可以支持webhook\",{\"1\":{\"43\":1}}],[\"alertmanager的抑制机制可以避免当某种问题告警产生之后用户接收到大量由此问题导致的一系列的其它告警通知\",{\"1\":{\"36\":1}}],[\"alertmanager的一个通知中根据配置的group\",{\"1\":{\"28\":1}}],[\"alertmanager提供了方式可以帮助用户控制告警通知的行为\",{\"1\":{\"35\":1}}],[\"alertmanager提供了多种内置第三方告警通知方式\",{\"1\":{\"24\":1}}],[\"alertmanager主要负责对prometheus产生的告警进行统一处理\",{\"1\":{\"26\":1}}],[\"alertmanager组件则用于处理这些由prometheus产生的告警\",{\"1\":{\"24\":1}}],[\"alertmanager\",{\"0\":{\"278\":1},\"1\":{\"23\":1,\"27\":1,\"31\":1,\"45\":2,\"51\":1,\"54\":3,\"56\":1,\"147\":1,\"149\":5,\"150\":13,\"214\":14,\"222\":1,\"273\":2,\"392\":1}}],[\"alertmanager高可用部署架构\",{\"1\":{\"145\":1}}],[\"alertmanager高可用\",{\"0\":{\"147\":1},\"1\":{\"9\":1,\"21\":1}}],[\"alertmanager配置概述\",{\"0\":{\"26\":1},\"1\":{\"8\":1,\"20\":1}}],[\"alerts1=\",{\"1\":{\"150\":1}}],[\"alerts可以查看当前告警的活动状态\",{\"1\":{\"69\":1}}],[\"alertstate=\",{\"1\":{\"68\":1}}],[\"alerts`\",{\"1\":{\"28\":1}}],[\"alerts\",{\"1\":{\"23\":1,\"27\":3,\"28\":1,\"31\":1,\"37\":1,\"39\":1,\"45\":4,\"48\":1,\"51\":5,\"68\":1,\"134\":1,\"150\":6,\"151\":1,\"259\":1,\"260\":1,\"357\":2}}],[\"alert\",{\"1\":{\"23\":2,\"26\":2,\"28\":3,\"31\":3,\"48\":1,\"66\":2,\"67\":4,\"68\":1,\"69\":3,\"150\":3,\"151\":6,\"213\":3,\"214\":1,\"218\":1,\"290\":1}}],[\"alloc\",{\"1\":{\"167\":3}}],[\"all\",{\"1\":{\"51\":1,\"99\":1,\"130\":1,\"131\":1,\"156\":1}}],[\"adapter并且设置influxdb相关的认证信息\",{\"1\":{\"167\":1}}],[\"adapter源码后\",{\"1\":{\"167\":1}}],[\"adapter\",{\"1\":{\"167\":3}}],[\"adaptor根据请求条件从第三方存储服务中获取响应的数据\",{\"1\":{\"164\":1}}],[\"adaptor\",{\"0\":{\"166\":1},\"1\":{\"163\":1}}],[\"advertise\",{\"1\":{\"150\":1}}],[\"admin进行登录\",{\"1\":{\"283\":1}}],[\"admin\",{\"1\":{\"109\":1,\"167\":3}}],[\"administrator\",{\"1\":{\"0\":1}}],[\"addr\",{\"1\":{\"305\":2,\"350\":1}}],[\"addresses\",{\"1\":{\"206\":1}}],[\"address执行blackbox\",{\"1\":{\"203\":1}}],[\"address参数指定当前节点所在网络地址\",{\"1\":{\"150\":1}}],[\"address=0\",{\"1\":{\"273\":1}}],[\"address=\",{\"1\":{\"149\":4,\"150\":8,\"151\":3}}],[\"address\",{\"1\":{\"100\":3,\"149\":1,\"156\":1,\"187\":3,\"189\":5,\"190\":4,\"192\":2,\"196\":2,\"197\":2,\"199\":2,\"200\":1,\"201\":2,\"202\":1,\"203\":7,\"207\":3,\"218\":4,\"305\":3,\"309\":2,\"310\":2,\"312\":3,\"314\":2,\"319\":2,\"321\":2}}],[\"address>\",{\"1\":{\"50\":1}}],[\"added\",{\"1\":{\"273\":1}}],[\"addpathpatterns\",{\"1\":{\"94\":1}}],[\"additional\",{\"1\":{\"253\":1,\"305\":1,\"314\":1}}],[\"additionalscrapeconfigs\",{\"1\":{\"75\":1}}],[\"addinterceptor\",{\"1\":{\"94\":1}}],[\"addinterceptors\",{\"1\":{\"94\":1}}],[\"addmetric\",{\"1\":{\"85\":2,\"96\":1,\"350\":1,\"351\":2}}],[\"add\",{\"1\":{\"48\":1,\"72\":1,\"85\":3,\"96\":1,\"126\":1,\"141\":1,\"283\":1,\"350\":1,\"351\":2,\"397\":1}}],[\"a\",{\"1\":{\"45\":1,\"48\":4,\"67\":3,\"72\":3,\"87\":1,\"93\":1,\"99\":1,\"105\":2,\"116\":6,\"135\":7,\"166\":1,\"217\":1,\"265\":1,\"269\":4,\"273\":2,\"305\":4,\"310\":2,\"349\":2,\"350\":1}}],[\"attach\",{\"1\":{\"187\":1,\"189\":1}}],[\"at`\",{\"1\":{\"31\":1}}],[\"atmobiles\",{\"1\":{\"30\":1,\"31\":2}}],[\"at\",{\"1\":{\"30\":2,\"31\":5,\"72\":1,\"135\":1}}],[\"auto\",{\"1\":{\"135\":1}}],[\"autowired\",{\"1\":{\"96\":1}}],[\"autoscaling\",{\"1\":{\"15\":1,\"176\":1}}],[\"authority\",{\"1\":{\"305\":1,\"314\":1}}],[\"authorization\",{\"1\":{\"186\":3,\"219\":5,\"223\":2}}],[\"auth的secret对象\",{\"1\":{\"217\":1}}],[\"auth的支持\",{\"1\":{\"102\":1,\"317\":1}}],[\"auth进行安全认证配置\",{\"1\":{\"165\":1}}],[\"authentication\",{\"1\":{\"51\":1}}],[\"auth\",{\"1\":{\"26\":5,\"50\":7,\"102\":2,\"165\":2,\"167\":1,\"217\":3,\"317\":2}}],[\"arch=\",{\"1\":{\"187\":1,\"189\":1}}],[\"args\",{\"1\":{\"86\":1,\"93\":2,\"96\":1,\"135\":1,\"175\":1,\"349\":1}}],[\"arraylist<>\",{\"1\":{\"96\":1}}],[\"arraylist<metricfamilysamples>\",{\"1\":{\"85\":2,\"350\":1,\"351\":1}}],[\"arraylist\",{\"1\":{\"96\":1,\"350\":1}}],[\"arrays\",{\"1\":{\"85\":8,\"351\":3}}],[\"area\",{\"1\":{\"135\":1}}],[\"are\",{\"1\":{\"23\":1,\"45\":1,\"72\":1,\"93\":1,\"135\":1,\"265\":2,\"310\":2}}],[\"article\",{\"1\":{\"18\":1}}],[\"associated\",{\"1\":{\"321\":1}}],[\"as为time\",{\"1\":{\"142\":1}}],[\"as为heatmap\",{\"1\":{\"139\":1}}],[\"as选项为heatmap\",{\"1\":{\"141\":1}}],[\"as选项定义如何格式化prometheus返回的样本数据\",{\"1\":{\"126\":1}}],[\"aslist\",{\"1\":{\"85\":8,\"351\":3}}],[\"as配置选项为table\",{\"1\":{\"77\":1}}],[\"as\",{\"1\":{\"23\":1,\"51\":1,\"72\":2,\"77\":1,\"135\":1,\"166\":1,\"273\":1}}],[\"apr\",{\"1\":{\"305\":1}}],[\"apache\",{\"1\":{\"114\":1}}],[\"apcupsd\",{\"1\":{\"114\":1}}],[\"apps\",{\"1\":{\"217\":1,\"223\":1}}],[\"app=\",{\"1\":{\"207\":2}}],[\"app=node\",{\"1\":{\"206\":2}}],[\"apply\",{\"1\":{\"186\":1,\"187\":1,\"218\":1,\"219\":1,\"223\":1}}],[\"apply对deployment进行变更升级\",{\"1\":{\"186\":1}}],[\"application\",{\"1\":{\"30\":1,\"32\":1,\"102\":1,\"317\":1}}],[\"applied\",{\"1\":{\"23\":2}}],[\"appoptics\",{\"1\":{\"167\":1}}],[\"app\",{\"1\":{\"45\":2,\"48\":2,\"175\":2,\"181\":4,\"186\":1,\"195\":5,\"201\":1,\"203\":5,\"205\":3,\"206\":1,\"217\":26,\"218\":4}}],[\"api查询promql表达式时\",{\"1\":{\"257\":1}}],[\"api查看容器详细的监控统计信息\",{\"1\":{\"104\":1}}],[\"api我们则可以直接查询promql表达式在一段时间返回内的计算结果\",{\"1\":{\"257\":1}}],[\"api我们可以查询promql在特定时间点下的计算结果\",{\"1\":{\"255\":1}}],[\"api我们可以分别通过\",{\"1\":{\"254\":1}}],[\"api使用了json格式的响应内容\",{\"1\":{\"253\":1}}],[\"api响应格式\",{\"0\":{\"253\":1}}],[\"api可以通过\",{\"1\":{\"252\":1}}],[\"api中promql只能使用瞬时向量选择器类型的表达式\",{\"1\":{\"257\":1}}],[\"api中\",{\"1\":{\"234\":1}}],[\"api中使用promql\",{\"0\":{\"252\":1,\"254\":1},\"1\":{\"8\":1,\"20\":1}}],[\"api找到集群中的所有node对象\",{\"1\":{\"189\":1}}],[\"api集成目前主要支持5种服务发现模式\",{\"1\":{\"187\":1}}],[\"api的方式查询服务信息\",{\"1\":{\"305\":1}}],[\"api的方式查看当前集群中的节点信息\",{\"1\":{\"305\":1}}],[\"api的方式进行注册\",{\"1\":{\"305\":1}}],[\"api的形式获取服务列表\",{\"1\":{\"305\":1}}],[\"api的形式\",{\"1\":{\"221\":1}}],[\"api的响应时间\",{\"1\":{\"191\":1}}],[\"api的ca以及token文件路径\",{\"1\":{\"187\":1}}],[\"api的ca证书以及当前账户对应的访问令牌文件挂载到pod实例的\",{\"1\":{\"186\":1}}],[\"api的处理都只基于prometheus本地存储完成\",{\"1\":{\"164\":1}}],[\"apigroup\",{\"1\":{\"186\":1,\"219\":1}}],[\"apigroups\",{\"1\":{\"186\":2,\"219\":2}}],[\"apiserver任务状态\",{\"1\":{\"202\":1}}],[\"apiserver任务采集状态\",{\"1\":{\"192\":1}}],[\"apiserver对用的地址\",{\"1\":{\"202\":1}}],[\"apiserver相关的指标\",{\"1\":{\"202\":1}}],[\"apiserver实例\",{\"1\":{\"202\":1}}],[\"apiserver交互\",{\"1\":{\"202\":1}}],[\"apiserver组件一般是独立部署在集群外的\",{\"1\":{\"202\":1}}],[\"apiserver组件内置了对prometheus的支持\",{\"1\":{\"192\":1}}],[\"apiserver扮演了整个kubernetes集群管理的入口的角色\",{\"1\":{\"202\":1}}],[\"apiserver获取集群运行监控指标\",{\"0\":{\"202\":1}}],[\"apiservers\",{\"1\":{\"192\":2,\"202\":2}}],[\"apiserver的并发和吞吐量直接决定了集群性能的好坏\",{\"1\":{\"180\":1,\"184\":1}}],[\"apiserver进行通讯\",{\"1\":{\"180\":1,\"184\":1}}],[\"apiserver是kubernetes提供所有服务的入口\",{\"1\":{\"180\":1,\"184\":1}}],[\"apiserver\",{\"1\":{\"179\":1,\"183\":1}}],[\"apiversion\",{\"1\":{\"174\":1,\"175\":2,\"181\":2,\"186\":3,\"187\":1,\"190\":1,\"195\":2,\"201\":1,\"203\":2,\"205\":2,\"206\":2,\"207\":1,\"210\":1,\"213\":2,\"214\":2,\"216\":1,\"217\":5,\"218\":1,\"219\":4}}],[\"api服务\",{\"1\":{\"114\":1}}],[\"apihighrequestlatency\",{\"1\":{\"67\":1}}],[\"api\",{\"1\":{\"26\":11,\"49\":4,\"51\":14,\"67\":1,\"75\":2,\"150\":3,\"169\":1,\"179\":1,\"183\":1,\"186\":1,\"190\":2,\"198\":1,\"199\":2,\"200\":1,\"202\":1,\"213\":1,\"217\":7,\"252\":1,\"254\":2,\"255\":2,\"257\":2,\"269\":2,\"294\":3,\"325\":4}}],[\"ansible\",{\"1\":{\"307\":1}}],[\"answer\",{\"1\":{\"305\":4,\"314\":1}}],[\"annotation\",{\"1\":{\"187\":3,\"189\":4,\"196\":1,\"197\":1,\"201\":3,\"203\":3,\"207\":7}}],[\"annotations的内容在告警产生时会一同作为参数发送到alertmanager\",{\"1\":{\"66\":1}}],[\"annotations`\",{\"1\":{\"28\":1}}],[\"annotations\",{\"1\":{\"27\":1,\"28\":1,\"31\":5,\"51\":2,\"66\":2,\"67\":2,\"69\":2,\"150\":2,\"151\":2,\"201\":1,\"205\":2,\"206\":1,\"207\":2}}],[\"any\",{\"1\":{\"67\":2,\"160\":1,\"199\":1,\"217\":1,\"273\":1,\"314\":1}}],[\"and\",{\"1\":{\"48\":1,\"72\":1,\"134\":1,\"135\":4,\"236\":1,\"247\":2,\"248\":1,\"273\":1,\"310\":2,\"319\":1,\"321\":1,\"364\":2,\"369\":1}}],[\"another\",{\"1\":{\"48\":1}}],[\"an\",{\"1\":{\"16\":1,\"48\":1}}],[\"监控服务内部运行状态\",{\"1\":{\"293\":1}}],[\"监控服务的内部运行状态\",{\"0\":{\"293\":1}}],[\"监控服务的可用性\",{\"1\":{\"207\":1}}],[\"监控的目标\",{\"0\":{\"289\":1}}],[\"监控任务运行状态等\",{\"1\":{\"282\":1}}],[\"监控当前系统所有发生的错误请求\",{\"1\":{\"234\":1}}],[\"监控当前系统的流量\",{\"1\":{\"234\":1}}],[\"监控模式\",{\"0\":{\"233\":1}}],[\"监控什么\",{\"1\":{\"232\":1}}],[\"监控所有\",{\"0\":{\"232\":1}}],[\"监控配置以及告警规则等资源\",{\"1\":{\"214\":1}}],[\"监控方法\",{\"1\":{\"198\":1}}],[\"监控service和ingress可用性\",{\"0\":{\"194\":1}}],[\"监控容器运行状态\",{\"1\":{\"188\":1}}],[\"监控用户部署的应用程序\",{\"1\":{\"171\":1}}],[\"监控集群状态\",{\"0\":{\"191\":1}}],[\"监控集群应用容器资源使用情况\",{\"1\":{\"171\":1}}],[\"监控集群基础设施\",{\"0\":{\"204\":1},\"1\":{\"171\":1}}],[\"监控系统自身难以扩展\",{\"1\":{\"290\":1}}],[\"监控系统获取到的监控指标与业务本身也是一种分离的关系\",{\"1\":{\"290\":1}}],[\"监控系统需要迅速反应并通知管理员\",{\"1\":{\"289\":1}}],[\"监控系统需要能够有效的支持白盒监控和黑盒监控\",{\"1\":{\"289\":1}}],[\"监控系统\",{\"1\":{\"114\":1}}],[\"监控缓冲池使用情况\",{\"0\":{\"111\":1}}],[\"监控数据库吞吐量\",{\"0\":{\"109\":1}}],[\"监控数据可视化\",{\"1\":{\"8\":1,\"20\":1}}],[\"监控描述信息\",{\"1\":{\"30\":2}}],[\"监控指标不再是一个单独存在的个体\",{\"1\":{\"282\":1}}],[\"监控指标kubelet\",{\"1\":{\"199\":1}}],[\"监控指标my\",{\"1\":{\"85\":1}}],[\"监控指标\",{\"1\":{\"30\":2}}],[\"监控mysql运行状态\",{\"0\":{\"107\":1},\"1\":{\"9\":1,\"21\":1}}],[\"监控kubernetes\",{\"0\":{\"184\":1},\"1\":{\"10\":1,\"22\":1}}],[\"监控kubernetes集群\",{\"1\":{\"10\":1,\"22\":1}}],[\"监控kubernetes集群状态\",{\"1\":{\"3\":1,\"171\":1}}],[\"监控kubernetes集群中的节点\",{\"1\":{\"3\":1}}],[\"监控kubernetes中的容器\",{\"1\":{\"3\":1}}],[\"iaas或者caas\",{\"1\":{\"313\":1}}],[\"ignoring\",{\"1\":{\"250\":2,\"251\":3,\"366\":2,\"367\":3}}],[\"irc\",{\"1\":{\"195\":1}}],[\"irate的这种灵敏度反而容易造成干扰\",{\"1\":{\"238\":1}}],[\"irate函数相比于rate函数提供了更高的灵敏度\",{\"1\":{\"238\":1}}],[\"irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率\",{\"1\":{\"238\":1}}],[\"irate同样用于计算区间向量的计算率\",{\"1\":{\"238\":1}}],[\"irate\",{\"1\":{\"69\":1,\"106\":1,\"126\":1,\"127\":1,\"128\":1,\"138\":1,\"151\":1,\"238\":1,\"248\":1,\"262\":2,\"369\":1,\"378\":3}}],[\"iemoji\",{\"1\":{\"144\":1}}],[\"itself\",{\"1\":{\"273\":1}}],[\"it\",{\"1\":{\"108\":1,\"135\":1,\"160\":1,\"167\":1,\"186\":1,\"199\":1,\"273\":1,\"310\":1}}],[\"itd\",{\"1\":{\"104\":1}}],[\"item\",{\"1\":{\"16\":1}}],[\"ipv4和ipv6探针\",{\"0\":{\"320\":1}}],[\"ip=192\",{\"1\":{\"396\":1}}],[\"ip=\",{\"1\":{\"187\":1,\"189\":1,\"207\":2}}],[\"ipmi\",{\"1\":{\"114\":1}}],[\"ip6\",{\"1\":{\"99\":1,\"103\":1,\"314\":2,\"318\":1,\"319\":2,\"321\":2}}],[\"ip4\",{\"1\":{\"99\":1,\"103\":1,\"314\":1,\"318\":1,\"319\":2,\"321\":1}}],[\"ip\",{\"1\":{\"99\":4,\"103\":6,\"175\":2,\"181\":5,\"187\":1,\"190\":1,\"192\":2,\"199\":1,\"201\":1,\"202\":2,\"203\":2,\"205\":1,\"206\":3,\"314\":4,\"318\":6,\"319\":5,\"321\":4}}],[\"icmp探针\",{\"0\":{\"319\":1}}],[\"icmp等其他网络协议\",{\"1\":{\"103\":1}}],[\"icmp\",{\"1\":{\"99\":2,\"195\":2,\"232\":1,\"319\":1}}],[\"icons\",{\"1\":{\"48\":1}}],[\"icon\",{\"1\":{\"48\":3,\"49\":2,\"134\":3}}],[\"implements\",{\"1\":{\"93\":1,\"94\":1,\"96\":1}}],[\"important\",{\"1\":{\"48\":1}}],[\"import\",{\"1\":{\"28\":2,\"31\":1,\"32\":1,\"33\":1,\"96\":6,\"166\":2,\"349\":3,\"350\":7,\"352\":1}}],[\"imagepullpolicy\",{\"1\":{\"201\":1,\"203\":1}}],[\"image=\",{\"1\":{\"105\":5}}],[\"image\",{\"1\":{\"49\":1,\"106\":6,\"108\":2,\"167\":2,\"175\":1,\"181\":3,\"187\":1,\"195\":1,\"201\":1,\"203\":1,\"205\":1,\"217\":1}}],[\"img\",{\"1\":{\"48\":1}}],[\"ifnotpresent\",{\"1\":{\"201\":1,\"203\":1}}],[\"if\",{\"1\":{\"28\":1,\"32\":4,\"33\":2,\"49\":2,\"51\":12,\"99\":2,\"103\":11,\"135\":2,\"166\":3,\"253\":1,\"310\":1,\"314\":6,\"318\":11,\"350\":2}}],[\"id>\",{\"1\":{\"108\":1}}],[\"id=\",{\"1\":{\"105\":5,\"134\":1,\"135\":1}}],[\"id=12455045\",{\"1\":{\"16\":1}}],[\"idle\",{\"1\":{\"69\":1,\"116\":1,\"126\":1,\"127\":1,\"128\":1,\"138\":1,\"151\":1,\"167\":1,\"227\":1,\"248\":1,\"262\":1,\"267\":1,\"268\":1,\"282\":1,\"286\":1,\"309\":1,\"310\":2,\"369\":1,\"378\":2}}],[\"identifying\",{\"1\":{\"27\":1}}],[\"identity\",{\"1\":{\"26\":1,\"50\":2}}],[\"id\",{\"1\":{\"26\":1,\"51\":8,\"93\":2,\"167\":1,\"305\":4,\"310\":1}}],[\"isatall\",{\"1\":{\"30\":2,\"31\":3}}],[\"is\",{\"1\":{\"23\":2,\"48\":3,\"67\":1,\"72\":1,\"99\":1,\"103\":1,\"108\":1,\"150\":2,\"156\":1,\"181\":1,\"218\":1,\"253\":1,\"265\":1,\"273\":5,\"310\":5,\"318\":1,\"321\":2}}],[\"issues\",{\"1\":{\"16\":1}}],[\"ing\",{\"1\":{\"181\":1}}],[\"ingress来管理应用的访问方式\",{\"1\":{\"221\":1}}],[\"ingress和service均扮演了负载均衡的角色\",{\"1\":{\"194\":1}}],[\"ingresses\",{\"1\":{\"186\":1,\"197\":1,\"203\":1}}],[\"ingress\",{\"1\":{\"180\":1,\"187\":3,\"197\":6,\"198\":1,\"203\":6,\"393\":1}}],[\"ingress是一个工作在7层的负载均衡器\",{\"1\":{\"178\":1}}],[\"ingested\",{\"1\":{\"160\":2}}],[\"ingestion\",{\"1\":{\"16\":1,\"23\":1}}],[\"inverse\",{\"1\":{\"134\":1}}],[\"index\",{\"1\":{\"133\":1,\"148\":1,\"159\":2}}],[\"indicates\",{\"1\":{\"99\":2,\"103\":1,\"318\":1}}],[\"influx\",{\"1\":{\"167\":1}}],[\"influxdb是一个开源的时间序列数据库\",{\"1\":{\"328\":1}}],[\"influxdb\",{\"0\":{\"328\":1},\"1\":{\"114\":1,\"122\":1,\"167\":19}}],[\"info\",{\"1\":{\"66\":1,\"105\":3,\"130\":1,\"150\":2,\"167\":1,\"285\":1,\"349\":4}}],[\"innodb\",{\"1\":{\"111\":17}}],[\"int64\",{\"1\":{\"166\":2}}],[\"into\",{\"1\":{\"135\":1,\"181\":1}}],[\"int\",{\"1\":{\"95\":1}}],[\"interface\",{\"1\":{\"106\":2}}],[\"interceptorregistry\",{\"1\":{\"94\":1}}],[\"internalip=\",{\"1\":{\"187\":1,\"189\":1}}],[\"internal分析连接失败的问题原因\",{\"1\":{\"110\":1}}],[\"internal\",{\"1\":{\"45\":2,\"110\":1}}],[\"interval进行设置\",{\"1\":{\"307\":1}}],[\"interval定义\",{\"1\":{\"72\":1}}],[\"interval来覆盖默认的计算周期\",{\"1\":{\"66\":1}}],[\"interval配置\",{\"1\":{\"42\":1}}],[\"interval参数进行设置\",{\"1\":{\"41\":1}}],[\"interval\",{\"1\":{\"40\":2,\"42\":2,\"51\":2,\"55\":2,\"66\":1,\"72\":3,\"129\":1,\"151\":2,\"169\":1,\"174\":2,\"187\":2,\"190\":2,\"210\":2,\"214\":2,\"218\":3,\"273\":4,\"307\":3,\"377\":4}}],[\"integrations\",{\"1\":{\"26\":1}}],[\"incoming\",{\"1\":{\"305\":1}}],[\"incomming\",{\"0\":{\"48\":1},\"1\":{\"48\":3}}],[\"increase计算出最近两分钟的增长量\",{\"1\":{\"238\":1}}],[\"increase函数获取区间向量中的第一个后最后一个样本并返回其增长量\",{\"1\":{\"238\":1}}],[\"increase\",{\"1\":{\"238\":2}}],[\"inc\",{\"1\":{\"89\":2,\"95\":4,\"352\":4}}],[\"inprogressrequest\",{\"1\":{\"352\":2}}],[\"inprogressrequests\",{\"1\":{\"89\":6,\"95\":3,\"352\":1}}],[\"inprogress\",{\"1\":{\"72\":2,\"89\":5,\"95\":4,\"352\":2}}],[\"instrumented\",{\"1\":{\"217\":1}}],[\"inst的secret资源\",{\"1\":{\"214\":1}}],[\"inst\",{\"1\":{\"210\":9,\"213\":1,\"214\":13,\"216\":7,\"218\":7,\"219\":4}}],[\"instant\",{\"1\":{\"240\":1,\"241\":2}}],[\"instance和job的值进行渲染\",{\"1\":{\"241\":1}}],[\"instance=\",{\"1\":{\"130\":3,\"144\":1,\"187\":1,\"189\":1,\"241\":6,\"244\":2,\"246\":2,\"259\":3,\"260\":2,\"287\":2,\"309\":1,\"310\":3,\"325\":3,\"357\":4,\"358\":8,\"360\":3,\"361\":2}}],[\"instance=~\",{\"1\":{\"128\":1}}],[\"instancedown\",{\"1\":{\"67\":1}}],[\"instance\",{\"1\":{\"51\":4,\"55\":1,\"67\":7,\"69\":7,\"100\":1,\"111\":3,\"126\":2,\"138\":1,\"150\":6,\"151\":7,\"196\":1,\"197\":1,\"203\":3,\"226\":1,\"241\":1,\"255\":2,\"257\":2,\"259\":1,\"262\":1,\"280\":3,\"368\":1,\"378\":3}}],[\"install\",{\"0\":{\"13\":1,\"397\":1},\"1\":{\"13\":1,\"181\":1,\"374\":1,\"395\":1,\"397\":2}}],[\"insecure\",{\"1\":{\"195\":1,\"199\":2,\"200\":1}}],[\"insert|update|delete\",{\"1\":{\"109\":1}}],[\"insert\",{\"1\":{\"67\":2,\"109\":4}}],[\"inspector可以展开相关的调试面板\",{\"1\":{\"126\":1}}],[\"in\",{\"1\":{\"48\":1,\"72\":1,\"90\":5,\"93\":3,\"95\":2,\"99\":2,\"109\":2,\"110\":2,\"111\":3,\"112\":2,\"116\":3,\"135\":1,\"160\":2,\"166\":1,\"181\":1,\"188\":2,\"201\":1,\"205\":1,\"217\":3,\"218\":1,\"227\":1,\"267\":1,\"286\":1,\"305\":5,\"310\":1,\"319\":1,\"321\":1,\"349\":2,\"350\":2,\"352\":4}}],[\"initiated\",{\"1\":{\"321\":1}}],[\"initialized\",{\"1\":{\"350\":3}}],[\"initialize\",{\"1\":{\"87\":1,\"93\":1,\"349\":1,\"350\":2}}],[\"init\",{\"1\":{\"33\":1,\"395\":1}}],[\"inhibit\",{\"1\":{\"26\":2,\"36\":1,\"51\":1,\"55\":1}}],[\"ioutil\",{\"1\":{\"166\":2}}],[\"iot\",{\"1\":{\"114\":1}}],[\"ioexception\",{\"1\":{\"86\":1,\"91\":1,\"349\":2,\"350\":1}}],[\"io\",{\"1\":{\"16\":2,\"54\":1,\"85\":1,\"86\":1,\"87\":1,\"91\":1,\"93\":3,\"95\":29,\"96\":3,\"100\":3,\"166\":1,\"186\":5,\"187\":18,\"189\":6,\"190\":4,\"192\":2,\"196\":1,\"197\":1,\"199\":6,\"200\":4,\"201\":9,\"202\":2,\"203\":4,\"205\":2,\"206\":1,\"207\":11,\"219\":5,\"223\":2,\"273\":1,\"285\":1,\"305\":1,\"349\":7,\"350\":3,\"352\":1,\"378\":1}}],[\"iii\",{\"0\":{\"10\":1,\"22\":1}}],[\"ii\",{\"0\":{\"9\":1,\"21\":1}}],[\"i\",{\"0\":{\"8\":1,\"20\":1},\"1\":{\"104\":2}}],[\"p3\",{\"1\":{\"305\":1}}],[\"pw=prom\",{\"1\":{\"167\":1}}],[\"p\",{\"1\":{\"151\":1,\"273\":1,\"274\":1,\"283\":1,\"305\":3}}],[\"p2\",{\"1\":{\"151\":1}}],[\"p1\",{\"1\":{\"151\":1}}],[\"perform\",{\"1\":{\"310\":1}}],[\"performed\",{\"1\":{\"310\":1}}],[\"periodically\",{\"1\":{\"273\":1}}],[\"per\",{\"1\":{\"160\":4,\"350\":1}}],[\"persisted\",{\"1\":{\"160\":2}}],[\"peers=0\",{\"1\":{\"150\":1}}],[\"peer=127\",{\"1\":{\"149\":1,\"150\":2}}],[\"peer参数并且指向a1实例的集群服务地址\",{\"1\":{\"149\":1}}],[\"peer\",{\"1\":{\"149\":1}}],[\"pending或者firing\",{\"1\":{\"68\":1}}],[\"pending|firing\",{\"1\":{\"68\":1}}],[\"placed\",{\"1\":{\"310\":1}}],[\"plain\",{\"1\":{\"117\":1}}],[\"please\",{\"1\":{\"150\":2}}],[\"plots\",{\"1\":{\"135\":2}}],[\"ping\",{\"1\":{\"195\":1}}],[\"pixels\",{\"1\":{\"135\":1}}],[\"pids\",{\"1\":{\"104\":1}}],[\"pkg\",{\"1\":{\"134\":1}}],[\"php等等\",{\"1\":{\"347\":1}}],[\"php\",{\"1\":{\"114\":1}}],[\"phase=\",{\"1\":{\"99\":5}}],[\"phase\",{\"1\":{\"99\":1}}],[\"python\",{\"1\":{\"114\":1,\"298\":1,\"347\":1}}],[\"ppassword\",{\"1\":{\"108\":1}}],[\"pseudosection\",{\"1\":{\"305\":1}}],[\"ps\",{\"1\":{\"93\":4,\"167\":1,\"349\":4}}],[\"pg\",{\"1\":{\"91\":2}}],[\"pull模式的优点可以简单总结为以下几点\",{\"1\":{\"313\":1}}],[\"pull系统\",{\"1\":{\"313\":1}}],[\"put\",{\"1\":{\"193\":1,\"250\":1,\"366\":1}}],[\"publish=8080\",{\"1\":{\"105\":1}}],[\"public\",{\"1\":{\"85\":2,\"86\":2,\"89\":2,\"90\":1,\"91\":2,\"93\":3,\"94\":5,\"95\":11,\"96\":4,\"349\":2,\"350\":6,\"396\":1}}],[\"push系统\",{\"1\":{\"313\":1}}],[\"pushadd\",{\"1\":{\"91\":1}}],[\"push\",{\"1\":{\"91\":1}}],[\"pushgateway则提供了与pushgateway的对接支持\",{\"1\":{\"349\":1}}],[\"pushgatewayintegration\",{\"1\":{\"91\":1}}],[\"pushgateway的实现类可以从所有注册到defaultregistry的collector实例中获取样本数据并直接推送\",{\"1\":{\"91\":1}}],[\"pushgateway\",{\"0\":{\"279\":1},\"1\":{\"91\":3,\"349\":1}}],[\"pushover\",{\"1\":{\"43\":1}}],[\"pong\",{\"1\":{\"195\":1}}],[\"pop3s\",{\"1\":{\"195\":1}}],[\"policy=autogen\",{\"1\":{\"167\":1}}],[\"points\",{\"1\":{\"138\":1}}],[\"ports\",{\"1\":{\"108\":2,\"167\":2,\"175\":2,\"181\":2,\"195\":1,\"201\":1,\"203\":1,\"205\":2,\"206\":2,\"217\":2}}],[\"port\",{\"1\":{\"100\":1,\"175\":2,\"181\":3,\"192\":2,\"195\":1,\"201\":3,\"202\":2,\"203\":2,\"205\":1,\"206\":3,\"207\":6,\"210\":1,\"214\":3,\"216\":1,\"217\":4,\"218\":1,\"305\":1,\"310\":1}}],[\"pool=\",{\"1\":{\"87\":2,\"349\":2}}],[\"pool\",{\"1\":{\"87\":5,\"111\":31,\"349\":6}}],[\"pod实例状态\",{\"1\":{\"214\":1}}],[\"pod作为浅醉\",{\"1\":{\"207\":1}}],[\"pod中的容器可能并没有使用默认的\",{\"1\":{\"201\":1}}],[\"pod中会包含一组容器\",{\"1\":{\"178\":1,\"180\":1}}],[\"pod平均启动时间\",{\"1\":{\"193\":1,\"199\":1}}],[\"pod平均启动时间大致为42s左右\",{\"1\":{\"193\":1,\"199\":1}}],[\"pod的使用方式也是类似的\",{\"1\":{\"187\":1}}],[\"pod是kubernetes中的最小调度资源\",{\"1\":{\"178\":1}}],[\"pods并不是只针对node\",{\"1\":{\"201\":1}}],[\"pods\",{\"1\":{\"175\":1,\"181\":2,\"186\":2,\"187\":4,\"193\":4,\"201\":3,\"203\":1,\"205\":1,\"206\":1,\"214\":2,\"216\":1,\"217\":1,\"219\":1,\"223\":1}}],[\"pod=~\",{\"1\":{\"130\":1}}],[\"pod\",{\"1\":{\"51\":4,\"130\":1,\"180\":1,\"187\":3,\"193\":4,\"198\":2,\"199\":4,\"201\":7,\"207\":14,\"218\":4}}],[\"postgressql\",{\"1\":{\"298\":1}}],[\"postgresql\",{\"1\":{\"167\":1}}],[\"posted\",{\"1\":{\"48\":1}}],[\"post请求\",{\"1\":{\"27\":1,\"30\":1}}],[\"post\",{\"1\":{\"27\":1,\"28\":1,\"30\":1,\"32\":1,\"48\":1,\"99\":2,\"102\":3,\"193\":1,\"195\":2,\"250\":4,\"251\":2,\"268\":2,\"269\":2,\"317\":3,\"325\":4,\"366\":4,\"367\":2}}],[\"png\",{\"1\":{\"48\":1,\"375\":1,\"378\":1}}],[\"printf\",{\"1\":{\"166\":1}}],[\"println\",{\"1\":{\"32\":2,\"166\":1}}],[\"private\",{\"1\":{\"95\":1,\"96\":1,\"350\":2}}],[\"prepare\",{\"0\":{\"395\":1}}],[\"preferred\",{\"1\":{\"314\":2,\"319\":2,\"321\":2}}],[\"prefix\",{\"1\":{\"214\":1}}],[\"predict\",{\"1\":{\"229\":1,\"239\":2}}],[\"prevents\",{\"1\":{\"156\":1}}],[\"preview\",{\"1\":{\"37\":1,\"39\":1}}],[\"pretty\",{\"1\":{\"116\":1}}],[\"pretext\",{\"1\":{\"49\":2}}],[\"prehandle\",{\"1\":{\"94\":2,\"95\":4}}],[\"prod聚合监控数据\",{\"1\":{\"308\":1}}],[\"prod不同的集群\",{\"1\":{\"308\":1}}],[\"prod\",{\"1\":{\"307\":2,\"309\":1}}],[\"produment\",{\"1\":{\"294\":2}}],[\"production\",{\"1\":{\"206\":3}}],[\"product\",{\"1\":{\"16\":1,\"42\":1}}],[\"progress\",{\"1\":{\"217\":2}}],[\"provided\",{\"1\":{\"187\":1,\"189\":1}}],[\"protobuf\",{\"1\":{\"166\":1}}],[\"proto\",{\"1\":{\"166\":3}}],[\"proto3\",{\"1\":{\"166\":1}}],[\"protocol=\",{\"1\":{\"207\":2}}],[\"protocol=ip4强制通过ipv4的方式进行探测\",{\"1\":{\"103\":1,\"318\":1}}],[\"protocol\",{\"1\":{\"99\":4,\"103\":5,\"175\":2,\"181\":1,\"195\":1,\"203\":1,\"205\":1,\"305\":1,\"314\":3,\"318\":5,\"319\":2,\"321\":3}}],[\"proxy\",{\"1\":{\"165\":3,\"179\":1,\"183\":1,\"186\":1,\"190\":2,\"199\":2,\"200\":1}}],[\"procfile\",{\"1\":{\"150\":2,\"151\":1,\"400\":1}}],[\"procfile文件\",{\"1\":{\"150\":1,\"151\":1}}],[\"processing\",{\"1\":{\"99\":1}}],[\"process\",{\"1\":{\"95\":1,\"188\":7,\"201\":4,\"205\":4,\"286\":1}}],[\"processrequest\",{\"1\":{\"89\":2,\"90\":2,\"352\":4}}],[\"probe的采集任务\",{\"1\":{\"100\":1}}],[\"probe和prometheus\",{\"1\":{\"100\":1}}],[\"probe\",{\"1\":{\"99\":44,\"100\":8,\"103\":7,\"196\":2,\"197\":2,\"203\":6,\"314\":1,\"318\":7,\"319\":1,\"321\":3}}],[\"probe>\",{\"1\":{\"99\":4}}],[\"prober\",{\"1\":{\"99\":4,\"101\":1,\"102\":3,\"103\":3,\"195\":12,\"316\":1,\"317\":3,\"318\":3}}],[\"prometehus提供了更灵活的数据模型以及查询语言\",{\"1\":{\"327\":1}}],[\"promethues也可以与其集成从而动态的发现需要监控的应用服务实例\",{\"1\":{\"313\":1}}],[\"promethues\",{\"1\":{\"210\":1}}],[\"promethues通过与kubernetes\",{\"1\":{\"187\":1}}],[\"prometheus提供了针对servlet\",{\"1\":{\"350\":1}}],[\"prometheus提供了多种client\",{\"1\":{\"348\":1}}],[\"prometheus提供了remote\",{\"1\":{\"145\":1}}],[\"prometheus和influxdb之间存在着一些显著的差异\",{\"1\":{\"328\":1}}],[\"prometheus也适用于那些生命周期较短\",{\"1\":{\"326\":1}}],[\"prometheus也会将它们存储到时间序列alerts\",{\"1\":{\"68\":1}}],[\"prometheus同样将时间序列数据分别存储在独立的本地磁盘中\",{\"1\":{\"326\":1}}],[\"prometheus则是一个完整的监控系统\",{\"1\":{\"324\":1}}],[\"prometheus则会直接将数据保存在内存当中\",{\"1\":{\"159\":1}}],[\"prometheus只需要向这个代理人询问有哪些监控目标即可\",{\"1\":{\"313\":1}}],[\"prometheus允许用户在采集任务设置中通过relabel\",{\"1\":{\"309\":1}}],[\"prometheus默认每5m重新读取一次文件内容\",{\"1\":{\"307\":1}}],[\"prometheus对云以及容器环境下的监控场景提供了完善的支持\",{\"1\":{\"302\":1}}],[\"prometheus对于联邦集群的支持\",{\"1\":{\"297\":1}}],[\"prometheus社区还提供了大量第三方实现的监控数据采集支持\",{\"1\":{\"298\":1}}],[\"prometheus社区提供了丰富的exporter实现\",{\"1\":{\"114\":1}}],[\"prometheus鼓励用户监控服务的内部状态\",{\"1\":{\"293\":1}}],[\"prometheus核心部分只有一个单独的二进制文件\",{\"1\":{\"292\":1}}],[\"prometheus核心组件\",{\"1\":{\"8\":1,\"20\":1}}],[\"prometheus作为新一代的云原生监控系统\",{\"1\":{\"288\":1}}],[\"prometheus作为一个时间序列数据库\",{\"1\":{\"273\":1}}],[\"prometheus简史\",{\"1\":{\"288\":1}}],[\"prometheus简介\",{\"0\":{\"288\":1},\"1\":{\"8\":1,\"20\":1}}],[\"prometheus简介小节\",{\"1\":{\"3\":1}}],[\"prometheus受启发于google的borgmon监控系统\",{\"1\":{\"288\":1}}],[\"prometheus周期性的从exporter暴露的http服务地址\",{\"1\":{\"285\":1}}],[\"prometheus是如此简单\",{\"1\":{\"297\":1}}],[\"prometheus是如何从众多的监控平台中脱颖而出成为下一代监控系统的首选\",{\"1\":{\"270\":1}}],[\"prometheus是一个开源的完整监控解决方案\",{\"1\":{\"291\":1}}],[\"prometheus是一个开放性的监控解决方案\",{\"1\":{\"281\":1}}],[\"prometheus架构\",{\"1\":{\"275\":1}}],[\"prometheus组件\",{\"0\":{\"275\":1}}],[\"prometheus可以采集到当前主机所有监控指标的样本数据\",{\"1\":{\"267\":1}}],[\"prometheus可以正常查询到本地存储以删除的历史数据记录\",{\"1\":{\"167\":1}}],[\"prometheus当前稳定的http\",{\"1\":{\"252\":1}}],[\"prometheus支持以下\",{\"1\":{\"359\":1,\"364\":1}}],[\"prometheus支持以下集合运算符\",{\"1\":{\"247\":1}}],[\"prometheus支持以下布尔运算符如下\",{\"1\":{\"245\":1}}],[\"prometheus支持模板化label和annotations的中标签的值\",{\"1\":{\"67\":1}}],[\"prometheus基于pull模型的架构方式\",{\"1\":{\"292\":1}}],[\"prometheus基于golang编写\",{\"1\":{\"272\":1}}],[\"prometheus基于指标提供了一个通用的监控解决方案\",{\"1\":{\"231\":1}}],[\"prometheus基础\",{\"0\":{\"8\":1,\"20\":1}}],[\"prometheus还支持基于dns以及文件的方式动态发现监控目标\",{\"1\":{\"313\":1}}],[\"prometheus还支持与dns\",{\"1\":{\"280\":1}}],[\"prometheus还可以直接与一些开源的服务发现工具进行集成\",{\"1\":{\"313\":1}}],[\"prometheus还提供了label\",{\"1\":{\"241\":1}}],[\"prometheus还提供了其它大量的内置函数\",{\"1\":{\"237\":1}}],[\"prometheus还提供了下列内置的聚合操作符\",{\"1\":{\"226\":1,\"368\":1}}],[\"prometheus还定义了histogram和summary的指标类型\",{\"1\":{\"230\":1}}],[\"prometheus定义了4种不同的指标类型\",{\"1\":{\"227\":1}}],[\"prometheus重新加载配置后\",{\"1\":{\"213\":1}}],[\"prometheusrule\",{\"1\":{\"213\":2,\"222\":1}}],[\"prometheus就能够正常的从apiserver中过去监控样本数据\",{\"1\":{\"192\":1}}],[\"prometheus就是一个用于存储监控样本数据的数据源\",{\"1\":{\"125\":1}}],[\"prometheus使用了访问地址后的任务采集状态\",{\"1\":{\"190\":1}}],[\"prometheus使用新的配置文件重建之后\",{\"1\":{\"187\":1}}],[\"prometheus目录下\",{\"1\":{\"175\":1}}],[\"prometheus配置文件中添加remote\",{\"1\":{\"165\":1}}],[\"prometheus在kubernetes下的服务发现机制\",{\"1\":{\"171\":1}}],[\"prometheus在本地使用promql对样本数据进行二次处理\",{\"1\":{\"164\":1}}],[\"prometheus在console\",{\"1\":{\"133\":1}}],[\"prometheus将向remote\",{\"1\":{\"164\":1}}],[\"prometheus将采集到的样本数据通过http的形式发送给适配器\",{\"1\":{\"163\":1}}],[\"prometheus将会按照以下规则对内容进行解析\",{\"1\":{\"116\":1}}],[\"prometheus并没有尝试在自身中解决以上问题\",{\"1\":{\"162\":1}}],[\"prometheus中强大的relabel机制\",{\"1\":{\"302\":1}}],[\"prometheus中服务发现的几种实现方式\",{\"1\":{\"302\":1}}],[\"prometheus中监控指标的类型\",{\"1\":{\"224\":1}}],[\"prometheus中存储的每一个样本大概占用1\",{\"1\":{\"160\":1}}],[\"prometheus中的告警规则允许你基于promql表达式定义告警触发条件\",{\"1\":{\"65\":1}}],[\"prometheus保存块数据的目录结构如下所示\",{\"1\":{\"159\":1}}],[\"prometheus数据存储\",{\"0\":{\"158\":1}}],[\"prometheus启动时会从写入日志\",{\"1\":{\"159\":1}}],[\"prometheus启动完成后\",{\"1\":{\"151\":1}}],[\"prometheus启动后会自动扫描这些路径下规则文件中定义的内容\",{\"1\":{\"66\":1}}],[\"prometheus2\",{\"1\":{\"151\":1}}],[\"prometheus与servicemonitor之间的关联关系使用servicemonitorselector定义\",{\"1\":{\"218\":1}}],[\"prometheus与kubernetes\",{\"0\":{\"182\":1}}],[\"prometheus与alertmanager\",{\"1\":{\"151\":1}}],[\"prometheus与服务发现\",{\"0\":{\"313\":1},\"1\":{\"3\":1,\"9\":1,\"21\":1}}],[\"prometheus的java\",{\"1\":{\"352\":1}}],[\"prometheus的relabeling机制\",{\"0\":{\"309\":1}}],[\"prometheus的remote\",{\"1\":{\"164\":1}}],[\"prometheus的告警模式\",{\"1\":{\"302\":1}}],[\"prometheus的优势\",{\"0\":{\"291\":1,\"385\":1}}],[\"prometheus的核心组件和概念\",{\"1\":{\"270\":1}}],[\"prometheus的前世今生\",{\"1\":{\"270\":1}}],[\"prometheus的数据模型\",{\"1\":{\"224\":1}}],[\"prometheus的本职就是一组用户自定义的crd资源以及controller的实现\",{\"1\":{\"221\":1}}],[\"prometheus的本地存储设计可以减少其自身运维和管理的复杂度\",{\"1\":{\"162\":1}}],[\"prometheus的本地存储给prometheus带来了简单高效的使用体验\",{\"1\":{\"152\":1}}],[\"prometheus的配置文件实际上是保存在名为prometheus\",{\"1\":{\"210\":1}}],[\"prometheus的简单性贯穿于整个prometheus的使用过程中\",{\"1\":{\"146\":1}}],[\"prometheus的远程存储机制\",{\"1\":{\"145\":1}}],[\"prometheus联邦集群\",{\"1\":{\"145\":1}}],[\"prometheus本地存储机制\",{\"1\":{\"145\":1}}],[\"prometheus能够更好地进行弹性扩展\",{\"1\":{\"145\":1}}],[\"prometheus内置了一个强大的数据查询语言promql\",{\"1\":{\"295\":1}}],[\"prometheus内置了一个基于本地存储的时间序列数据库\",{\"1\":{\"145\":1}}],[\"prometheus内置了对邮件\",{\"1\":{\"60\":1}}],[\"prometheus采集任务状态\",{\"1\":{\"131\":1}}],[\"prometheus这类为其提供\\b数据的对象均称为数据源\",{\"1\":{\"122\":1}}],[\"prometheus自身提供的console\",{\"1\":{\"118\":1}}],[\"prometheusmetricsinterceptor继承自handlerinterceptoradapter\",{\"1\":{\"94\":1}}],[\"prometheusmetricsinterceptor\",{\"1\":{\"94\":2,\"95\":4}}],[\"prometheus负责数据的统一收集并且提供统一的查询接口promql\",{\"1\":{\"83\":1}}],[\"prometheus负责产生告警\",{\"1\":{\"58\":1}}],[\"prometheus通过使用平台提供的api就可以找到所有需要监控的云主机\",{\"1\":{\"313\":1}}],[\"prometheus通过与consul的交互可以获取到相应exporter实例的访问信息\",{\"1\":{\"306\":1}}],[\"prometheus通过指标名称\",{\"1\":{\"258\":1}}],[\"prometheus通过自动发现node节点\",{\"1\":{\"190\":1}}],[\"prometheus通过轮询的方式定期从这些target中获取样本数据\",{\"1\":{\"113\":1}}],[\"prometheus通过轮询的方式定时从这些target中获取监控数据样本\",{\"1\":{\"82\":1}}],[\"prometheus通过recoding\",{\"1\":{\"71\":1}}],[\"prometheusspec\",{\"1\":{\"75\":1}}],[\"prometheus会根据modulus的值作为系数\",{\"1\":{\"312\":1}}],[\"prometheus会丢弃source\",{\"1\":{\"311\":1}}],[\"prometheus会定时从文件中读取最新的target信息\",{\"1\":{\"307\":1}}],[\"prometheus会将所有采集到的样本数据以时间序列\",{\"1\":{\"268\":1}}],[\"prometheus会返回json格式的响应内容\",{\"1\":{\"256\":1}}],[\"prometheus会查找当前集群中所有的endpoints配置\",{\"1\":{\"202\":1}}],[\"prometheus会通过kubernetes\",{\"1\":{\"189\":1}}],[\"prometheus会自动的周期性读取文件中的内容\",{\"1\":{\"307\":1}}],[\"prometheus会自动发现kubernetes中所有node节点的信息并作为监控的目标target\",{\"1\":{\"199\":1}}],[\"prometheus会自动从kubernetes中发现到所有的node节点并作为当前job监控的target实例\",{\"1\":{\"187\":1}}],[\"prometheus会自动将冲突的标签替换为\",{\"1\":{\"169\":1}}],[\"prometheus会按照以下规则对内容进行解析\",{\"1\":{\"116\":1}}],[\"prometheus会对exporter响应的内容逐行解析\",{\"1\":{\"116\":1}}],[\"prometheus会在后台完成expr中定义的promql表达式计算\",{\"1\":{\"72\":1}}],[\"prometheus会周期性的对告警规则进行计算\",{\"1\":{\"60\":1}}],[\"prometheus首次检测到满足触发条件后\",{\"1\":{\"69\":1}}],[\"prometheus后端对这些触发规则进行周期性计算\",{\"1\":{\"65\":1}}],[\"prometheus官网中给出了企业微信的相关配置说明\",{\"1\":{\"51\":1}}],[\"prometheus实战\",{\"0\":{\"10\":1,\"22\":1}}],[\"prometheus服务发现的实现机制\",{\"1\":{\"302\":1}}],[\"prometheus服务发现\",{\"0\":{\"302\":1},\"1\":{\"9\":1,\"21\":1}}],[\"prometheus高可用部署\",{\"0\":{\"152\":1}}],[\"prometheus高可用部署架构\",{\"1\":{\"145\":1}}],[\"prometheus高可用\",{\"1\":{\"9\":1,\"21\":1,\"312\":1}}],[\"prometheus进阶\",{\"0\":{\"9\":1,\"21\":1}}],[\"prometheus告警规则\",{\"1\":{\"213\":1}}],[\"prometheus告警信息\",{\"1\":{\"30\":2}}],[\"prometheus告警简介\",{\"0\":{\"60\":1},\"1\":{\"8\":1,\"20\":1}}],[\"prometheus告警处理\",{\"0\":{\"24\":1},\"1\":{\"8\":1,\"20\":1,\"60\":1}}],[\"prometheus\",{\"0\":{\"208\":1,\"221\":1,\"222\":1,\"276\":1,\"323\":1,\"328\":1,\"333\":1,\"338\":1,\"342\":1,\"391\":1,\"394\":1,\"398\":1},\"1\":{\"5\":1,\"10\":1,\"13\":1,\"14\":1,\"16\":3,\"22\":1,\"45\":1,\"54\":2,\"69\":2,\"75\":2,\"85\":1,\"86\":1,\"87\":2,\"91\":1,\"93\":5,\"96\":3,\"99\":2,\"100\":4,\"106\":6,\"108\":6,\"116\":1,\"118\":1,\"122\":1,\"135\":5,\"138\":1,\"139\":15,\"148\":1,\"149\":2,\"150\":6,\"151\":13,\"153\":1,\"156\":1,\"159\":2,\"166\":7,\"167\":3,\"169\":2,\"174\":5,\"175\":22,\"186\":18,\"187\":9,\"190\":2,\"196\":1,\"197\":1,\"201\":9,\"203\":4,\"205\":2,\"206\":1,\"207\":11,\"208\":1,\"210\":10,\"213\":6,\"214\":4,\"216\":7,\"217\":1,\"218\":10,\"219\":13,\"221\":2,\"222\":2,\"223\":8,\"230\":22,\"241\":2,\"246\":2,\"253\":1,\"255\":1,\"257\":1,\"259\":2,\"260\":2,\"273\":9,\"274\":6,\"276\":5,\"277\":1,\"280\":1,\"282\":1,\"283\":1,\"285\":3,\"287\":2,\"299\":1,\"307\":6,\"349\":7,\"350\":3,\"352\":1,\"357\":4,\"360\":4,\"361\":2,\"373\":1,\"377\":6,\"378\":1,\"392\":1,\"393\":10,\"397\":4,\"399\":1,\"400\":1}}],[\"prometheus被誉为下一代监控系统的首选\",{\"1\":{\"1\":1}}],[\"prometheus操作指南\",{\"0\":{\"1\":1}}],[\"prompb\",{\"1\":{\"166\":3}}],[\"promconsole\",{\"1\":{\"135\":5}}],[\"prom\",{\"1\":{\"108\":1,\"134\":1,\"135\":2,\"167\":1,\"175\":1,\"195\":1,\"201\":1,\"203\":1,\"205\":1,\"274\":1}}],[\"promsql\",{\"0\":{\"17\":1}}],[\"promql的默认行为会依次将瞬时向量中的所有样本与标量之间进行比较运算\",{\"1\":{\"360\":1}}],[\"promql的时间范围选择器支持其它时间单位\",{\"1\":{\"260\":1}}],[\"promql除了能够对数据进行基本的查询统计以外\",{\"1\":{\"354\":1}}],[\"promql是prometheus自定义的一套强大的数据查询语言\",{\"1\":{\"282\":1}}],[\"promql是prometheus所有应用场景的基础\",{\"1\":{\"258\":1}}],[\"promql是prometheus内置的数据查询语言\",{\"1\":{\"258\":1}}],[\"promql是prometheus的标准查询语句\",{\"1\":{\"225\":1}}],[\"promql表达式可能返回多种数据类型\",{\"1\":{\"256\":1}}],[\"promql表达式\",{\"1\":{\"255\":1,\"257\":1}}],[\"promql依次比较向量中的所有时间序列样本的值\",{\"1\":{\"245\":1}}],[\"promql支持使用=和\",{\"1\":{\"259\":1}}],[\"promql支持的所有数学运算符如下所示\",{\"1\":{\"244\":1}}],[\"promql支持常见的运算操作符\",{\"1\":{\"224\":1}}],[\"promql还直接支持用户使用标量\",{\"1\":{\"263\":1}}],[\"promql还可以支持使用正则表达式作为匹配条件\",{\"1\":{\"259\":1}}],[\"promql还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤\",{\"1\":{\"259\":1}}],[\"promql还支持丰富的操作符\",{\"1\":{\"243\":1}}],[\"promql还提供了大量的其它内置函数\",{\"1\":{\"242\":1}}],[\"promql中内置的predict\",{\"1\":{\"239\":1}}],[\"promql中还直接内置了rate\",{\"1\":{\"238\":1}}],[\"promql提供了另外一个灵敏度更高的函数irate\",{\"1\":{\"238\":1}}],[\"promql内置的聚合操作和函数可以让用户对这些数据进行进一步的分析\",{\"1\":{\"228\":1}}],[\"promql内置函数\",{\"0\":{\"237\":1},\"1\":{\"3\":1,\"8\":1,\"20\":1}}],[\"promql作为prometheus的核心能力除了实现数据的对外查询和展现\",{\"1\":{\"224\":1}}],[\"promql\",{\"1\":{\"60\":1,\"72\":1,\"95\":4}}],[\"promql聚合操作\",{\"0\":{\"226\":1},\"1\":{\"8\":1,\"20\":1}}],[\"promql操作符\",{\"0\":{\"243\":1,\"354\":1},\"1\":{\"8\":1,\"20\":1}}],[\"payload\",{\"1\":{\"319\":2}}],[\"payload=\",{\"1\":{\"48\":3}}],[\"passed\",{\"1\":{\"135\":3}}],[\"password=prom\",{\"1\":{\"167\":1}}],[\"password=password\",{\"1\":{\"108\":1}}],[\"password=admin\",{\"1\":{\"167\":1}}],[\"password\",{\"1\":{\"26\":1,\"50\":2,\"102\":1,\"108\":1,\"165\":2,\"167\":1,\"217\":3,\"317\":1}}],[\"path2\",{\"1\":{\"294\":1}}],[\"pathprefix\",{\"1\":{\"134\":3}}],[\"path=$gopath\",{\"1\":{\"150\":1}}],[\"path=\",{\"1\":{\"95\":21,\"106\":1,\"108\":1,\"149\":2,\"150\":3,\"151\":2,\"217\":1,\"273\":1,\"294\":3,\"307\":1}}],[\"path\",{\"1\":{\"95\":5,\"100\":3,\"156\":1,\"160\":2,\"165\":2,\"169\":1,\"187\":1,\"189\":1,\"190\":2,\"196\":1,\"197\":2,\"199\":2,\"200\":2,\"201\":4,\"203\":3,\"207\":4,\"214\":1,\"218\":1,\"273\":1,\"294\":2,\"306\":1,\"309\":1}}],[\"path用于指定数据存储路径\",{\"1\":{\"56\":1}}],[\"panel中可以通过value\",{\"1\":{\"144\":1}}],[\"panel的options选项控制当前面板的显示模式\",{\"1\":{\"144\":1}}],[\"panel的编辑页面中\",{\"1\":{\"141\":1}}],[\"panel而言\",{\"1\":{\"144\":1}}],[\"panel侧重于展示系统的当前状态而非变化趋势\",{\"1\":{\"143\":1}}],[\"panel不需要自身对数据\\b的分布情况进行计算\",{\"1\":{\"141\":1}}],[\"panel会要求用户提供bucket分布范围的设置\",{\"1\":{\"142\":1}}],[\"panel会自行对promql查询出的数据进行分布情况统计\",{\"1\":{\"141\":1}}],[\"panel会根据当前数据源类型加载不同的query\",{\"1\":{\"126\":1}}],[\"panel编辑页面\",{\"1\":{\"141\":1}}],[\"panel即可\",{\"1\":{\"141\":1}}],[\"panel也非常简单\",{\"1\":{\"141\":1}}],[\"panel可以自动对histogram类型的监控指标分布情况进行计划\",{\"1\":{\"141\":1}}],[\"panel实现对prometheus监控指标的可视化\",{\"1\":{\"140\":1}}],[\"panel来的直观\",{\"1\":{\"137\":1}}],[\"panel能够展示正确的数据\",{\"1\":{\"131\":1}}],[\"panel能够自动化格式化样本值\",{\"1\":{\"77\":1}}],[\"panel是grafana中最基本的可视化单元\",{\"1\":{\"126\":1}}],[\"panel是grafana提供的基础可视化组件之一\",{\"1\":{\"76\":1}}],[\"panel等\",{\"1\":{\"123\":1}}],[\"panel以及table\",{\"1\":{\"123\":1}}],[\"panel通过如趋势图\",{\"1\":{\"123\":1}}],[\"panel在默认情况下format\",{\"1\":{\"77\":1}}],[\"panel支持直接将promql返回的时间序列格式化为表格的形式进行展示\",{\"1\":{\"76\":1}}],[\"panel示例\",{\"1\":{\"76\":1,\"143\":1}}],[\"panel\",{\"0\":{\"76\":1,\"126\":1,\"144\":1},\"1\":{\"123\":2,\"126\":1,\"141\":2,\"144\":1}}],[\"pages\",{\"1\":{\"111\":13}}],[\"page\",{\"1\":{\"66\":1,\"67\":1,\"69\":2,\"151\":2}}],[\"pager将会接收到按cluster和alertname进行分组的告警通知\",{\"1\":{\"42\":1}}],[\"pager发送告警通知\",{\"1\":{\"42\":1}}],[\"pager\",{\"1\":{\"42\":3}}],[\"pagerduty\",{\"1\":{\"26\":2,\"43\":2}}],[\"parameter\",{\"1\":{\"226\":2,\"368\":2}}],[\"param\",{\"1\":{\"100\":5,\"196\":2,\"197\":2,\"203\":6,\"309\":1}}],[\"params\",{\"1\":{\"100\":3,\"156\":1,\"169\":1,\"196\":1,\"197\":1,\"203\":2}}],[\"parsequery\",{\"1\":{\"350\":1}}],[\"parse\",{\"1\":{\"33\":1}}],[\"partyid2\",{\"1\":{\"51\":1}}],[\"partyid1\",{\"1\":{\"51\":1}}],[\"party\",{\"1\":{\"51\":3}}],[\"part\",{\"0\":{\"8\":1,\"9\":1,\"10\":1,\"20\":1,\"21\":1,\"22\":1}}],[\"package\",{\"1\":{\"28\":2,\"31\":2,\"32\":1,\"33\":1,\"166\":3,\"349\":1,\"350\":1}}],[\"项目主页\",{\"0\":{\"7\":1}}],[\"能更好地与容器平台\",{\"1\":{\"288\":1}}],[\"能够找到并解决根源问题\",{\"1\":{\"289\":1}}],[\"能够帮助用户将传统的面向结果转变为面向预测的方式\",{\"1\":{\"225\":1}}],[\"能够通过service的形式访问到集群外的资源\",{\"1\":{\"206\":1}}],[\"能够与kube\",{\"1\":{\"202\":1}}],[\"能够快速判断当前服务的可用性\",{\"1\":{\"194\":1}}],[\"能够快速处理和恢复\",{\"1\":{\"180\":1,\"184\":1}}],[\"能够自动忽略冲突的监控数据\",{\"1\":{\"169\":1}}],[\"能够展示监控样本数据在一段时间内的变化趋势\",{\"1\":{\"137\":1}}],[\"能够在黑盒的角度快速发现已经发生的问题\",{\"1\":{\"98\":1}}],[\"能够正常接收来自prometheus的告警信息\",{\"1\":{\"59\":1}}],[\"能够充分简化prometheus的运维和管理难度\",{\"1\":{\"5\":1}}],[\"能过帮助用户快速实现告警的通知\",{\"1\":{\"25\":1}}],[\"能做什么\",{\"1\":{\"1\":1,\"5\":1}}],[\"余下的章节我们会关注到prometheus的高级\\b用法部分\",{\"1\":{\"5\":1}}],[\"对样本数据进行+1或者\",{\"1\":{\"352\":1}}],[\"对样本数据进行聚合\",{\"0\":{\"81\":1}}],[\"对基于时间序列的数据进行存储\",{\"1\":{\"325\":1}}],[\"对外提供查询和图形可视化的功能\",{\"1\":{\"324\":1}}],[\"对外提供应用容器的自动化部署和管理能力\",{\"1\":{\"180\":1,\"184\":1}}],[\"对target实例的标签进行重写的机制在prometheus被称为relabeling\",{\"1\":{\"309\":1}}],[\"对照分析\",{\"1\":{\"289\":1}}],[\"对监控指标进行长期趋势分析\",{\"1\":{\"289\":1}}],[\"对监控数据进行查询\",{\"1\":{\"5\":1}}],[\"对应的数据结构\",{\"1\":{\"269\":1}}],[\"对时间序列进行过滤\",{\"1\":{\"245\":1}}],[\"对时间窗口内的样本数据进行统计\",{\"1\":{\"239\":1}}],[\"对数据的变化趋势进行预测\",{\"1\":{\"229\":1}}],[\"对value进行计数\",{\"1\":{\"226\":1,\"368\":1}}],[\"对ingress和service进行网络探测\",{\"0\":{\"203\":1}}],[\"对prometheus进行访问授权\",{\"1\":{\"186\":1}}],[\"对集群中部署的服务进行探测\",{\"1\":{\"180\":1,\"184\":1}}],[\"对资源进行隔离\",{\"1\":{\"178\":1}}],[\"对service和ingress进行网络探测\",{\"1\":{\"171\":1}}],[\"对所有请求\",{\"1\":{\"94\":1}}],[\"对一组相关的告警进行统一定义\",{\"1\":{\"60\":1}}],[\"对告警信息按照集群以及告警的名称对告警进行分组\",{\"1\":{\"42\":1}}],[\"对于没有匹配的样本数据\",{\"1\":{\"358\":1}}],[\"对于counter而言只有一个\",{\"1\":{\"352\":1}}],[\"对于研发团队而言\",{\"1\":{\"308\":1}}],[\"对于线上环境我们可能会划分为\",{\"1\":{\"308\":1}}],[\"对于决策者而言要么你就直接在应用中集成该监控系统的支持\",{\"1\":{\"300\":1}}],[\"对于单一prometheus\",{\"1\":{\"296\":1}}],[\"对于监控系统而言\",{\"1\":{\"296\":1}}],[\"对于基于这类模型的监控系统而言往往存在以下问题\",{\"1\":{\"290\":1}}],[\"对于nagios这类基于push模式传统监控软件就意味着必须在每一个节点上安装相应的agent程序\",{\"1\":{\"313\":1}}],[\"对于nagios这类系统而言\",{\"1\":{\"290\":1}}],[\"对于node\",{\"1\":{\"201\":1,\"205\":1}}],[\"对于常用的监控系统\",{\"1\":{\"290\":1}}],[\"对于docker用户\",{\"1\":{\"274\":1}}],[\"对于非docker用户\",{\"1\":{\"273\":1}}],[\"对于非histogram类型\",{\"1\":{\"142\":1}}],[\"对于复杂类型的表达式\",{\"1\":{\"248\":1}}],[\"对于主机而言在2分钟的时间窗口内\",{\"1\":{\"238\":1}}],[\"对于主机负载而言\",{\"1\":{\"144\":1}}],[\"对于失败而言有些是显式的\",{\"1\":{\"234\":1}}],[\"对于传统监控解决方案而言\",{\"1\":{\"232\":1}}],[\"对于gauge类型的监控指标\",{\"1\":{\"229\":1}}],[\"对于grafana而言\",{\"1\":{\"125\":1}}],[\"对于grafana管理员而言\",{\"1\":{\"122\":1}}],[\"对于部署prometheus\",{\"1\":{\"216\":1}}],[\"对于集群内的任意服务都可以通过该内部dns域名访问blackbox\",{\"1\":{\"203\":1}}],[\"对于用户任意部署的pod实例\",{\"1\":{\"201\":1}}],[\"对于用户而言\",{\"1\":{\"193\":1,\"210\":1,\"290\":1}}],[\"对于用户而言最重要的事情就是实现数据的可视化\",{\"1\":{\"123\":1}}],[\"对于内置了prometheus支持的应用\",{\"1\":{\"198\":1}}],[\"对于内置了对prometheus支持的应用程序\",{\"1\":{\"180\":1,\"184\":1}}],[\"对于prometheus而言也不可能支持所有的平台或者环境\",{\"1\":{\"307\":1}}],[\"对于prometheus而言\",{\"1\":{\"213\":1}}],[\"对于prometheus采集到的时间序列数据\",{\"1\":{\"76\":1}}],[\"对于pod启动时间可以通过指标kubelet\",{\"1\":{\"193\":1}}],[\"对于ingress而言\",{\"1\":{\"203\":1}}],[\"对于ingress\",{\"1\":{\"187\":1}}],[\"对于incomming\",{\"1\":{\"49\":1}}],[\"对于mac用户可以直接使用brew进行安装\",{\"1\":{\"181\":1}}],[\"对于外部用户而言\",{\"1\":{\"180\":1,\"184\":1}}],[\"对于同一个kubernetes集群其可能被多个组织使用\",{\"1\":{\"178\":1}}],[\"对于第一个问题\",{\"1\":{\"178\":1}}],[\"对于这组容器而言它们共享相同的网络和存储资源\",{\"1\":{\"178\":1}}],[\"对于中心prometheus\",{\"1\":{\"169\":1}}],[\"对于大部分监控规模而言\",{\"1\":{\"169\":1}}],[\"对于规则文件的处理\",{\"1\":{\"164\":1}}],[\"对于多核主机\",{\"1\":{\"151\":1}}],[\"对于singlestat\",{\"1\":{\"144\":1}}],[\"对于一个panel而言\",{\"1\":{\"126\":1}}],[\"对于一些prometheus还不支持的云环境\",{\"1\":{\"307\":1}}],[\"对于一些复杂的情况\",{\"1\":{\"292\":1}}],[\"对于一些显式的错误如http\",{\"1\":{\"234\":1}}],[\"对于一些启用了https的服务\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于一些需要请求参数的服务\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于一些短周期或者临时采集的样本数据\",{\"1\":{\"91\":1}}],[\"对于某些应用和服务而言它们可能内置了对prometheus的支持\",{\"1\":{\"370\":1}}],[\"对于某些prometheus还没有提供支持的编程语言\",{\"1\":{\"116\":1}}],[\"对于某些启用了安全认证的服务还需要能够对http探测设置相应的auth支持\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于类型histogram的指标x为了表示其样本的分布情况\",{\"1\":{\"116\":1}}],[\"对于类型为summary的指标x\",{\"1\":{\"116\":1}}],[\"对于数据库而言\",{\"1\":{\"109\":1}}],[\"对于使用prometheus作为数据源的用户\",{\"1\":{\"126\":1}}],[\"对于使用了bear\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于使用者而言只需要查询这些运算结果即可\",{\"1\":{\"71\":1}}],[\"对于https的支持需要设定tls\",{\"1\":{\"165\":1}}],[\"对于https类型的服务还需要能够对证书进行自定义设置\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于histogram类型的监控指标来说\",{\"1\":{\"141\":1}}],[\"对于histogram类型的指标也可以支持\",{\"1\":{\"137\":1}}],[\"对于histogram和summary的样本\",{\"1\":{\"116\":1}}],[\"对于histogram而言\",{\"1\":{\"90\":1}}],[\"对于任何能够提供promethues标准的监控样本的程序都可以称为exporter\",{\"1\":{\"83\":1}}],[\"对于不同类型的http的探测需要管理员能够对http探针的行为进行更多的自定义设置\",{\"1\":{\"102\":1,\"317\":1}}],[\"对于不同级别的告警\",{\"1\":{\"40\":1}}],[\"对于不同的用户和组织而言还需要一些自定义的告知方式支持\",{\"1\":{\"27\":1}}],[\"对于已经生效的规则\",{\"1\":{\"37\":1,\"39\":1}}],[\"对大部分的研发或者运维人员来说可以快速掌握\",{\"1\":{\"5\":1}}],[\"从日志文件中获取监控样本\",{\"0\":{\"388\":1}}],[\"从nginx\",{\"0\":{\"387\":1}}],[\"从node\",{\"0\":{\"287\":1},\"1\":{\"310\":1}}],[\"从服务发现注册中心返回的target实例中有选择性的采集某些exporter实例的监控数据\",{\"1\":{\"308\":1}}],[\"从2012年开始由前google工程师在soundcloud以开源软件的形式进行研发\",{\"1\":{\"288\":1}}],[\"从注释中可以看出当前指标类型为仪表盘\",{\"1\":{\"286\":1}}],[\"从类型中也可以看出node\",{\"1\":{\"286\":1}}],[\"从二进制包安装\",{\"0\":{\"273\":1}}],[\"从理论上讲只要系统不关机\",{\"1\":{\"227\":1}}],[\"从存储上来讲所有的监控指标metric都是相同的\",{\"1\":{\"227\":1}}],[\"从概念上来讲operator就是针对管理特定应用程序的\",{\"1\":{\"221\":1}}],[\"从本质上来讲prometheus属于是典型的有状态应用\",{\"1\":{\"220\":1}}],[\"从ui中我们可以查看到通过prometheusrule自动创建的告警规则配置\",{\"1\":{\"213\":1}}],[\"从kube\",{\"0\":{\"202\":1}}],[\"从kubelet获取节点容器资源使用情况\",{\"0\":{\"200\":1}}],[\"从kubelet获取节点运行状态\",{\"0\":{\"199\":1}}],[\"从部署到各个节点的node\",{\"1\":{\"198\":1}}],[\"从集群各节点kubelet内置的cadvisor中获取\",{\"1\":{\"198\":1}}],[\"从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标\",{\"1\":{\"198\":1}}],[\"从集群中各节点的kubelet服务获取节点的基本运行状态\",{\"1\":{\"184\":1}}],[\"从上面的描述中可以看出exporter可以是一个相对开放的概念\",{\"1\":{\"285\":1}}],[\"从上面的样本中可以得知当前prometheus\",{\"1\":{\"230\":1}}],[\"从上面的结果可以看出\",{\"1\":{\"189\":1}}],[\"从上面公式中可以看出在保留时间\",{\"1\":{\"160\":1}}],[\"从prometheus\",{\"1\":{\"189\":1}}],[\"从黑盒监控的角度在集群中部署blackbox\",{\"1\":{\"184\":1}}],[\"从自身架构上讲\",{\"1\":{\"180\":1,\"184\":1}}],[\"从物理结构上讲kubernetes主要用于整合和管理底层的基础设施资源\",{\"1\":{\"180\":1,\"184\":1}}],[\"从remote\",{\"1\":{\"167\":1}}],[\"从失败中恢复\",{\"0\":{\"161\":1}}],[\"从dashboardc创建singlestat\",{\"1\":{\"144\":1}}],[\"从1970\",{\"1\":{\"116\":1}}],[\"从exporter的运行方式上来讲\",{\"1\":{\"115\":1}}],[\"从exporter的来源上来讲\",{\"1\":{\"114\":1}}],[\"从mysqld\",{\"1\":{\"109\":1}}],[\"从配置管理的角度来说显然是不可接受的\",{\"1\":{\"100\":1}}],[\"从返回的样本中\",{\"1\":{\"99\":1}}],[\"从而产生一条新的瞬时时间序列\",{\"1\":{\"360\":1}}],[\"从而产生多个pod实例\",{\"1\":{\"174\":1}}],[\"从而将监控样本返回给prometheus\",{\"1\":{\"350\":1}}],[\"从而大大的减少了在云原生\",{\"1\":{\"313\":1}}],[\"从而使用户部署在aws上的应用可以自动的适应访问规模的变化\",{\"1\":{\"313\":1}}],[\"从而使用户可以动态的改变变量的值\",{\"1\":{\"128\":1}}],[\"从而向这些target轮询监控数据\",{\"1\":{\"308\":1}}],[\"从而达到以下目的\",{\"1\":{\"289\":1}}],[\"从而了解prometheus中的一些概念以及架构模式\",{\"1\":{\"270\":1}}],[\"从而形成一条新的时间序列\",{\"1\":{\"246\":1,\"361\":1,\"363\":1}}],[\"从而得到一组新的时间序列\",{\"1\":{\"244\":1}}],[\"从而能够对问题进行快速的处理或者提前预防问题的发生\",{\"1\":{\"289\":1}}],[\"从而能够更好的于客户端或者可视化工具配合\",{\"1\":{\"241\":1}}],[\"从而能够动态的发现kubernetes中部署的所有可监控的目标资源\",{\"1\":{\"185\":1}}],[\"从而更有效的为业务和系统的正常运行保驾护航\",{\"1\":{\"225\":1}}],[\"从而让用户可以获取服务和应用内部真正的运行状态\",{\"1\":{\"293\":1}}],[\"从而让kubernetes可以使用最新的配置文件创建prometheus\",{\"1\":{\"220\":1}}],[\"从而让其以不同的样式展示\",{\"1\":{\"138\":1}}],[\"从而过滤出需要探测的所有service实例\",{\"1\":{\"203\":1}}],[\"从而从kubelet采集到监控数据\",{\"1\":{\"199\":1}}],[\"从而评估当前集群的运行状态以及性能\",{\"1\":{\"191\":1}}],[\"从而获得cadvisor访问地址\",{\"1\":{\"190\":1}}],[\"从而获取到cadvisor的监控数据\",{\"1\":{\"190\":1}}],[\"从而动态的获取需要监控的目标实例\",{\"1\":{\"185\":1}}],[\"从而动态生成变量的可选值\",{\"1\":{\"130\":1}}],[\"从而当应用发生故障后\",{\"1\":{\"180\":1,\"184\":1}}],[\"从而提供一个安全可靠的生产运行环境\",{\"1\":{\"180\":1,\"182\":1}}],[\"从而确保当prometheus发生宕机或者重启之后能够从influxdb中恢复和获取历史数据\",{\"1\":{\"167\":1}}],[\"从而恢复数据\",{\"1\":{\"159\":1}}],[\"从而匹配出标签instance的值作为node变量的所有可选项\",{\"1\":{\"130\":1}}],[\"从而减少从prometheus返回的数据量\",{\"1\":{\"126\":1}}],[\"从而可以监控程序的内部运行情况\",{\"1\":{\"352\":1}}],[\"从而可以更好的对数据进行聚合\",{\"1\":{\"310\":1}}],[\"从而可以通过该标签按照环境对数据进行统计\",{\"1\":{\"307\":1}}],[\"从而可以对时间序列的变化趋势做出预测\",{\"1\":{\"239\":1}}],[\"从而可以让用户可以使用自定义的prometheus配置文件\",{\"1\":{\"210\":1}}],[\"从而可以让prometheus通过访问http\",{\"1\":{\"190\":1}}],[\"从而可以反映出docker本身是否会影响kubelet的性能表现等问题\",{\"1\":{\"199\":1}}],[\"从而可以方便用户通过这些标签对数据进行聚合\",{\"1\":{\"190\":1}}],[\"从而可以使外部客户端能够访问到部署在kubernetes集群内的服务\",{\"1\":{\"180\":1}}],[\"从而可以使prometheuse可以根据规模进行扩展\",{\"1\":{\"145\":1}}],[\"从而可以有效的根据企业的组织架构定义整个管理模型\",{\"1\":{\"124\":1}}],[\"从而可以细化mysql查询响应时间的分布情况\",{\"1\":{\"112\":1}}],[\"从而实现对这些云环境中基础设施的自动化监控支持\",{\"1\":{\"307\":1}}],[\"从而实现对特定pod实例监控指标的采集\",{\"1\":{\"201\":1}}],[\"从而实现特定应用程序的常见操作以及运维自动化\",{\"1\":{\"221\":1}}],[\"从而实现功能分区\",{\"1\":{\"155\":1}}],[\"从而实现可以与用户动态交互的dashboard页面\",{\"1\":{\"123\":1}}],[\"从而实现应用层面的监控对接\",{\"1\":{\"5\":1}}],[\"从而支持记录查询时间区间的统计信息\",{\"1\":{\"112\":1}}],[\"从而帮助管理员主动的发现故障和问题\",{\"1\":{\"99\":1}}],[\"从而对潜在的不确定因素进行优化\",{\"1\":{\"98\":1,\"289\":1}}],[\"从而通过钉钉接收告警信息\",{\"1\":{\"60\":1}}],[\"从alertmanager的alerts页面下用户将不会看到该规则匹配到的告警信息\",{\"1\":{\"37\":1,\"39\":1}}],[\"从第1章到第4章的部分都是本书的基础性章节\",{\"1\":{\"5\":1}}],[\"之后还会带领读者通过java和golang实现自定义的exporter\",{\"1\":{\"5\":1}}],[\"这个代理人掌握着当前所有监控目标的访问信息\",{\"1\":{\"313\":1}}],[\"这个时候我们就可以使用位移操作\",{\"1\":{\"261\":1}}],[\"这个时候点击该菜单\",{\"1\":{\"133\":1}}],[\"这个值是会无限变大的\",{\"1\":{\"227\":1}}],[\"这是一种rrd风格的数据库\",{\"1\":{\"326\":1}}],[\"这是一种基于文本的格式规范\",{\"1\":{\"116\":1}}],[\"这是可视化工具渲染图标时可能根据\",{\"1\":{\"241\":1}}],[\"这是由于prometheus\",{\"1\":{\"214\":1}}],[\"这是由于当前使用的ca证书中\",{\"1\":{\"199\":1}}],[\"这是我们可以创建一个不包含selector的service即可\",{\"1\":{\"206\":1}}],[\"这是就可以通过在集群内创建service\",{\"1\":{\"202\":1}}],[\"这是为了避免集群内的应用硬编码数据库的访问信息\",{\"1\":{\"202\":1}}],[\"这本章中\",{\"1\":{\"146\":1}}],[\"这种按需的资源使用方式对于监控系统而言就意味着没有了一个固定的监控目标\",{\"1\":{\"313\":1}}],[\"这种发生在采集样本数据之前\",{\"1\":{\"309\":1}}],[\"这种通用的方式可以衍生了很多不同的玩法\",{\"1\":{\"307\":1}}],[\"这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的\",{\"1\":{\"239\":1}}],[\"这种基于service的annotations来控制prometheus的方式\",{\"1\":{\"207\":1}}],[\"这种方式不需要依赖于任何的平台或者第三方服务\",{\"1\":{\"307\":1}}],[\"这种方式可以避免在时间窗口范围内的\",{\"1\":{\"238\":1}}],[\"这种方式的问题很明显\",{\"1\":{\"230\":1}}],[\"这种方式我们成为声明式\",{\"1\":{\"221\":1}}],[\"这种方式限制了cadvisor服务的运行端口\",{\"1\":{\"190\":1}}],[\"这种方式在prometheus中称为remote\",{\"1\":{\"162\":1}}],[\"这种方式打破的监控的界限\",{\"1\":{\"115\":1}}],[\"这种情况只能考虑继续在实例级别进行功能划分\",{\"1\":{\"156\":1}}],[\"这种模式被称为服务发现\",{\"1\":{\"313\":1}}],[\"这种模式也适合与多数据中心的情况\",{\"1\":{\"155\":1}}],[\"这种模式特别适合于展示服务的健康状态\",{\"1\":{\"144\":1}}],[\"这种场景下prometheus的性能瓶颈主要在于大量的采集任务\",{\"1\":{\"155\":1}}],[\"这种部署方式一般适用于两种场景\",{\"1\":{\"155\":1}}],[\"这一角色\",{\"1\":{\"313\":1}}],[\"这一类exporter直接内置了对prometheus监控的支持\",{\"1\":{\"277\":1}}],[\"这一小节中将重点介绍如何利用promql对时间序列进行各种逻辑和数学运算的\",{\"1\":{\"354\":1}}],[\"这一小节中\",{\"1\":{\"348\":1}}],[\"这一小节中我们将讨论当使用kubernetes时的监控策略该如何设计\",{\"1\":{\"180\":1,\"182\":1}}],[\"这一小节当中将介绍如何使用prometheus提供的mysqld\",{\"1\":{\"107\":1}}],[\"这一特性在prometheus中称为联邦集群\",{\"1\":{\"169\":1}}],[\"这一部分\",{\"1\":{\"347\":1}}],[\"这一部分我们将带领读者通过kubernetes部署prometheus实例\",{\"1\":{\"173\":1}}],[\"这一部分会重点讨论如何利用联邦集群特性对prometheus进行扩展\",{\"1\":{\"168\":1}}],[\"这一部分将重点讨论prometheus的高可用架构\",{\"1\":{\"152\":1}}],[\"这一章节中我们的另外一位重要成员kubernetes将会登场\",{\"1\":{\"5\":1}}],[\"这一章节中重点讨论prometheus高可用方面的能力\",{\"1\":{\"5\":1}}],[\"这一章中读者将学习如何在prometheus中自定义告警规则\",{\"1\":{\"5\":1}}],[\"这12次http请求响应时间的9分位数是8\",{\"1\":{\"95\":1}}],[\"这12次http请求响应时间的中位数是3\",{\"1\":{\"95\":1}}],[\"这12次http请求的总响应时间为\",{\"1\":{\"95\":1}}],[\"这样每个target实例都会包含一个新的标签tmp\",{\"1\":{\"312\":1}}],[\"这样可以方便的根据dc标签的值\",{\"1\":{\"310\":1}}],[\"这样可以避免用户进行大量的网络配置\",{\"1\":{\"155\":1}}],[\"这样可以避免接收到大量与实际问题无关的告警通知\",{\"1\":{\"63\":1}}],[\"这样从这些实例中采集到的样本信息将包含这些标签信息\",{\"1\":{\"307\":1}}],[\"这样的返回结果我们称之为\",{\"1\":{\"260\":1}}],[\"这样的函数\",{\"1\":{\"237\":1}}],[\"这样的一个程序称为exporter\",{\"1\":{\"82\":1}}],[\"这样我们就可以通过这些地址获取到相应的监控指标\",{\"1\":{\"207\":1}}],[\"这样我们可以通过虚拟机ip和端口访问到prometheus实例\",{\"1\":{\"175\":1}}],[\"这样通过service就可以访问到对应的nodeexporter实例\",{\"1\":{\"201\":1,\"205\":1}}],[\"这样prometheus在采集样本数据时\",{\"1\":{\"199\":1}}],[\"这时我们可以通过promql语言在\",{\"1\":{\"378\":1}}],[\"这时我们可以看到新的采集任务\",{\"1\":{\"378\":1}}],[\"这时我们可以使用bool改变比较运算的默认行为\",{\"1\":{\"361\":1}}],[\"这时我们需要使用query类型的变量\",{\"1\":{\"130\":1}}],[\"这时用户可以考虑使用第三方的可视化工具如grafana\",{\"1\":{\"283\":1}}],[\"这时可以使用bool修饰符改变布尔运算的默认行为\",{\"1\":{\"246\":1}}],[\"这时可以按照服务所在集群或者告警名称对告警进行分组\",{\"1\":{\"62\":1}}],[\"这时\",{\"1\":{\"239\":1}}],[\"这时简单通过联邦集群进行功能分区\",{\"1\":{\"156\":1}}],[\"这时在考虑另外一种极端情况\",{\"1\":{\"156\":1}}],[\"这时需要使用grafana的query\",{\"1\":{\"130\":1}}],[\"这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算\",{\"1\":{\"71\":1}}],[\"这时如果要忽略是哪一个cpu的\",{\"1\":{\"282\":1}}],[\"这时如果客户端要求使用mb作为单位响应数据\",{\"1\":{\"244\":1}}],[\"这时如果某一容器频繁重启\",{\"1\":{\"51\":1}}],[\"这时如果手动拉高主机cpu使用率\",{\"1\":{\"50\":1}}],[\"这部分我们将带领读者学习prometheus社区提供的client\",{\"1\":{\"348\":1}}],[\"这部分我们会在后续部分介绍\",{\"1\":{\"57\":1}}],[\"这部分内容会在本章的\",{\"1\":{\"126\":1}}],[\"这部分\",{\"1\":{\"75\":1,\"140\":1}}],[\"这部分将介绍如何将slack集成到alertmanager中\",{\"1\":{\"46\":1}}],[\"这部分将会基于grafana这一可视化工具实现监控数据可视化\",{\"1\":{\"5\":1}}],[\"这些程序被称为exporter\",{\"1\":{\"370\":1}}],[\"这些资源可以随着需求规模的变化而变化\",{\"1\":{\"313\":1}}],[\"这些target时候都会包含一些默认的标签\",{\"1\":{\"309\":1}}],[\"这些插件会返回4种nagios可识别的状态\",{\"1\":{\"290\":1}}],[\"这些样本数据按照时间先后顺序展示\",{\"1\":{\"282\":1}}],[\"这些操作符包括\",{\"1\":{\"243\":1}}],[\"这些操作符作用域瞬时向量\",{\"1\":{\"226\":1,\"368\":1}}],[\"这些内置函数包括一些常用的数学计算\",{\"1\":{\"242\":1}}],[\"这些并不在prometheus\",{\"1\":{\"210\":1}}],[\"这些所有的操作在kubernetes同样被视为是一系列的资源\",{\"1\":{\"186\":1}}],[\"这些基础设施可能是物理机\",{\"1\":{\"180\":1,\"184\":1}}],[\"这些海量资源组成了一个能够方便进行扩展的操作系统\",{\"1\":{\"177\":1}}],[\"这些查询结果都是临时的\",{\"1\":{\"132\":1}}],[\"这些硬编码方式都会直接导致dashboard配置的频繁修改\",{\"1\":{\"127\":1}}],[\"这些exporter程序扮演了一个中间代理人的角色\",{\"1\":{\"115\":1}}],[\"这些exporter可以实现大部分通用的监控需求\",{\"1\":{\"114\":1}}],[\"这些配置信息可能是一些自定义的http头信息\",{\"1\":{\"99\":1}}],[\"这些都是支持业务和服务的基础设施\",{\"1\":{\"98\":1}}],[\"这些规则文件的计算频率与告警规则计算频率一致\",{\"1\":{\"72\":1}}],[\"这些告警信息并不能有效的支持用户对于故障根源问题的分析和定位\",{\"1\":{\"290\":1}}],[\"这些告警中通过添加标签team来标示这些告警的创建者\",{\"1\":{\"42\":1}}],[\"这些告警将会合并为一个通知向receiver发送\",{\"1\":{\"42\":1}}],[\"这些属性的配置信息将从上级路由继承\",{\"1\":{\"42\":1}}],[\"这些route通过标签匹配告警的处理方式\",{\"1\":{\"40\":1}}],[\"这里所有的exporters都继承自collector\",{\"1\":{\"350\":1}}],[\"这里返回的是当前应用中jvm相关的监控指标\",{\"1\":{\"349\":1}}],[\"这里实际上是发生了一次标签的重写处理\",{\"1\":{\"309\":1}}],[\"这里限定了只获取node\",{\"1\":{\"306\":1}}],[\"这里以garbagecollectorexports为例\",{\"1\":{\"350\":1}}],[\"这里以graph面板为例\",{\"1\":{\"126\":1}}],[\"这里以nagios为例\",{\"1\":{\"290\":1}}],[\"这里主要是针对资源的饱和度\",{\"1\":{\"236\":1}}],[\"这里的资源主要包括但不限于\",{\"1\":{\"236\":1}}],[\"这里的web\",{\"1\":{\"40\":1}}],[\"这里还有一些通用的套路和模式可以使用\",{\"1\":{\"233\":1}}],[\"这里还需要为alertmanager创建相应的配置内容\",{\"1\":{\"214\":1}}],[\"这里先思考一个基本的问题\",{\"1\":{\"231\":1}}],[\"这里是192\",{\"1\":{\"206\":1}}],[\"这里给出对ingress探测的prometheus任务配置作为参考\",{\"1\":{\"203\":1}}],[\"这里指定了服务发现模式为endpoints\",{\"1\":{\"202\":1}}],[\"这里也有两种方式采集cadvisor中的监控指标\",{\"1\":{\"200\":1}}],[\"这里也可以使用countermetricfamily\",{\"1\":{\"96\":1}}],[\"这里同样通过node模式自动发现所有的kubelet信息\",{\"1\":{\"200\":1}}],[\"这里同时使用了simpleclient\",{\"1\":{\"93\":1}}],[\"这里需要修改prometheus配置文件\",{\"1\":{\"287\":1}}],[\"这里需要指定用于访问kubernetes\",{\"1\":{\"187\":1}}],[\"这里需要注意的是\",{\"1\":{\"130\":1,\"312\":1}}],[\"这里创建prometheus\",{\"1\":{\"186\":1}}],[\"这里创建了一个id为querygraph的div节点\",{\"1\":{\"135\":1}}],[\"这里创建了一个名为inprogress\",{\"1\":{\"89\":1}}],[\"这里为了能够采集到主机的运行指标如cpu\",{\"1\":{\"285\":1}}],[\"这里为了能够直接访问该service\",{\"1\":{\"181\":1}}],[\"这里为dashboard定义了一遍名为job的变量\",{\"1\":{\"131\":1}}],[\"这里利用curl分别向3个alertmanager实例发送告警信息\",{\"1\":{\"150\":1}}],[\"这里在本地启动一个webhook服务用于打印alertmanager发送的告警通知信息\",{\"1\":{\"150\":1}}],[\"这里就不做过多的介绍\",{\"1\":{\"305\":1}}],[\"这里就不一一细讲\",{\"1\":{\"242\":1}}],[\"这里就不重复介绍了\",{\"1\":{\"141\":1}}],[\"这里就不对protocol\",{\"1\":{\"116\":1}}],[\"这里选择单位为percent\",{\"1\":{\"138\":1}}],[\"这里提供了3个选项\",{\"1\":{\"126\":1}}],[\"这里使用服务定义文件的方式将本地运行的node\",{\"1\":{\"305\":1}}],[\"这里使用node模式自动发现集群中所有kubelet作为监控的数据采集目标\",{\"1\":{\"199\":1}}],[\"这里使用了一个轻量级的多线程管理工具goreman\",{\"1\":{\"149\":1}}],[\"这里使用了singlestat展示所有监控采集任务的状态\",{\"1\":{\"131\":1}}],[\"这里使用如下promql查询当前主机负载\",{\"1\":{\"144\":1}}],[\"这里使用docker\",{\"1\":{\"108\":1,\"167\":1}}],[\"这里使用gin\",{\"1\":{\"28\":1}}],[\"这里有没对http配置项添加任何配置\",{\"1\":{\"101\":1,\"316\":1}}],[\"这里针对每一个探针服务\",{\"1\":{\"100\":1}}],[\"这里分别配置了名为baidu\",{\"1\":{\"100\":1}}],[\"这里通过node\",{\"1\":{\"238\":1}}],[\"这里通过一个名为nginx\",{\"1\":{\"181\":1}}],[\"这里通过volumes声明了一个磁盘卷\",{\"1\":{\"175\":1}}],[\"这里通过环境变量data\",{\"1\":{\"108\":1}}],[\"这里通过method定义了探测时使用的请求方法\",{\"1\":{\"102\":1,\"317\":1}}],[\"这里通过在url中提供module参数指定了当前使用的探针\",{\"1\":{\"99\":1}}],[\"这里通过labels指定了当前样本各个标签对应的值\",{\"1\":{\"95\":1}}],[\"这里可以直接访问业务代码\",{\"1\":{\"96\":1}}],[\"这里\",{\"1\":{\"50\":1,\"223\":1}}],[\"这里如果我们手动拉高当前主机的cpu利用率\",{\"1\":{\"49\":1}}],[\"这里定义了三个relabel步骤\",{\"1\":{\"190\":1}}],[\"这里定义了一条自定义规则\",{\"1\":{\"138\":1}}],[\"这里定义了一个基于file\",{\"1\":{\"307\":1}}],[\"这里定义了一个名为node的变量\",{\"1\":{\"128\":1}}],[\"这里定义了一个名为my\",{\"1\":{\"85\":1}}],[\"这里定义了一个单独子路由\",{\"1\":{\"42\":1}}],[\"这里定义结构体dingtalkmarkdown用于映射dingtalk的消息体\",{\"1\":{\"31\":1}}],[\"这里将添加prometheus作为默认的数据源\",{\"1\":{\"283\":1}}],[\"这里将部署一个blackbox\",{\"1\":{\"203\":1}}],[\"这里将使用configmaps管理prometheus的配置文件\",{\"1\":{\"174\":1}}],[\"这里将介绍如何使用influxdb作为prometheus的remote\",{\"1\":{\"167\":1}}],[\"这里将继续扩展webhook服务\",{\"1\":{\"29\":1}}],[\"这里将详细介绍路由相关的内容\",{\"1\":{\"26\":1}}],[\"这里我们添加了一个新的job名字为node\",{\"1\":{\"377\":1}}],[\"这里我们添加了一个新的监控采集任务kubernetes\",{\"1\":{\"192\":1}}],[\"这里我们首先在集群中部署一个示例应用\",{\"1\":{\"217\":1}}],[\"这里我们为node\",{\"1\":{\"201\":1}}],[\"这里我们为dashboard创建了一个名为node的变量\",{\"1\":{\"130\":1}}],[\"这里我们通过deployment部署prometheus\",{\"1\":{\"175\":1}}],[\"这里我们想要能在grafana中动态改变标签值\",{\"1\":{\"130\":1}}],[\"这里我们主要介绍prometheus\",{\"1\":{\"126\":1}}],[\"这里我们也可以采用relabling的方式对这些配置进行简化\",{\"1\":{\"100\":1}}],[\"这里我们使用gauge记录当前应用正在处理的http请求数量\",{\"1\":{\"95\":1}}],[\"这里我们可以使用group\",{\"1\":{\"42\":1}}],[\"这里我们将演示如果将alertmanager运维报警提醒通过自定义机器人聚合到钉钉群\",{\"1\":{\"29\":1}}],[\"这里我们会带领读者对kubernetes有一个基本的认识\",{\"1\":{\"5\":1}}],[\"这里假定你已经对linux系统以及docker技术有一定的基本认识\",{\"1\":{\"5\":1}}],[\"作为前置的标签是在系统内部使用的\",{\"1\":{\"309\":1}}],[\"作为前缀的标签\",{\"1\":{\"269\":1}}],[\"作为promql表达式\",{\"1\":{\"265\":1}}],[\"作为示例\",{\"1\":{\"210\":1}}],[\"作为样本的标签保存到时间序列当中\",{\"1\":{\"199\":1}}],[\"作为系统管理员\",{\"1\":{\"180\":1,\"182\":1}}],[\"作为容器领域事实的标准\",{\"1\":{\"171\":1}}],[\"作为一个通用可视化工具\",{\"1\":{\"124\":1}}],[\"作为邮箱登录密码\",{\"1\":{\"50\":1}}],[\"作为监控系统的重要能力之一\",{\"1\":{\"5\":1}}],[\"作用\",{\"1\":{\"48\":1,\"130\":1,\"135\":1}}],[\"作者介绍\",{\"0\":{\"0\":1}}],[\"聚合操作\",{\"0\":{\"368\":1}}],[\"聚合等\",{\"1\":{\"269\":1}}],[\"聚合以及逻辑运算能力的支持\",{\"1\":{\"258\":1}}],[\"聚合以及其它各种运算操作\",{\"1\":{\"71\":1}}],[\"聚合\",{\"1\":{\"5\":1,\"258\":1,\"295\":1}}],[\"lcsrm\",{\"1\":{\"217\":1}}],[\"ls\",{\"1\":{\"186\":1}}],[\"lua\",{\"1\":{\"114\":1}}],[\"lucid\",{\"1\":{\"105\":1}}],[\"left指定左向量具有更好的基数\",{\"1\":{\"251\":1,\"367\":1}}],[\"left\",{\"1\":{\"251\":3,\"367\":3}}],[\"left或者group\",{\"1\":{\"251\":1,\"367\":1}}],[\"level\",{\"1\":{\"156\":1}}],[\"level=error\",{\"1\":{\"218\":1}}],[\"level=info\",{\"1\":{\"150\":3,\"273\":6}}],[\"level=debug\",{\"1\":{\"150\":7,\"151\":3}}],[\"legend控制图例的显示示例\",{\"1\":{\"138\":1}}],[\"legend选项\",{\"1\":{\"138\":1}}],[\"legends\",{\"1\":{\"135\":1}}],[\"legend\",{\"1\":{\"126\":1,\"135\":1,\"141\":1}}],[\"le=\",{\"1\":{\"95\":15,\"116\":6,\"139\":11,\"217\":1,\"230\":11,\"240\":6}}],[\"length\",{\"1\":{\"99\":4,\"117\":1,\"350\":1}}],[\"len\",{\"1\":{\"51\":10,\"166\":1}}],[\"l27vx\",{\"1\":{\"217\":1}}],[\"l2=\",{\"1\":{\"86\":1}}],[\"l2\",{\"1\":{\"85\":1}}],[\"l1=\",{\"1\":{\"86\":2}}],[\"l1\",{\"1\":{\"85\":2}}],[\"local访问到blackbox的实例\",{\"1\":{\"195\":1}}],[\"local\",{\"1\":{\"181\":1,\"196\":1,\"197\":1,\"203\":4,\"285\":1,\"373\":2,\"374\":1}}],[\"localhost\",{\"1\":{\"26\":1,\"34\":1,\"50\":1,\"58\":1,\"93\":1,\"105\":2,\"106\":1,\"108\":2,\"130\":2,\"138\":1,\"144\":1,\"150\":4,\"151\":2,\"167\":5,\"174\":1,\"214\":1,\"216\":1,\"217\":1,\"241\":9,\"244\":2,\"246\":2,\"255\":3,\"257\":3,\"259\":5,\"260\":2,\"273\":1,\"274\":1,\"280\":2,\"283\":1,\"285\":1,\"286\":1,\"287\":5,\"305\":10,\"306\":1,\"307\":4,\"309\":1,\"310\":3,\"311\":1,\"349\":1,\"357\":4,\"358\":8,\"360\":3,\"361\":2,\"377\":3}}],[\"lockfile\",{\"1\":{\"160\":2}}],[\"lowest\",{\"1\":{\"135\":1}}],[\"load用于检查cpu负载等\",{\"1\":{\"290\":1}}],[\"loading\",{\"1\":{\"150\":1,\"273\":2}}],[\"load1反映的是当前状态\",{\"1\":{\"286\":1}}],[\"load1反应的是当前系统的负载状态\",{\"1\":{\"227\":1}}],[\"load1该指标反映了当前主机在最近一分钟以内的负载情况\",{\"1\":{\"286\":1}}],[\"load1可以查询出prometheus采集到的主机负载的样本数据\",{\"1\":{\"282\":1}}],[\"load1表明了当前指标的名称\",{\"1\":{\"267\":1}}],[\"load1我们得到了两条时间序列\",{\"1\":{\"130\":1}}],[\"load1\",{\"1\":{\"116\":3,\"130\":2,\"144\":1,\"267\":3,\"268\":1,\"286\":4}}],[\"load\",{\"1\":{\"105\":9,\"116\":1,\"267\":1,\"273\":1,\"286\":1}}],[\"loaded\",{\"1\":{\"93\":7}}],[\"long\",{\"1\":{\"99\":1,\"112\":2,\"160\":1}}],[\"lookup\",{\"1\":{\"99\":4}}],[\"log\",{\"1\":{\"142\":3,\"150\":3}}],[\"login\",{\"1\":{\"102\":1,\"317\":1}}],[\"logback等监控数据收集的支持\",{\"1\":{\"87\":1}}],[\"log4j\",{\"1\":{\"87\":1}}],[\"lo\",{\"1\":{\"54\":1,\"273\":1,\"373\":1}}],[\"l\",{\"1\":{\"30\":1,\"166\":3}}],[\"li>\",{\"1\":{\"134\":2}}],[\"lisp\",{\"1\":{\"114\":1}}],[\"list<garbagecollectormxbean>\",{\"1\":{\"350\":2}}],[\"list<metricfamilysamples>\",{\"1\":{\"85\":4,\"96\":2,\"350\":2,\"351\":2}}],[\"list>\",{\"1\":{\"226\":1,\"250\":2,\"251\":8,\"366\":2,\"367\":8,\"368\":1}}],[\"listening\",{\"1\":{\"273\":1,\"285\":1}}],[\"listenandserve\",{\"1\":{\"166\":1}}],[\"listen\",{\"1\":{\"149\":5,\"150\":6,\"151\":3}}],[\"list\",{\"1\":{\"96\":1,\"135\":3,\"186\":2,\"193\":1,\"218\":2,\"219\":1,\"250\":2,\"314\":1,\"350\":1,\"366\":2}}],[\"like\",{\"1\":{\"109\":2,\"110\":2,\"111\":3,\"112\":2}}],[\"lib文件还是\",{\"1\":{\"134\":1}}],[\"lib文件中\",{\"1\":{\"134\":1}}],[\"lib并修改navbar组件\",{\"1\":{\"134\":1}}],[\"libraries目录中查找\",{\"1\":{\"134\":1}}],[\"libraries目录中已经内置了一些基本的界面组件\",{\"1\":{\"133\":1}}],[\"libraries中定义的head组件\",{\"1\":{\"134\":1}}],[\"libraries和consoles目录\",{\"1\":{\"133\":1}}],[\"libraries和\",{\"1\":{\"133\":1}}],[\"library用户可以创建自定义的exporter程序\",{\"1\":{\"348\":1}}],[\"library用户可以完全根据自己的需求实现自定义exporter\",{\"1\":{\"347\":1}}],[\"library创建自定义exporter\",{\"1\":{\"347\":1}}],[\"library创建自己的exporter程序\",{\"1\":{\"114\":1}}],[\"library如\",{\"1\":{\"347\":1}}],[\"library来让你的应用程序支持监控数据采集\",{\"1\":{\"300\":1}}],[\"library的输出格式不止支持prometheus的格式化数据\",{\"1\":{\"300\":1}}],[\"library编写该监控目标的监控采集程序\",{\"1\":{\"277\":1}}],[\"library\",{\"1\":{\"115\":1,\"347\":1,\"348\":1}}],[\"library库\",{\"1\":{\"84\":1}}],[\"library根据自身需求创建自定义的exporter\",{\"1\":{\"1\":1}}],[\"lib\",{\"1\":{\"105\":2}}],[\"limit\",{\"1\":{\"104\":1,\"105\":2}}],[\"linux\",{\"1\":{\"105\":1,\"187\":1,\"189\":1,\"373\":5}}],[\"linear函数可以预测时间序列v在t秒后的值\",{\"1\":{\"239\":1}}],[\"linear\",{\"1\":{\"229\":2,\"239\":2}}],[\"liner\",{\"1\":{\"142\":1}}],[\"lines配置\",{\"1\":{\"144\":1}}],[\"lines\",{\"1\":{\"138\":1}}],[\"line\",{\"1\":{\"48\":2,\"135\":2}}],[\"link\",{\"1\":{\"30\":1,\"49\":2}}],[\"lang\",{\"1\":{\"350\":3}}],[\"language\",{\"1\":{\"5\":1}}],[\"lan\",{\"1\":{\"305\":3}}],[\"latest\",{\"1\":{\"103\":1,\"105\":2,\"318\":1}}],[\"latencies\",{\"1\":{\"67\":1,\"193\":2}}],[\"latency\",{\"1\":{\"66\":2,\"67\":3,\"90\":8,\"95\":26,\"193\":4,\"199\":4,\"352\":4}}],[\"lambda\",{\"1\":{\"90\":1}}],[\"labelkeep\",{\"1\":{\"311\":1}}],[\"labelkeep正好相反\",{\"1\":{\"310\":1}}],[\"label进行重写\",{\"1\":{\"310\":1}}],[\"label当中\",{\"1\":{\"310\":1}}],[\"label=value\",{\"1\":{\"266\":1}}],[\"label中\",{\"1\":{\"241\":1}}],[\"label标签中\",{\"1\":{\"241\":1}}],[\"label的值会按照separator进行拼接\",{\"1\":{\"310\":1}}],[\"label的值\",{\"1\":{\"241\":2}}],[\"labeldrop对标签进行管理\",{\"1\":{\"311\":1}}],[\"labeldrop\",{\"1\":{\"218\":1,\"310\":1}}],[\"labelmap会根据regex的定义去匹配target实例所有标签的名称\",{\"1\":{\"310\":1}}],[\"labelmap重写标签\",{\"0\":{\"310\":1}}],[\"labelmap\",{\"1\":{\"190\":2,\"196\":1,\"197\":1,\"199\":3,\"200\":2,\"201\":1,\"203\":3,\"207\":1,\"310\":1,\"311\":1}}],[\"labelmatcher\",{\"1\":{\"166\":1}}],[\"label>\",{\"1\":{\"169\":1}}],[\"label属性用于指定界面中变量的显示名称\",{\"1\":{\"129\":1}}],[\"labeled\",{\"1\":{\"105\":1}}],[\"labeledgauge\",{\"1\":{\"85\":4,\"96\":3,\"351\":4}}],[\"labelvalue\",{\"1\":{\"96\":1,\"166\":1,\"269\":2}}],[\"labelnames\",{\"1\":{\"89\":1,\"95\":4}}],[\"labelname=\",{\"1\":{\"86\":2}}],[\"labelname\",{\"1\":{\"85\":1,\"96\":1,\"166\":1,\"269\":2,\"351\":1}}],[\"label\",{\"1\":{\"67\":1,\"100\":3,\"105\":5,\"116\":4,\"130\":6,\"131\":1,\"135\":2,\"156\":1,\"187\":3,\"189\":4,\"190\":6,\"192\":1,\"196\":6,\"197\":6,\"199\":5,\"200\":5,\"201\":5,\"202\":1,\"203\":18,\"207\":13,\"218\":8,\"241\":10,\"250\":2,\"262\":1,\"269\":1,\"273\":1,\"310\":7,\"312\":2,\"366\":2}}],[\"labels值的hash值\",{\"1\":{\"312\":1}}],[\"labels的hash值\",{\"0\":{\"312\":1}}],[\"labels的值匹配到regex正则表达式内容的target实例\",{\"1\":{\"311\":1}}],[\"labels的值中没有匹配到regex正则表达式内容的target实例\",{\"1\":{\"311\":1}}],[\"labels标签的值\",{\"1\":{\"310\":1}}],[\"labelset\",{\"1\":{\"258\":1,\"268\":1,\"269\":2}}],[\"labels配置true可以确保当采集到的监控指标冲突时\",{\"1\":{\"169\":1}}],[\"labels>\",{\"1\":{\"68\":1}}],[\"labels\",{\"1\":{\"27\":1,\"28\":2,\"51\":20,\"66\":2,\"67\":1,\"69\":2,\"72\":2,\"85\":2,\"89\":2,\"95\":6,\"100\":2,\"135\":1,\"150\":5,\"151\":3,\"156\":4,\"166\":2,\"169\":1,\"175\":3,\"181\":2,\"186\":1,\"190\":2,\"192\":1,\"195\":3,\"196\":5,\"197\":5,\"199\":1,\"200\":2,\"201\":6,\"202\":1,\"203\":18,\"205\":2,\"206\":1,\"207\":9,\"213\":1,\"214\":2,\"217\":4,\"218\":9,\"294\":1,\"307\":3,\"310\":4,\"311\":1,\"312\":3,\"351\":2}}],[\"last\",{\"1\":{\"23\":1,\"45\":1,\"105\":1}}],[\"layer\",{\"1\":{\"14\":1}}],[\"全局配置\",{\"1\":{\"26\":1}}],[\"全书组织\",{\"0\":{\"5\":1},\"1\":{\"7\":1,\"19\":1}}],[\"全栈工程师\",{\"1\":{\"0\":1}}],[\"称为\",{\"1\":{\"4\":1}}],[\"反之则丢弃\",{\"1\":{\"363\":1}}],[\"反之使用instance\",{\"1\":{\"259\":1}}],[\"反之使用label\",{\"1\":{\"259\":2}}],[\"反之丢弃\",{\"1\":{\"245\":1}}],[\"反之对于客户端而言histogram消耗的资源更少\",{\"1\":{\"230\":1}}],[\"反之\",{\"1\":{\"126\":1,\"253\":1,\"287\":1}}],[\"反之成功\",{\"1\":{\"103\":1,\"318\":1}}],[\"反应\",{\"1\":{\"4\":1}}],[\"反映了当前样本的特征维度\",{\"1\":{\"269\":1}}],[\"反映\",{\"1\":{\"4\":1}}],[\"错误计数\",{\"1\":{\"236\":1}}],[\"错误以及饱和度\",{\"1\":{\"234\":1}}],[\"错误信息\",{\"1\":{\"144\":1}}],[\"错误\",{\"1\":{\"4\":1,\"110\":1,\"232\":1,\"234\":1,\"235\":1,\"236\":1}}],[\"源\",{\"1\":{\"4\":1}}],[\"mhandler\",{\"1\":{\"350\":3}}],[\"mkdir\",{\"1\":{\"273\":1,\"305\":1}}],[\"m\",{\"1\":{\"166\":3,\"260\":1}}],[\"mteircs设置\",{\"1\":{\"141\":1}}],[\"msec\",{\"1\":{\"305\":1}}],[\"ms\",{\"1\":{\"166\":2,\"378\":1}}],[\"msg\",{\"1\":{\"305\":1}}],[\"msg=listening\",{\"1\":{\"150\":2}}],[\"msg=\",{\"1\":{\"150\":5,\"151\":3,\"273\":6}}],[\"msgtype\",{\"1\":{\"30\":2,\"31\":3}}],[\"mssql\",{\"1\":{\"114\":1}}],[\"milliseconds\",{\"1\":{\"350\":1}}],[\"microseconds可以获得当前节点中pod启动时间相关的统计数据\",{\"1\":{\"199\":1}}],[\"microseconds\",{\"1\":{\"193\":3,\"199\":3}}],[\"microseconds获取\",{\"1\":{\"193\":1}}],[\"mixed用于需要从多个数据源中查询和渲染数据的场景\",{\"1\":{\"126\":1}}],[\"mixed和grafana\",{\"1\":{\"126\":1}}],[\"misc\",{\"1\":{\"111\":1}}],[\"minute\",{\"1\":{\"273\":2}}],[\"minutes\",{\"1\":{\"67\":2}}],[\"minikube会自动配置本机的kubelet命令行工具\",{\"1\":{\"181\":1}}],[\"minikube会在本地通过虚拟机运行一个单节点的kubernetes集群\",{\"1\":{\"181\":1}}],[\"minikube\",{\"1\":{\"181\":5,\"187\":5,\"188\":1,\"189\":5,\"190\":1,\"201\":1,\"205\":1,\"206\":1,\"207\":1,\"396\":1}}],[\"minimum\",{\"1\":{\"135\":1,\"160\":1}}],[\"min\",{\"1\":{\"135\":1,\"160\":1,\"226\":1,\"368\":1}}],[\"mindset\",{\"1\":{\"16\":1}}],[\"m个采集任务\",{\"1\":{\"100\":1}}],[\"mfs\",{\"1\":{\"85\":7,\"96\":3,\"350\":3,\"351\":4}}],[\"muini\",{\"1\":{\"298\":1}}],[\"mutable\",{\"1\":{\"159\":1}}],[\"multiple\",{\"1\":{\"144\":1}}],[\"must\",{\"1\":{\"72\":2,\"166\":1}}],[\"much\",{\"1\":{\"16\":1}}],[\"mountvolume\",{\"1\":{\"214\":1}}],[\"mountpath\",{\"1\":{\"175\":1}}],[\"mobile\",{\"1\":{\"134\":1}}],[\"moby\",{\"1\":{\"105\":1}}],[\"mon\",{\"1\":{\"396\":1}}],[\"monitor\",{\"1\":{\"217\":2}}],[\"monitoring平台中\",{\"1\":{\"49\":1}}],[\"monitoring\",{\"1\":{\"47\":1,\"48\":3,\"49\":1,\"210\":6,\"213\":4,\"214\":12,\"216\":6,\"217\":5,\"218\":6,\"219\":7,\"223\":3,\"397\":2}}],[\"mongodb\",{\"1\":{\"114\":1}}],[\"modifyindex\",{\"1\":{\"305\":2}}],[\"modulus\",{\"1\":{\"156\":1,\"310\":2,\"312\":2}}],[\"module\",{\"1\":{\"100\":4,\"196\":1,\"197\":1,\"203\":2}}],[\"module=http\",{\"1\":{\"99\":1}}],[\"modules\",{\"1\":{\"99\":1,\"101\":1,\"195\":1,\"316\":1}}],[\"modes用于控制图形展示形式\",{\"1\":{\"138\":1}}],[\"mode=\",{\"1\":{\"116\":1,\"127\":1,\"128\":1,\"138\":1,\"227\":1,\"248\":1,\"267\":1,\"268\":2,\"282\":1,\"286\":1,\"309\":1,\"310\":3,\"369\":1}}],[\"mode\",{\"1\":{\"69\":1,\"116\":1,\"126\":2,\"138\":1,\"151\":1,\"227\":1,\"262\":2,\"267\":1,\"286\":1,\"378\":2}}],[\"model\",{\"1\":{\"28\":4,\"31\":7,\"32\":2,\"166\":4}}],[\"more\",{\"1\":{\"67\":1}}],[\"mesos\",{\"1\":{\"298\":1}}],[\"messages\",{\"1\":{\"269\":2}}],[\"message\",{\"1\":{\"28\":2,\"31\":1,\"33\":1,\"51\":7,\"166\":5}}],[\"measurements\",{\"1\":{\"167\":2}}],[\"mean5m\",{\"1\":{\"66\":1}}],[\"merge\",{\"1\":{\"159\":1}}],[\"menu\",{\"1\":{\"134\":1}}],[\"metadata\",{\"1\":{\"174\":1,\"175\":3,\"181\":3,\"186\":4,\"187\":1,\"190\":1,\"195\":3,\"201\":2,\"203\":3,\"205\":3,\"206\":2,\"207\":2,\"210\":1,\"213\":2,\"214\":2,\"216\":1,\"217\":6,\"218\":1,\"219\":4}}],[\"meta\",{\"1\":{\"159\":4,\"187\":9,\"189\":13,\"190\":4,\"192\":3,\"196\":4,\"197\":6,\"199\":4,\"200\":4,\"201\":6,\"202\":3,\"203\":14,\"207\":35,\"214\":2,\"218\":10,\"305\":1,\"310\":13,\"311\":1}}],[\"method=\",{\"1\":{\"95\":21,\"217\":1,\"246\":2,\"250\":10,\"251\":4,\"259\":2,\"260\":2,\"266\":1,\"268\":6,\"269\":2,\"325\":3,\"357\":4,\"360\":3,\"361\":2,\"366\":10,\"367\":4}}],[\"method\",{\"1\":{\"89\":1,\"95\":11,\"99\":2,\"102\":3,\"103\":2,\"195\":1,\"226\":1,\"236\":1,\"250\":10,\"251\":2,\"259\":1,\"317\":3,\"318\":2,\"366\":10,\"367\":2,\"368\":1}}],[\"metric类型\",{\"0\":{\"227\":1},\"1\":{\"139\":1}}],[\"metricfamilysamples指定了当前监控指标的名称\",{\"1\":{\"85\":1}}],[\"metricfamilysamples\",{\"1\":{\"85\":6}}],[\"metricname\",{\"1\":{\"85\":4}}],[\"metric\",{\"0\":{\"269\":1},\"1\":{\"23\":2,\"72\":2,\"105\":1,\"109\":1,\"111\":2,\"112\":1,\"116\":1,\"130\":2,\"166\":1,\"227\":2,\"255\":2,\"256\":2,\"257\":2,\"268\":3,\"269\":4,\"294\":1}}],[\"metrics地址\",{\"1\":{\"230\":1}}],[\"metrics地址时会返回以下内容\",{\"1\":{\"116\":1}}],[\"metrics实例应用程序会返回以下样本数据\",{\"1\":{\"217\":1}}],[\"metrics暴露监控样本数据\",{\"1\":{\"207\":1}}],[\"metrics作为监控采集路径\",{\"1\":{\"201\":1}}],[\"metrics作为采集目标地址\",{\"1\":{\"190\":1}}],[\"metrics即可获取apiserver组件中记录的所有监控样数据\",{\"1\":{\"192\":1}}],[\"metrics即可获取到标准的prometheus监控样本输出\",{\"1\":{\"105\":1}}],[\"metrics设置\",{\"1\":{\"139\":1,\"142\":1}}],[\"metrics选项\",{\"1\":{\"138\":1}}],[\"metrics返回的监控样本中\",{\"1\":{\"109\":1}}],[\"metrics查看mysql\",{\"1\":{\"108\":1}}],[\"metrics时\",{\"1\":{\"96\":1}}],[\"metrics可以看到以下输出内容\",{\"1\":{\"93\":1}}],[\"metrics\",{\"1\":{\"15\":2,\"85\":1,\"86\":2,\"87\":1,\"93\":2,\"96\":2,\"100\":3,\"126\":1,\"130\":1,\"141\":1,\"156\":1,\"160\":1,\"169\":1,\"186\":1,\"187\":2,\"188\":1,\"189\":2,\"190\":5,\"196\":1,\"197\":1,\"199\":5,\"200\":7,\"201\":4,\"203\":2,\"205\":1,\"207\":4,\"218\":2,\"219\":1,\"258\":1,\"268\":1,\"273\":2,\"283\":1,\"285\":1,\"286\":1,\"294\":1,\"306\":2,\"309\":1,\"349\":1,\"350\":1,\"375\":2}}],[\"metrics类型\",{\"1\":{\"8\":1,\"20\":1}}],[\"metrics类型小节\",{\"1\":{\"3\":1}}],[\"members\",{\"1\":{\"305\":1}}],[\"members可以查看当前集群中的所有节点\",{\"1\":{\"305\":1}}],[\"memcached\",{\"1\":{\"298\":1}}],[\"memeory\",{\"1\":{\"286\":1}}],[\"memstats\",{\"1\":{\"167\":8}}],[\"memfree\",{\"1\":{\"95\":1,\"229\":2,\"378\":1}}],[\"mem\",{\"1\":{\"69\":2,\"104\":2,\"151\":2}}],[\"memavailable\",{\"1\":{\"69\":1,\"95\":1,\"151\":1,\"229\":1}}],[\"memtotal\",{\"1\":{\"69\":2,\"151\":2,\"378\":1}}],[\"memorypoolsexports\",{\"1\":{\"350\":1}}],[\"memory\",{\"1\":{\"69\":3,\"95\":2,\"105\":4,\"106\":1,\"151\":3,\"188\":4,\"201\":4,\"205\":4,\"210\":1,\"213\":1,\"214\":1,\"216\":1,\"218\":1,\"219\":1,\"229\":3,\"244\":3,\"245\":6,\"349\":1,\"378\":4}}],[\"median\",{\"1\":{\"67\":2}}],[\"mandatory\",{\"1\":{\"310\":1}}],[\"manage\",{\"0\":{\"394\":1}}],[\"managementfactory\",{\"1\":{\"350\":2}}],[\"management\",{\"1\":{\"350\":2}}],[\"management中获取到gc回收相关的运行数据\",{\"1\":{\"350\":1}}],[\"managed\",{\"1\":{\"187\":1,\"189\":1}}],[\"manager负责监听这些事件并触发相应的任务来满足用户的期望\",{\"1\":{\"221\":1}}],[\"manager\",{\"1\":{\"179\":1,\"183\":1}}],[\"many\",{\"1\":{\"110\":1,\"249\":2,\"365\":2}}],[\"make\",{\"1\":{\"166\":1}}],[\"matrix\",{\"1\":{\"256\":2,\"257\":2}}],[\"mattn\",{\"1\":{\"149\":1,\"400\":1}}],[\"matching\",{\"1\":{\"310\":1}}],[\"matchnames\",{\"1\":{\"217\":2}}],[\"matchlabels\",{\"1\":{\"181\":1,\"195\":1,\"203\":1,\"213\":2,\"214\":2,\"217\":3,\"218\":1,\"219\":1}}],[\"matched\",{\"1\":{\"310\":2}}],[\"matches\",{\"1\":{\"103\":4,\"310\":1,\"314\":6,\"318\":4}}],[\"matchers\",{\"1\":{\"164\":1,\"165\":1,\"166\":1}}],[\"matcher\",{\"1\":{\"45\":1}}],[\"match或者定义的匹配规则\",{\"1\":{\"36\":1}}],[\"match和target\",{\"1\":{\"36\":1}}],[\"match\",{\"1\":{\"36\":7,\"40\":2,\"42\":2,\"51\":1,\"55\":2,\"156\":1,\"169\":5}}],[\"machine\",{\"1\":{\"105\":1}}],[\"mac机器上\",{\"1\":{\"104\":1}}],[\"maximum\",{\"1\":{\"135\":1,\"160\":1}}],[\"max\",{\"1\":{\"105\":1,\"110\":10,\"135\":1,\"160\":1,\"226\":1,\"368\":1}}],[\"mail\",{\"1\":{\"50\":1}}],[\"maint\",{\"1\":{\"105\":1}}],[\"maintainers\",{\"1\":{\"105\":1}}],[\"maintainer=\",{\"1\":{\"105\":5}}],[\"main\",{\"1\":{\"28\":2,\"33\":3,\"86\":1,\"93\":1,\"166\":2,\"349\":1}}],[\"may\",{\"1\":{\"45\":1,\"253\":1}}],[\"mar\",{\"1\":{\"117\":1}}],[\"marksweep\",{\"1\":{\"93\":2,\"349\":2}}],[\"markdow\",{\"1\":{\"31\":1}}],[\"markdown\",{\"1\":{\"30\":4,\"31\":9,\"32\":2}}],[\"markdown三种消息类型\",{\"1\":{\"30\":1}}],[\"marshal\",{\"1\":{\"32\":1}}],[\"mappings配置\",{\"1\":{\"144\":1}}],[\"mappings定义值的映射关系\",{\"1\":{\"144\":1}}],[\"mapped\",{\"1\":{\"87\":1,\"349\":1}}],[\"map\",{\"1\":{\"28\":5,\"135\":1,\"269\":1}}],[\"master组件和node\\b组件\",{\"1\":{\"183\":1}}],[\"master组件和node组件\",{\"1\":{\"179\":1}}],[\"master组件主要包括\",{\"1\":{\"179\":1,\"183\":1}}],[\"master\",{\"1\":{\"16\":1,\"45\":1,\"75\":2}}],[\"mysecret\",{\"1\":{\"102\":1,\"317\":1}}],[\"mysql还提供了一个slow\",{\"1\":{\"112\":1}}],[\"mysql只能从磁盘中读取数据\",{\"1\":{\"111\":1}}],[\"mysql默认的存储引擎innodb使用了一片称为缓冲池的内存区域\",{\"1\":{\"111\":1}}],[\"mysql默认的最大链接数为151\",{\"1\":{\"110\":1}}],[\"mysql>\",{\"1\":{\"108\":1,\"109\":2,\"110\":2,\"111\":3,\"112\":2}}],[\"mysqlexporter\",{\"1\":{\"108\":1}}],[\"mysql是最流行的关系型数据库管理系统之一\",{\"1\":{\"107\":1}}],[\"mysql是一个关系型数据库管理系统\",{\"1\":{\"107\":1}}],[\"mysql|cassandra\",{\"1\":{\"42\":1}}],[\"mysqld\",{\"0\":{\"107\":1},\"1\":{\"9\":1,\"21\":1,\"108\":3,\"109\":1,\"111\":2,\"112\":1,\"307\":1}}],[\"mysql\",{\"1\":{\"4\":1,\"108\":10,\"109\":15,\"110\":9,\"111\":16,\"112\":4,\"114\":1,\"206\":2,\"277\":1,\"280\":1,\"298\":1}}],[\"myjob\",{\"1\":{\"66\":1}}],[\"myorg\",{\"1\":{\"45\":5}}],[\"my\",{\"1\":{\"16\":1,\"85\":3,\"86\":11,\"91\":1,\"102\":1,\"273\":1,\"317\":1,\"351\":2}}],[\"md\",{\"1\":{\"16\":1,\"75\":2,\"378\":1}}],[\"术语的写法要规范\",{\"1\":{\"4\":1}}],[\"术语在第一次出现的时候\",{\"1\":{\"4\":1}}],[\"的\\b右边向量元素进行运算\",{\"1\":{\"365\":1}}],[\"的\\b右边向量元素进行相应的操作\",{\"1\":{\"245\":1}}],[\"的所有时间序列\",{\"1\":{\"360\":1}}],[\"的监控数据收集\",{\"1\":{\"351\":1}}],[\"的监控系统模型\",{\"1\":{\"290\":1}}],[\"的基本用法\",{\"1\":{\"348\":1}}],[\"的基础设施环境中用户可以像使用水\",{\"1\":{\"313\":1}}],[\"的关键字维度组成\",{\"1\":{\"325\":1}}],[\"的人员可能只关心其中一部分的监控数据\",{\"1\":{\"311\":1}}],[\"的能力动态管理监控目标\",{\"1\":{\"292\":1}}],[\"的面板\",{\"1\":{\"283\":1}}],[\"的角色\",{\"1\":{\"251\":1,\"367\":1}}],[\"的样本值\",{\"1\":{\"250\":1,\"366\":1}}],[\"的主机呢\",{\"1\":{\"245\":1}}],[\"的右边向量元素进行运算\",{\"1\":{\"244\":1,\"249\":1}}],[\"的情况\",{\"1\":{\"238\":1}}],[\"的情况下其样本值应该是不断增大的\",{\"1\":{\"238\":1}}],[\"的使用率通常是系统性能瓶颈的标志\",{\"1\":{\"236\":1}}],[\"的原则下\",{\"1\":{\"235\":1}}],[\"的原则下结合prometheus以及kubernetes容器实践\",{\"1\":{\"235\":1}}],[\"的耗时为0\",{\"1\":{\"230\":2}}],[\"的命名规则去查找secret配置并以文件挂载的方式\",{\"1\":{\"214\":1}}],[\"的pod启动时间\",{\"1\":{\"193\":1,\"199\":1}}],[\"的pod启动时间大致在18\",{\"1\":{\"193\":1}}],[\"的值以4作为系数\",{\"1\":{\"312\":1}}],[\"的值\",{\"1\":{\"190\":1}}],[\"的访问地址\",{\"1\":{\"189\":1}}],[\"的交互\",{\"1\":{\"185\":1}}],[\"的url地址\",{\"1\":{\"163\":1}}],[\"的方式定义监控目标\",{\"1\":{\"280\":1}}],[\"的方式保存在内存数据库中\",{\"1\":{\"268\":1}}],[\"的方式\",{\"1\":{\"160\":1}}],[\"的方式对查询结果进行处理\",{\"1\":{\"130\":1}}],[\"的区域显示为warning状态\",{\"1\":{\"138\":1}}],[\"的时间序列\",{\"1\":{\"138\":1}}],[\"的可视化图表如下所示\",{\"1\":{\"135\":1}}],[\"的形式保存在内置的时间序列数据库当中\",{\"1\":{\"294\":1}}],[\"的形式以外\",{\"1\":{\"266\":1}}],[\"的形式\",{\"1\":{\"128\":1,\"130\":1,\"169\":1}}],[\"的请求次数为0\",{\"1\":{\"95\":5}}],[\"的告警信息\",{\"1\":{\"60\":1}}],[\"的\",{\"1\":{\"4\":1}}],[\"和一组标签集\",{\"1\":{\"268\":1}}],[\"和字符串\",{\"1\":{\"263\":1}}],[\"和区间映射\",{\"1\":{\"144\":1}}],[\"和样本大小\",{\"1\":{\"160\":1}}],[\"和样本\",{\"1\":{\"116\":1}}],[\"和dec\",{\"1\":{\"89\":1}}],[\"和桌面平台\",{\"1\":{\"46\":1}}],[\"和自动化运维工具\",{\"1\":{\"43\":1}}],[\"和\",{\"1\":{\"4\":1,\"95\":1,\"352\":1}}],[\"地\",{\"1\":{\"4\":1}}],[\"是系统保留的关键字\",{\"1\":{\"269\":1}}],[\"是alertmanager的配置文件\",{\"1\":{\"214\":1}}],[\"是通过kubernetes自动发现的endpoint对象的所有metadata标签\",{\"1\":{\"207\":1}}],[\"是影响其使用体验的关键因素\",{\"1\":{\"180\":1,\"184\":1}}],[\"是kubernetes的架构示意图\",{\"1\":{\"179\":1,\"183\":1}}],[\"是指应用可以根据当前的资源使用情况自动水平扩容或者缩容的能力\",{\"1\":{\"176\":1}}],[\"是使用singlestat进行数据可视化的显示效果\",{\"1\":{\"143\":1}}],[\"是prometheus\",{\"1\":{\"221\":1}}],[\"是prometheus获取到的node节点的标签信息\",{\"1\":{\"187\":1}}],[\"是prometheus返回的样本数据\",{\"1\":{\"139\":1}}],[\"是prometheus基础的综述\",{\"1\":{\"5\":1}}],[\"是则表示验证成功\",{\"1\":{\"101\":1,\"316\":1}}],[\"是否区分了\",{\"1\":{\"4\":1}}],[\"是否有明显的错别字\",{\"1\":{\"4\":1}}],[\"是继kubernetes之后的第一个cncf基金会顶级项目\",{\"1\":{\"1\":1}}],[\"凡事章节号应该使用阿拉伯数字\",{\"1\":{\"4\":1}}],[\"科技类图示\",{\"1\":{\"4\":1}}],[\"语言表达是否太过口语化\",{\"1\":{\"4\":1}}],[\"句号\",{\"1\":{\"4\":1}}],[\"顿号\",{\"1\":{\"4\":1}}],[\"逗号\",{\"1\":{\"4\":1}}],[\"初始node\",{\"0\":{\"286\":1}}],[\"初始化时关联的其它实例的集群服务地址\",{\"1\":{\"149\":1}}],[\"初始prometheus\",{\"1\":{\"125\":1,\"204\":1}}],[\"初始prometheus小节\",{\"1\":{\"3\":1}}],[\"初识client\",{\"0\":{\"349\":1}}],[\"初识promql\",{\"0\":{\"258\":1},\"1\":{\"8\":1,\"20\":1}}],[\"初识prometheus\",{\"0\":{\"281\":1},\"1\":{\"8\":1,\"20\":1,\"120\":1}}],[\"初识kubernetes\",{\"0\":{\"177\":1},\"1\":{\"3\":1,\"10\":1,\"22\":1}}],[\"版本更新历史\",{\"0\":{\"3\":1}}],[\"s3\",{\"1\":{\"397\":1}}],[\"skip\",{\"1\":{\"195\":1,\"199\":2,\"200\":1}}],[\"ssh\",{\"1\":{\"181\":1,\"188\":1,\"195\":1}}],[\"ssl刚好相反\",{\"1\":{\"103\":1,\"318\":1}}],[\"ssl为true时\",{\"1\":{\"103\":1,\"318\":1}}],[\"ssl进行配置\",{\"1\":{\"103\":1,\"318\":1}}],[\"ssl和fail\",{\"1\":{\"103\":1,\"318\":1}}],[\"ssl\",{\"1\":{\"99\":4,\"103\":7,\"318\":7}}],[\"svc访问到部署外部的kube\",{\"1\":{\"202\":1}}],[\"svc\",{\"1\":{\"175\":1,\"181\":1,\"190\":2,\"192\":4,\"195\":1,\"196\":1,\"197\":1,\"199\":2,\"200\":1,\"202\":3,\"203\":5,\"206\":1}}],[\"snappy\",{\"1\":{\"166\":2}}],[\"snmp\",{\"1\":{\"114\":1,\"232\":1,\"298\":1}}],[\"synchronized\",{\"1\":{\"350\":1}}],[\"sync\",{\"1\":{\"305\":1}}],[\"syntax\",{\"1\":{\"166\":1}}],[\"sys\",{\"1\":{\"105\":2,\"167\":2}}],[\"systemd\",{\"1\":{\"374\":1}}],[\"systems\",{\"1\":{\"319\":1}}],[\"system\",{\"1\":{\"48\":1,\"105\":2,\"181\":1,\"218\":1,\"268\":1,\"374\":1}}],[\"sdb\",{\"1\":{\"244\":1,\"358\":4}}],[\"sdb2\",{\"1\":{\"150\":2}}],[\"sda\",{\"1\":{\"244\":1,\"358\":4}}],[\"sda1\",{\"1\":{\"150\":4}}],[\"sd定义整个服务发现过程\",{\"1\":{\"217\":1}}],[\"sd\",{\"1\":{\"187\":7,\"189\":1,\"190\":2,\"192\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":3,\"200\":2,\"201\":1,\"202\":1,\"203\":4,\"207\":4,\"214\":1,\"218\":1,\"306\":2,\"307\":5,\"310\":3,\"311\":1,\"312\":1}}],[\"sre\",{\"1\":{\"289\":1}}],[\"src\",{\"1\":{\"241\":3}}],[\"sr\",{\"1\":{\"134\":1}}],[\"sans\",{\"1\":{\"199\":1}}],[\"same\",{\"1\":{\"166\":1}}],[\"sample和metricfamilysamples的方式适用于当某监控指标的样本之间的标签可能不一致的情况\",{\"1\":{\"85\":1}}],[\"sample实例\",{\"1\":{\"85\":1}}],[\"sample2\",{\"1\":{\"85\":2}}],[\"sample\",{\"0\":{\"398\":1},\"1\":{\"85\":6,\"160\":2,\"268\":1}}],[\"samples\",{\"1\":{\"23\":1,\"85\":2,\"160\":3,\"166\":2,\"349\":1}}],[\"saturation\",{\"1\":{\"236\":2}}],[\"sat\",{\"1\":{\"117\":1}}],[\"sharding\",{\"1\":{\"297\":1}}],[\"shaw\",{\"1\":{\"105\":1}}],[\"shell\",{\"1\":{\"167\":1}}],[\"sh\",{\"1\":{\"167\":1}}],[\"sh后\",{\"1\":{\"150\":1}}],[\"sh脚本对集群进行简单测试\",{\"1\":{\"150\":1}}],[\"shouldusecompression\",{\"1\":{\"350\":1}}],[\"should\",{\"1\":{\"135\":1,\"310\":1}}],[\"show\",{\"1\":{\"109\":3,\"110\":2,\"111\":5,\"112\":3,\"167\":1}}],[\"scollector\",{\"1\":{\"298\":1}}],[\"scheduler负责完成调度工作\",{\"1\":{\"180\":1,\"184\":1}}],[\"scheduler\",{\"1\":{\"179\":1,\"183\":1}}],[\"schedule\",{\"1\":{\"178\":1}}],[\"scheme\",{\"1\":{\"135\":2,\"187\":1,\"189\":1,\"190\":4,\"192\":1,\"197\":1,\"199\":3,\"200\":2,\"202\":1,\"203\":1,\"207\":4,\"214\":1,\"218\":1,\"273\":1,\"306\":1,\"309\":2}}],[\"script>\",{\"1\":{\"135\":1}}],[\"scraped\",{\"1\":{\"273\":1}}],[\"scrape并且其值为true的endpoint作为监控目标\",{\"1\":{\"207\":1}}],[\"scrape=\",{\"1\":{\"207\":1}}],[\"scrape=true\",{\"1\":{\"206\":1}}],[\"scrape\",{\"1\":{\"100\":1,\"151\":3,\"156\":2,\"169\":2,\"174\":2,\"187\":2,\"190\":2,\"201\":4,\"205\":4,\"206\":1,\"207\":6,\"210\":2,\"218\":5,\"273\":6,\"280\":1,\"287\":1,\"307\":3,\"310\":1,\"311\":1,\"312\":2,\"377\":5}}],[\"scaled\",{\"1\":{\"181\":1}}],[\"scale\",{\"1\":{\"181\":1}}],[\"scaleio\",{\"1\":{\"114\":1}}],[\"scalar\",{\"0\":{\"264\":1},\"1\":{\"239\":1,\"256\":2,\"263\":1}}],[\"scala\",{\"1\":{\"114\":1}}],[\"scaling\",{\"1\":{\"1\":1}}],[\"scavenge\",{\"1\":{\"93\":2,\"349\":2}}],[\"space\",{\"1\":{\"160\":1}}],[\"span>\",{\"1\":{\"134\":4}}],[\"spec中则定义了该deployment的具体设置\",{\"1\":{\"181\":1}}],[\"spec\",{\"1\":{\"105\":1,\"175\":3,\"181\":3,\"186\":2,\"195\":3,\"201\":2,\"203\":3,\"205\":3,\"206\":1,\"210\":1,\"213\":2,\"214\":2,\"216\":1,\"217\":6,\"218\":1,\"219\":1}}],[\"specifies\",{\"1\":{\"99\":1,\"103\":1,\"318\":1}}],[\"spent\",{\"1\":{\"93\":1,\"116\":1,\"227\":1,\"267\":1,\"286\":1,\"349\":1,\"350\":1}}],[\"springframework\",{\"1\":{\"96\":1}}],[\"springmetrics\",{\"1\":{\"93\":1}}],[\"springapplication\",{\"1\":{\"93\":2,\"94\":1,\"96\":1}}],[\"springbootapplication\",{\"1\":{\"93\":1,\"94\":1,\"96\":1}}],[\"spring\",{\"1\":{\"86\":1,\"93\":1,\"350\":2}}],[\"sprintf\",{\"1\":{\"31\":5}}],[\"signals是google针对大量分布式监控的经验总结\",{\"1\":{\"234\":1}}],[\"signalfx\",{\"1\":{\"167\":1}}],[\"siglesta支持值映射\",{\"1\":{\"144\":1}}],[\"singlestat\",{\"1\":{\"123\":1,\"126\":1,\"143\":2,\"144\":3}}],[\"singlestat面板中除了会显示当前的最新样本值以外\",{\"1\":{\"144\":1}}],[\"singlestat面板\",{\"0\":{\"143\":1},\"1\":{\"9\":1,\"21\":1}}],[\"singletonlist\",{\"1\":{\"96\":2,\"350\":2}}],[\"since\",{\"1\":{\"93\":1,\"188\":1}}],[\"size\",{\"1\":{\"90\":3,\"135\":1,\"188\":1,\"201\":1,\"205\":1,\"305\":1,\"319\":2,\"350\":2,\"352\":6}}],[\"simpleclient\",{\"1\":{\"85\":1,\"86\":1,\"87\":1,\"91\":1,\"93\":3,\"349\":7}}],[\"silence设置同步\",{\"1\":{\"148\":1}}],[\"silences菜单下则可以通过ui创建静默规则\",{\"1\":{\"57\":1}}],[\"silence\",{\"1\":{\"37\":1,\"39\":1}}],[\"sudo\",{\"1\":{\"305\":2,\"372\":1,\"373\":2,\"374\":1,\"377\":1}}],[\"sun\",{\"1\":{\"305\":1}}],[\"subsets\",{\"1\":{\"206\":1}}],[\"substituted\",{\"1\":{\"135\":1}}],[\"subjects\",{\"1\":{\"186\":1,\"219\":1}}],[\"supported\",{\"1\":{\"135\":1}}],[\"super\",{\"1\":{\"94\":2,\"95\":3}}],[\"success值为1\",{\"1\":{\"103\":1,\"318\":1}}],[\"success\",{\"1\":{\"99\":4,\"253\":1,\"255\":1,\"257\":1}}],[\"successful\",{\"1\":{\"28\":1,\"33\":1}}],[\"sum近似计算的结果\",{\"1\":{\"240\":1}}],[\"sum作为后缀\",{\"1\":{\"230\":1}}],[\"sum指标表示\",{\"1\":{\"116\":1}}],[\"summed\",{\"1\":{\"99\":1}}],[\"summary与histogram非常类似\",{\"1\":{\"352\":1}}],[\"summary等\",{\"1\":{\"352\":1}}],[\"summary和apiserver\",{\"1\":{\"193\":1}}],[\"summary和histogram都提供了对于事件的计数\",{\"1\":{\"95\":1}}],[\"summary和histogram非常类型相似\",{\"1\":{\"95\":1}}],[\"summary和histogram的用法基本保持一致\",{\"1\":{\"90\":1}}],[\"summary和histogram用于统计和分析样本的分布情况\",{\"1\":{\"90\":1}}],[\"summary和histogram\",{\"1\":{\"88\":1}}],[\"summarymetricfamily\",{\"1\":{\"350\":3}}],[\"summarymetricfamily声明其它的指标类型\",{\"1\":{\"96\":1}}],[\"summarymetricfamily等\",{\"1\":{\"85\":1}}],[\"summary在通过promql进行查询时有更好的性能表现\",{\"1\":{\"95\":1,\"230\":1}}],[\"summary实例也提供了timer\",{\"1\":{\"90\":1}}],[\"summary\",{\"1\":{\"31\":1,\"66\":1,\"67\":2,\"69\":2,\"90\":9,\"93\":1,\"95\":7,\"96\":1,\"116\":3,\"150\":2,\"151\":2,\"227\":1,\"230\":1,\"349\":1,\"352\":5}}],[\"sum时间序列可以计算出相同的内容\",{\"1\":{\"95\":1}}],[\"sum\",{\"1\":{\"69\":1,\"72\":2,\"93\":2,\"95\":8,\"106\":5,\"109\":1,\"111\":3,\"116\":2,\"135\":1,\"139\":1,\"151\":1,\"167\":1,\"193\":1,\"199\":1,\"226\":4,\"230\":2,\"240\":1,\"262\":4,\"349\":2,\"368\":4,\"378\":3}}],[\"s\",{\"1\":{\"27\":1,\"31\":7,\"67\":2,\"135\":1,\"160\":1,\"166\":4,\"175\":1,\"181\":2,\"192\":1,\"202\":1,\"203\":1,\"260\":1,\"273\":1}}],[\"smarthost\",{\"1\":{\"26\":1,\"50\":2}}],[\"smtp\",{\"1\":{\"26\":8,\"50\":14}}],[\"slave4\",{\"1\":{\"156\":1}}],[\"slave3\",{\"1\":{\"156\":1}}],[\"slave1\",{\"1\":{\"156\":1}}],[\"slave0\",{\"1\":{\"156\":1}}],[\"slaves\",{\"1\":{\"156\":2}}],[\"slave\",{\"1\":{\"156\":3}}],[\"slack等等内置的通知方式进行集成\",{\"1\":{\"278\":1}}],[\"slack等多种通知方式的支持\",{\"1\":{\"60\":1}}],[\"slack以及其它方式接收告警信息\",{\"1\":{\"55\":1}}],[\"slack还支持在文本内容中添加链接\",{\"1\":{\"48\":1}}],[\"slack为当前channel创建了一个用于接收消息的api地址\",{\"1\":{\"48\":1}}],[\"slack的强大之处在于在channel中添加各种第三方服务的集成\",{\"1\":{\"47\":1}}],[\"slack作为一款即时通讯工具\",{\"1\":{\"47\":1}}],[\"slack是非常流行的团队沟通应用\",{\"1\":{\"46\":1}}],[\"slack\",{\"1\":{\"26\":1,\"43\":1,\"45\":6,\"47\":1,\"48\":4,\"49\":12}}],[\"slack或者webhook等\",{\"1\":{\"26\":1}}],[\"slack配置等内容\",{\"1\":{\"26\":1}}],[\"slow\",{\"1\":{\"112\":6}}],[\"slideshare\",{\"1\":{\"16\":1}}],[\"some\",{\"1\":{\"156\":1,\"312\":1}}],[\"sources\",{\"0\":{\"404\":1}}],[\"source=\",{\"1\":{\"285\":1}}],[\"source中指定当前查询的数据源\",{\"1\":{\"126\":1}}],[\"source的数据\",{\"1\":{\"123\":1}}],[\"source\",{\"0\":{\"122\":1},\"1\":{\"36\":3,\"51\":1,\"55\":1,\"100\":2,\"108\":2,\"122\":1,\"125\":1,\"156\":2,\"190\":2,\"192\":1,\"196\":5,\"197\":5,\"199\":1,\"200\":2,\"201\":5,\"202\":1,\"203\":15,\"207\":9,\"214\":2,\"218\":8,\"310\":5,\"311\":1,\"312\":3,\"314\":2,\"319\":2,\"321\":2}}],[\"so\",{\"1\":{\"16\":1}}],[\"still\",{\"1\":{\"253\":1}}],[\"stdvar\",{\"1\":{\"226\":1,\"368\":1}}],[\"stddev\",{\"1\":{\"226\":1,\"368\":1}}],[\"st4cd\",{\"1\":{\"206\":1,\"207\":1}}],[\"stereotype\",{\"1\":{\"96\":1}}],[\"step=15s\",{\"1\":{\"257\":1}}],[\"step=<duration>\",{\"1\":{\"257\":1}}],[\"step可以控制prometheus查询数据时的最小步长\",{\"1\":{\"126\":1}}],[\"step\",{\"1\":{\"23\":1,\"126\":1}}],[\"styles选项\",{\"1\":{\"77\":1}}],[\"styles为\\b\\bvalue定义样本值的格式化方式\",{\"1\":{\"77\":1}}],[\"storing\",{\"1\":{\"72\":1}}],[\"storage可以分离监控样本采集和数据存储\",{\"1\":{\"168\":1}}],[\"storage获取历史数据\",{\"1\":{\"167\":1}}],[\"storage相关的配置内容\",{\"1\":{\"167\":1}}],[\"storage相关的协议主要通过以下proto文件进行定义\",{\"1\":{\"166\":1}}],[\"storage支持\",{\"1\":{\"167\":1}}],[\"storage需要用户分别创建用于支持remote\",{\"1\":{\"166\":1}}],[\"storage存储支持\",{\"1\":{\"154\":1}}],[\"storage特性可以解决这一系列问题\",{\"1\":{\"152\":1}}],[\"storage\",{\"0\":{\"14\":1,\"166\":1,\"167\":1},\"1\":{\"14\":1,\"56\":1,\"106\":1,\"108\":1,\"149\":2,\"150\":3,\"151\":2,\"154\":1,\"160\":7,\"162\":1,\"166\":1,\"167\":7,\"273\":1,\"307\":1,\"400\":1}}],[\"strings\",{\"1\":{\"93\":1}}],[\"stringvar\",{\"1\":{\"33\":1}}],[\"string\",{\"0\":{\"265\":1},\"1\":{\"28\":15,\"31\":5,\"32\":1,\"33\":1,\"85\":1,\"86\":1,\"93\":2,\"95\":6,\"96\":1,\"135\":2,\"149\":1,\"241\":8,\"256\":2,\"263\":1,\"265\":1,\"269\":2,\"349\":1,\"350\":2}}],[\"string>\",{\"1\":{\"26\":1,\"49\":12,\"50\":4,\"51\":1,\"99\":1,\"116\":1}}],[\"struct\",{\"1\":{\"28\":2,\"31\":3}}],[\"stable\",{\"1\":{\"397\":1}}],[\"standalone\",{\"0\":{\"391\":1,\"398\":1}}],[\"standardexports\",{\"1\":{\"350\":1}}],[\"stage\",{\"1\":{\"308\":2}}],[\"staging|testing|development\",{\"1\":{\"259\":1}}],[\"stacked\",{\"1\":{\"135\":1}}],[\"starttls\",{\"1\":{\"321\":2}}],[\"starttimer\",{\"1\":{\"90\":1,\"95\":2,\"352\":2}}],[\"start=2015\",{\"1\":{\"257\":1}}],[\"start=<rfc3339\",{\"1\":{\"257\":1}}],[\"starting\",{\"1\":{\"181\":3,\"273\":1,\"305\":2}}],[\"start\",{\"1\":{\"150\":1,\"151\":1,\"166\":1,\"181\":1,\"188\":4,\"193\":4,\"199\":4,\"201\":1,\"205\":1,\"273\":1,\"350\":1,\"375\":1,\"400\":1}}],[\"start命令\",{\"1\":{\"150\":1}}],[\"started\",{\"1\":{\"93\":1,\"273\":1}}],[\"startsat\",{\"1\":{\"27\":1,\"28\":2,\"31\":1,\"51\":2}}],[\"stats获取监控样本\",{\"0\":{\"387\":1}}],[\"statsd\",{\"1\":{\"298\":1}}],[\"stats\",{\"1\":{\"104\":1,\"283\":1,\"325\":1}}],[\"static\",{\"1\":{\"58\":1,\"86\":1,\"89\":2,\"90\":5,\"93\":1,\"95\":4,\"100\":3,\"106\":1,\"108\":1,\"134\":1,\"151\":4,\"156\":1,\"169\":1,\"174\":1,\"273\":2,\"280\":3,\"287\":2,\"349\":1,\"350\":2,\"351\":1,\"352\":6,\"375\":1,\"377\":3,\"378\":1}}],[\"status=\",{\"1\":{\"217\":1,\"268\":6,\"325\":3}}],[\"statusinternalservererror\",{\"1\":{\"166\":1}}],[\"status中的threads\",{\"1\":{\"110\":1}}],[\"statuscode\",{\"1\":{\"103\":1,\"318\":1}}],[\"statusok\",{\"1\":{\"28\":1,\"33\":1}}],[\"statusbadrequest\",{\"1\":{\"28\":1,\"33\":1,\"166\":2}}],[\"status\",{\"1\":{\"27\":1,\"28\":2,\"31\":4,\"32\":2,\"49\":2,\"95\":5,\"99\":4,\"103\":3,\"109\":19,\"110\":8,\"111\":21,\"112\":6,\"150\":3,\"151\":2,\"167\":1,\"175\":1,\"181\":2,\"186\":1,\"187\":1,\"201\":1,\"203\":1,\"205\":1,\"206\":1,\"214\":3,\"216\":1,\"217\":1,\"223\":1,\"253\":2,\"255\":1,\"257\":1,\"294\":2,\"305\":2,\"318\":3}}],[\"statefulset来管理应用workload\",{\"1\":{\"221\":1}}],[\"statefulsets\",{\"1\":{\"210\":1,\"214\":1,\"216\":2}}],[\"statefulset\",{\"1\":{\"178\":1}}],[\"state=\",{\"1\":{\"111\":5}}],[\"state\",{\"1\":{\"15\":1,\"111\":1}}],[\"se\",{\"1\":{\"349\":1}}],[\"segment\",{\"1\":{\"305\":4}}],[\"sevrer\",{\"1\":{\"297\":1}}],[\"sevrer软件包\",{\"1\":{\"273\":1}}],[\"sever分别发送相同的告警给alertmanager\",{\"1\":{\"147\":1}}],[\"severity\",{\"1\":{\"36\":2,\"51\":2,\"55\":2,\"66\":1,\"67\":1,\"69\":2,\"150\":2,\"151\":2}}],[\"separator\",{\"1\":{\"214\":2,\"218\":10,\"241\":1,\"310\":3}}],[\"session\",{\"1\":{\"206\":1}}],[\"selector\",{\"1\":{\"175\":1,\"181\":2,\"195\":2,\"201\":1,\"202\":1,\"203\":2,\"205\":2,\"206\":1,\"217\":4}}],[\"selection\",{\"1\":{\"130\":1}}],[\"select\",{\"1\":{\"109\":1,\"310\":1}}],[\"select可以查询到当前服务器执行查询语句的总次数\",{\"1\":{\"109\":1}}],[\"series中的每一个点称为一个样本\",{\"1\":{\"268\":1}}],[\"series理解为一个以时间为y轴的数字矩阵\",{\"1\":{\"268\":1}}],[\"series通过指标名称\",{\"1\":{\"268\":1}}],[\"series是按照时间戳和值的序列顺序存放的\",{\"1\":{\"268\":1}}],[\"series所对应的监控指标\",{\"1\":{\"227\":1}}],[\"series的形式保存在prometheus内存的tsdb\",{\"1\":{\"227\":1}}],[\"series和heatmap\",{\"1\":{\"126\":1}}],[\"series\",{\"1\":{\"72\":2,\"138\":3,\"141\":1,\"142\":2,\"144\":1,\"156\":1,\"166\":1,\"268\":1,\"269\":1}}],[\"serviceenabletagoverride\",{\"1\":{\"305\":1}}],[\"serviceport\",{\"1\":{\"305\":1}}],[\"servicemeta\",{\"1\":{\"305\":1}}],[\"servicemonitor\",{\"1\":{\"217\":3,\"222\":1}}],[\"servicemonitorselector\",{\"1\":{\"213\":1,\"214\":1,\"218\":1,\"219\":1}}],[\"servicemonitor这些自定义的资源类型来自动化部署和管理prometheus的相关组件以及配置\",{\"1\":{\"210\":1}}],[\"serviceaddress\",{\"1\":{\"305\":1}}],[\"serviceaccountname\",{\"1\":{\"186\":1,\"210\":1,\"213\":1,\"214\":1,\"219\":1}}],[\"serviceaccount\",{\"1\":{\"186\":7,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"218\":1,\"219\":3,\"223\":1}}],[\"servicetags\",{\"1\":{\"305\":1}}],[\"servicename\",{\"1\":{\"305\":1}}],[\"serviceid\",{\"1\":{\"305\":1}}],[\"service作为前缀\",{\"1\":{\"207\":1}}],[\"service负载均衡原理\",{\"1\":{\"206\":1}}],[\"service负载均衡\",{\"1\":{\"202\":1}}],[\"service资源只能通过集群网络进行访问\",{\"1\":{\"181\":1}}],[\"service创建完成后\",{\"1\":{\"178\":1}}],[\"service通过selector\",{\"1\":{\"178\":1}}],[\"service在kubernetes集群内扮演了服务发现和负载均衡的作用\",{\"1\":{\"178\":1}}],[\"service类型为nodeport\",{\"1\":{\"175\":1}}],[\"services则定义了当前需要发现哪些类型服务实例的信息\",{\"1\":{\"306\":1}}],[\"services的监控采集任务\",{\"1\":{\"203\":1}}],[\"services\",{\"1\":{\"48\":3,\"49\":1,\"108\":1,\"167\":1,\"186\":1,\"196\":1,\"203\":1,\"219\":1,\"306\":1,\"310\":1,\"311\":1}}],[\"service\",{\"1\":{\"42\":1,\"175\":2,\"180\":1,\"181\":8,\"186\":1,\"187\":5,\"192\":1,\"195\":1,\"196\":4,\"198\":1,\"201\":1,\"202\":1,\"203\":9,\"205\":2,\"206\":1,\"207\":16,\"214\":1,\"217\":3,\"218\":4,\"223\":1,\"253\":1,\"292\":1,\"305\":8,\"310\":4,\"374\":2,\"375\":1,\"377\":1,\"393\":1}}],[\"server对获取监控样本请求的处理过程\",{\"1\":{\"350\":1}}],[\"server对外提供了自定义的promql语言\",{\"1\":{\"276\":1}}],[\"server对外提供访问路径\",{\"1\":{\"132\":1}}],[\"server向该exporter发起的请求\",{\"1\":{\"350\":1}}],[\"server采集各自关心的内容\",{\"1\":{\"311\":1}}],[\"server采集所有环境中的所有exporter数据显然会存在大量的资源浪费\",{\"1\":{\"311\":1}}],[\"server采集不同的环境监控数据\",{\"1\":{\"308\":1}}],[\"server用于监控自己关心的指标数据\",{\"1\":{\"311\":1}}],[\"server处理的任务量过大时\",{\"1\":{\"297\":1}}],[\"server能够按照某些规则\",{\"1\":{\"308\":1}}],[\"server能够从当前node\",{\"1\":{\"287\":1}}],[\"server能够直接与exporter进行通信\",{\"1\":{\"279\":1}}],[\"server并不直接服务监控特定的目标\",{\"1\":{\"285\":1}}],[\"server知道这些exporter实例的访问地址\",{\"1\":{\"280\":1}}],[\"server则可以采用同样pull的方式从pushgateway中获取到监控数据\",{\"1\":{\"279\":1}}],[\"server通过访问该exporter提供的endpoint端点\",{\"1\":{\"277\":1}}],[\"server通讯即可\",{\"1\":{\"155\":1}}],[\"server进行扩展\",{\"1\":{\"276\":1}}],[\"server进行wal\",{\"1\":{\"230\":1}}],[\"server内置的express\",{\"1\":{\"276\":1}}],[\"server本身就是一个时序数据库\",{\"1\":{\"276\":1}}],[\"server需要对采集到的监控数据进行存储\",{\"1\":{\"276\":1}}],[\"server可以通过静态配置管理监控目标\",{\"1\":{\"276\":1}}],[\"server可能很好的进行迁移\",{\"1\":{\"154\":1}}],[\"server是prometheus组件中的核心部分\",{\"1\":{\"276\":1}}],[\"server中将用于获取监控样本数据的服务称为一个target实例\",{\"1\":{\"370\":1}}],[\"server中自带了一个prometheus\",{\"1\":{\"299\":1}}],[\"server中支持基于promql创建告警规则\",{\"1\":{\"278\":1}}],[\"server中wal\",{\"1\":{\"230\":1}}],[\"server中定义告警规则以及产生告警\",{\"1\":{\"24\":1}}],[\"server以及其相应的配置\",{\"1\":{\"222\":1}}],[\"server自身返回的样本数据中\",{\"1\":{\"230\":1}}],[\"server自身以及配置的自动化管理工作\",{\"1\":{\"221\":1}}],[\"server自身的高可用问题\",{\"1\":{\"147\":1}}],[\"server代理\",{\"1\":{\"200\":1}}],[\"server代理获取kubelet监控指标\",{\"1\":{\"199\":1}}],[\"server提供的代理地址访问kubelet的\",{\"1\":{\"200\":1}}],[\"server提供的代理api访问各个节点中kubelet的metrics服务\",{\"1\":{\"199\":1}}],[\"server组件的访问地址\",{\"1\":{\"198\":1}}],[\"server监控数据\",{\"0\":{\"192\":1}}],[\"server获取cadvisor监控数据状态\",{\"1\":{\"190\":1}}],[\"server作为代理获取节点上的cadvisor监控数据\",{\"1\":{\"190\":1}}],[\"server映射到虚拟机的32022端口\",{\"1\":{\"181\":1}}],[\"server而言\",{\"1\":{\"169\":1}}],[\"server而言保持了配置了简单性\",{\"1\":{\"148\":1}}],[\"server都包含一个用于获取当前实例中监控样本的接口\",{\"1\":{\"169\":1}}],[\"server部署到不同的数据中心可以避免网络配置的复杂性\",{\"1\":{\"169\":1}}],[\"server的联邦集群能力可以使其从其他的prometheus\",{\"1\":{\"276\":1}}],[\"server的\",{\"1\":{\"230\":1}}],[\"server的代理地址\",{\"1\":{\"199\":1}}],[\"server的本地磁盘空间做容量规划时\",{\"1\":{\"160\":1}}],[\"server的可迁移性的场景\",{\"1\":{\"154\":1}}],[\"server将监控数据进行聚合到任务级别\",{\"1\":{\"156\":1}}],[\"server只收集当前采集任务的一部分实例的监控指标\",{\"1\":{\"156\":1}}],[\"server也无法有效处理时\",{\"1\":{\"156\":1}}],[\"server也不会频繁发生迁移的情况\",{\"1\":{\"153\":1}}],[\"server负责聚合多个数据中心的监控数据\",{\"1\":{\"169\":1}}],[\"server负责实现对多数据中心数据的聚合\",{\"1\":{\"155\":1}}],[\"server负责当前数据中心的采集任务是一个不错的方式\",{\"1\":{\"155\":1}}],[\"server负责采集应用监控指标\",{\"1\":{\"155\":1}}],[\"server负责采集基础设施相关的监控指标\",{\"1\":{\"155\":1}}],[\"server无法直接与数据中心中的exporter进行通讯时\",{\"1\":{\"155\":1}}],[\"server无法处理大量的采集任务时\",{\"1\":{\"155\":1}}],[\"server实现对数据的汇聚\",{\"1\":{\"155\":1}}],[\"server实例而言它可以处理\",{\"1\":{\"296\":1}}],[\"server实例中获取数据\",{\"1\":{\"276\":1}}],[\"server实例就变成了声明一个prometheus资源\",{\"1\":{\"216\":1}}],[\"server实例只负责采集当前数据中心中的一部分任务\",{\"1\":{\"170\":1}}],[\"server实例能够与当前数据中心的prometheus\",{\"1\":{\"155\":1}}],[\"server实例\",{\"1\":{\"153\":1,\"169\":1,\"170\":1,\"175\":1,\"222\":1,\"281\":1}}],[\"server发生宕机或者数据丢失的情况下\",{\"1\":{\"154\":1}}],[\"server发生故障后可以确保prometheus持续可用\",{\"1\":{\"147\":1}}],[\"server之间的数据一致性问题以及持久化问题\",{\"1\":{\"153\":1}}],[\"server之间不需要任何的状态同步\",{\"1\":{\"148\":1}}],[\"server所产生的告警\",{\"1\":{\"147\":1}}],[\"server基本上能够应对大部分用户监控规模的需求\",{\"1\":{\"145\":1}}],[\"server暴露样本数据\",{\"0\":{\"86\":1}}],[\"server一样均采用golang实现\",{\"1\":{\"52\":1}}],[\"server\",{\"0\":{\"272\":1,\"276\":1},\"1\":{\"8\":1,\"20\":1,\"60\":1,\"86\":1,\"108\":1,\"147\":1,\"164\":1,\"169\":2,\"198\":1,\"272\":1,\"273\":1,\"274\":1,\"277\":1,\"281\":1,\"287\":2,\"305\":4,\"306\":1,\"308\":1,\"310\":1,\"311\":1,\"325\":4,\"349\":1,\"350\":6,\"370\":1,\"377\":1,\"392\":1}}],[\"section\",{\"1\":{\"305\":4}}],[\"sec\",{\"1\":{\"109\":2,\"110\":2,\"111\":3,\"112\":2}}],[\"second\",{\"1\":{\"67\":1,\"160\":2,\"273\":1,\"350\":1}}],[\"seconds的指标类型为summary\",{\"1\":{\"230\":1}}],[\"seconds为例\",{\"1\":{\"95\":1}}],[\"seconds\",{\"1\":{\"66\":1,\"90\":8,\"93\":7,\"95\":26,\"99\":15,\"105\":4,\"106\":1,\"116\":17,\"135\":2,\"160\":2,\"167\":3,\"188\":4,\"201\":1,\"205\":1,\"217\":4,\"227\":1,\"230\":7,\"240\":14,\"267\":1,\"273\":2,\"286\":1,\"349\":7,\"350\":2,\"352\":4}}],[\"secretname\",{\"1\":{\"210\":1}}],[\"secrets\",{\"1\":{\"186\":2,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"214\":1}}],[\"secret\",{\"1\":{\"26\":2,\"50\":1,\"51\":4,\"210\":2,\"214\":2,\"217\":1}}],[\"setexecutor\",{\"1\":{\"350\":1}}],[\"setup\",{\"1\":{\"186\":2,\"214\":1,\"393\":1}}],[\"setting\",{\"1\":{\"181\":2}}],[\"set\",{\"1\":{\"32\":1,\"72\":1,\"109\":2,\"110\":3,\"111\":3,\"112\":2,\"181\":1,\"253\":1,\"273\":2,\"319\":1,\"350\":3,\"397\":1}}],[\"sensu\",{\"0\":{\"342\":1}}],[\"sensitive\",{\"1\":{\"93\":1}}],[\"sendresponseheaders\",{\"1\":{\"350\":2}}],[\"send方法包含两个参数\",{\"1\":{\"32\":1}}],[\"send\",{\"1\":{\"27\":3,\"30\":1,\"32\":1,\"33\":2,\"49\":2,\"50\":2,\"51\":2,\"195\":3,\"321\":1}}],[\"sent\",{\"1\":{\"23\":1,\"321\":1}}],[\"see\",{\"1\":{\"1\":1,\"5\":1,\"118\":1,\"119\":1}}],[\"在build\",{\"1\":{\"349\":1}}],[\"在bloackbox响应的监控样本中\",{\"1\":{\"103\":1,\"318\":1}}],[\"在blackbox\",{\"1\":{\"99\":1}}],[\"在基于云\",{\"1\":{\"313\":1}}],[\"在基本ha模式的基础上通过添加remote\",{\"1\":{\"154\":1}}],[\"在监控kubernetes下所有的主机节点时\",{\"1\":{\"310\":1}}],[\"在多环境的场景下\",{\"1\":{\"310\":1}}],[\"在json文件中可以使用job标签覆盖默认的job名称\",{\"1\":{\"307\":1}}],[\"在下面的json文件中分别定义了3个采集任务\",{\"1\":{\"307\":1}}],[\"在启动成功后\",{\"1\":{\"305\":1}}],[\"在启动alertmanager之前需要创建相应的目录\",{\"1\":{\"56\":1}}],[\"在云环境以及容器环境下我们更多的监控对象都是动态的\",{\"1\":{\"303\":1}}],[\"在前6个章节中\",{\"1\":{\"302\":1}}],[\"在前面的小节中介绍了grafana中4中常用的可视化面板的使用\",{\"1\":{\"127\":1}}],[\"在前面的部分中已经介绍了告警能力在prometheus的架构中被划分为两个部分\",{\"1\":{\"24\":1}}],[\"在过去一段时间中95\",{\"1\":{\"295\":1}}],[\"在不同的场景下\",{\"1\":{\"313\":1}}],[\"在不同容量情况下系统的并发和负载变化如何\",{\"1\":{\"289\":1}}],[\"在不考虑kubernetes自身组件的情况下\",{\"1\":{\"184\":1}}],[\"在当前页面中根据物理主机系统的不同\",{\"1\":{\"286\":1}}],[\"在配置正确的情况下点击\",{\"1\":{\"283\":1}}],[\"在配置文件中使用route定义了顶级的路由\",{\"1\":{\"55\":1}}],[\"在形式上\",{\"1\":{\"269\":1}}],[\"在time\",{\"1\":{\"268\":1}}],[\"在1\",{\"1\":{\"267\":1}}],[\"在12ms范围内的运行任务次数为34\",{\"1\":{\"139\":1}}],[\"在并非唯一的情况下\",{\"1\":{\"262\":1}}],[\"在瞬时向量表达式或者区间向量表达式中\",{\"1\":{\"261\":1}}],[\"在响应内容中使用resulttype表示当前返回的数据类型\",{\"1\":{\"256\":1}}],[\"在响应内容中还会得到当前jvm的运行状态数据\",{\"1\":{\"87\":1}}],[\"在逻辑运算and\",{\"1\":{\"251\":1,\"367\":1}}],[\"在限定匹配标签后\",{\"1\":{\"251\":1,\"367\":1}}],[\"在操作符两边表达式标签不一致的情况下\",{\"1\":{\"250\":1,\"366\":1}}],[\"在没有发生重置\",{\"1\":{\"238\":1}}],[\"在微服务中通常提倡\",{\"1\":{\"234\":1}}],[\"在之前prometheus简介部分介绍监控的基本目标\",{\"1\":{\"232\":1}}],[\"在之前的部分有讲过\",{\"1\":{\"42\":1}}],[\"在实现监控时\",{\"1\":{\"231\":1}}],[\"在实际的操作中\",{\"1\":{\"187\":1}}],[\"在选择这两种方式时用户应该按照自己的实际场景进行选择\",{\"1\":{\"230\":1}}],[\"在node\",{\"1\":{\"227\":1}}],[\"在安装prometheus\",{\"1\":{\"223\":1}}],[\"在完成数据源的添加之后就可以在grafana中创建我们可视化dashboard了\",{\"1\":{\"283\":1}}],[\"在完成serviceaccount创建后\",{\"1\":{\"219\":1}}],[\"在完成角色权限以及用户的绑定之后\",{\"1\":{\"186\":1}}],[\"在原生的prometheus配置方式中\",{\"1\":{\"217\":1}}],[\"在原生的管理方式上\",{\"1\":{\"213\":1}}],[\"在了解了kubernetes下service与endpoint的关系以后\",{\"1\":{\"207\":1}}],[\"在了解了slack以及incomming\",{\"1\":{\"49\":1}}],[\"在relabel\",{\"1\":{\"202\":1}}],[\"在开始正式内容之前\",{\"1\":{\"202\":1}}],[\"在开始使用grafana之前\",{\"1\":{\"121\":1}}],[\"在镜像prom\",{\"1\":{\"195\":1}}],[\"在从minikube集群中获取到的一个节点metadata标签信息\",{\"1\":{\"189\":1}}],[\"在未指定命名空间的情况下\",{\"1\":{\"181\":1}}],[\"在命令行中使用\",{\"1\":{\"181\":1}}],[\"在命名空间default创建configmap资源\",{\"1\":{\"174\":1}}],[\"在该任务配置中\",{\"1\":{\"203\":1}}],[\"在该yaml文件中\",{\"1\":{\"181\":1}}],[\"在该函数中\",{\"1\":{\"135\":1}}],[\"在dashbord中\",{\"1\":{\"181\":1}}],[\"在dashboard页面右上角菜单中点击\",{\"1\":{\"141\":1}}],[\"在dashboard页面中\",{\"1\":{\"123\":1}}],[\"在集群内\",{\"1\":{\"180\":1}}],[\"在白盒监控层面我们需要关注\",{\"1\":{\"180\":1}}],[\"在kubernetes这类容器管理平台中\",{\"1\":{\"313\":1}}],[\"在kubernetes集群中部署prometheus\",{\"0\":{\"223\":1}}],[\"在kubernetes集群中命名空间default中会包含一个名为kubernetes的默认service\",{\"1\":{\"192\":1}}],[\"在kubernetes基本的resource和controller的概念上\",{\"1\":{\"221\":1}}],[\"在kubernetes下安装部署prometheus\",{\"0\":{\"393\":1}}],[\"在kubernetes下service是作为一个内部负载均衡器的存在\",{\"1\":{\"206\":1}}],[\"在kubernetes下\",{\"1\":{\"187\":1}}],[\"在kubernetes下部署应用程序时\",{\"1\":{\"207\":1}}],[\"在kubernetes下部署blackbox\",{\"0\":{\"195\":1}}],[\"在kubernetes下部署的pod实例都会包含一组描述自身信息的label\",{\"1\":{\"178\":1}}],[\"在kubernetes下部署prometheus\",{\"0\":{\"173\":1}}],[\"在kubernetes中安装prometheus\",{\"1\":{\"223\":1}}],[\"在kubernetes中我们使用deployment\",{\"1\":{\"221\":1}}],[\"在kubernetes中service和endpoint是两个独立的资源\",{\"1\":{\"206\":1}}],[\"在kubernetes中主要使用基于角色的访问控制模型\",{\"1\":{\"186\":1}}],[\"在kubernetes中通过定义service\",{\"1\":{\"178\":1}}],[\"在kubernetes中可以使用configmaps资源定义和管理这些配置\",{\"1\":{\"174\":1}}],[\"在google已经使用超过15年\",{\"1\":{\"171\":1,\"177\":1}}],[\"在grafana首页中显示默认的使用向导\",{\"1\":{\"283\":1}}],[\"在grafana\",{\"1\":{\"140\":1}}],[\"在grafana中使用heatmap\",{\"1\":{\"141\":1}}],[\"在grafana中配置如图\",{\"1\":{\"130\":1}}],[\"在grafana中用户可以为dashboard定义一组变量\",{\"1\":{\"128\":1}}],[\"在grafana中dashboard是属于一个organization\",{\"1\":{\"124\":1}}],[\"在grafana中\",{\"1\":{\"123\":1}}],[\"在graph面板中display选项可以帮助我们实现更多的可视化定制的能力\",{\"1\":{\"138\":1}}],[\"在graph面板的legend选项可以进一步控制图例的显示方式\",{\"1\":{\"138\":1}}],[\"在每个数据中心部署单独的prometheus\",{\"1\":{\"169\":1}}],[\"在每一个采集任务的配置中可以添加多个relabel\",{\"1\":{\"310\":1}}],[\"在每一个数据中部署一个单独的prometheus\",{\"1\":{\"155\":1}}],[\"在每一个group中我们可以定义多个告警规则\",{\"1\":{\"66\":1}}],[\"在远程读的流程当中\",{\"1\":{\"164\":1}}],[\"在一个新的terminal窗口中运行consul\",{\"1\":{\"305\":1}}],[\"在一个dashboard中一个最基本的可视化单元为一个panel\",{\"1\":{\"123\":1}}],[\"在一般情况下\",{\"1\":{\"160\":1,\"239\":1}}],[\"在文件系统中这些块保存在单独的目录当中\",{\"1\":{\"159\":1}}],[\"在解决了prometheus服务可用性的基础上\",{\"1\":{\"154\":1}}],[\"在简单了解了gossip协议之后\",{\"1\":{\"148\":1}}],[\"在promql中支持使用常用的算术运算符\",{\"1\":{\"355\":1}}],[\"在promql操作符中优先级由高到低依次为\",{\"1\":{\"248\":1,\"369\":1}}],[\"在promql通过标签匹配模式\",{\"1\":{\"245\":1}}],[\"在prometheus所有的target实例中\",{\"1\":{\"309\":1}}],[\"在prometheus支持的众多服务发现的实现方式中\",{\"1\":{\"307\":1}}],[\"在prometheus源码中也可以找到指标\",{\"1\":{\"269\":1}}],[\"在prometheus的配置文件当可以通过以下方式与consul进行集成\",{\"1\":{\"306\":1}}],[\"在prometheus的配置文件中添加名为kubernetes\",{\"1\":{\"203\":1}}],[\"在prometheus的配置文件中\",{\"1\":{\"187\":1}}],[\"在prometheus的架构设计中\",{\"1\":{\"285\":1}}],[\"在prometheus的架构中被划分成两个独立的部分\",{\"1\":{\"58\":1}}],[\"在prometheus的底层实现中指标名称实际上是以\",{\"1\":{\"269\":1}}],[\"在prometheus的存储实现上所有的监控样本都是以time\",{\"1\":{\"227\":1}}],[\"在prometheus和alertmanager实例之间不要使用任何的负载均衡\",{\"1\":{\"151\":1}}],[\"在prometheus设计上\",{\"1\":{\"145\":1}}],[\"在prometheus监控服务的健康状态时\",{\"1\":{\"144\":1}}],[\"在prometheus配置文件中\",{\"1\":{\"72\":1}}],[\"在prometheus中通过标签选择当前需要监控的servicemonitor对象\",{\"1\":{\"218\":1}}],[\"在prometheus中\",{\"1\":{\"60\":1,\"131\":1,\"207\":1,\"280\":1}}],[\"在prometheus中一条告警规则主要由以下几部分组成\",{\"1\":{\"60\":1}}],[\"在prometheus中自定义告警规则\",{\"1\":{\"24\":1}}],[\"在prometheus\",{\"0\":{\"210\":1},\"1\":{\"10\":1,\"22\":1,\"24\":1,\"116\":1,\"210\":1,\"230\":1,\"278\":1,\"307\":1,\"370\":1}}],[\"在procfile文件所在目录\",{\"1\":{\"150\":1}}],[\"在push\",{\"1\":{\"148\":1}}],[\"在默认情况下\",{\"1\":{\"145\":1,\"214\":1,\"310\":1}}],[\"在默认情况下http探针只会对http返回状态码进行校验\",{\"1\":{\"103\":1,\"318\":1}}],[\"在样本数据中会通过0表示不健康\",{\"1\":{\"144\":1}}],[\"在某些场景下我们可能\\b\\b更关心的是\\b这些数字表示的意义\",{\"1\":{\"144\":1}}],[\"在某些情况下\",{\"1\":{\"62\":1}}],[\"在某些情况下除了alertmanager已经内置的集中告警通知方式以外\",{\"1\":{\"27\":1}}],[\"在以下场景中特别适用于使用singlestat\",{\"1\":{\"143\":1}}],[\"在y轴\",{\"1\":{\"142\":1}}],[\"在01ms范围内的任务次数为2\",{\"1\":{\"139\":1}}],[\"在02ms区间范围内为36次\",{\"1\":{\"139\":1}}],[\"在示例中会返回3条\",{\"1\":{\"138\":1}}],[\"在定义query类型变量时\",{\"1\":{\"130\":1}}],[\"在导入dashboard时\",{\"1\":{\"129\":1}}],[\"在展示主机cpu使用率时\",{\"1\":{\"127\":1}}],[\"在面板中\",{\"1\":{\"126\":1}}],[\"在query\",{\"1\":{\"126\":1,\"257\":1}}],[\"在metadata中声明了该deployment的名称以及标签\",{\"1\":{\"181\":1}}],[\"在metrics选项中\",{\"1\":{\"138\":1}}],[\"在metrics中使用变量\",{\"1\":{\"130\":1}}],[\"在metric中使用变量\",{\"1\":{\"131\":1}}],[\"在metric选项中可以定义了grafana从哪些数据源中查询样本数据\",{\"1\":{\"126\":1}}],[\"在minikube下可以通过以下命令打开\",{\"1\":{\"181\":1}}],[\"在mysql中还可以通过安装response\",{\"1\":{\"112\":1}}],[\"在mysql中通过全局设置max\",{\"1\":{\"110\":1}}],[\"在mysqld\",{\"1\":{\"111\":1}}],[\"在mysql内部通过一个名为questions的计数器\",{\"1\":{\"109\":1}}],[\"在通用设置中\",{\"1\":{\"126\":1}}],[\"在通读这些内容后\",{\"1\":{\"1\":1}}],[\"在exporter返回的样本数据中\",{\"1\":{\"227\":1}}],[\"在exporter响应的http头信息中\",{\"1\":{\"117\":1}}],[\"在email\",{\"1\":{\"50\":1}}],[\"在所有节点上运行一个cadvisor再通过各自的ui查看监控信息显然不太方便\",{\"1\":{\"105\":1}}],[\"在大多数情况下人们都倾向于使用某些量化指标的平均值\",{\"1\":{\"230\":1}}],[\"在大多数情况下\",{\"1\":{\"103\":1,\"318\":1}}],[\"在上一部分中我们介绍了prometheus的relabeling机制\",{\"1\":{\"311\":1}}],[\"在上一小节中我们称该表达式为瞬时向量表达式\",{\"1\":{\"244\":1}}],[\"在上一小节中我们带领读者了解了prometheus的底层数据模型\",{\"1\":{\"227\":1}}],[\"在上一小节中我们介绍了与kubernetes的应用管理模型\",{\"1\":{\"173\":1}}],[\"在上一小节中我们主要讨论了prometheus\",{\"1\":{\"147\":1}}],[\"在上一小节中\",{\"1\":{\"141\":1,\"189\":1,\"237\":1,\"280\":1,\"310\":1,\"370\":1}}],[\"在上一小节讲过\",{\"1\":{\"101\":1,\"316\":1}}],[\"在上面的例子中\",{\"1\":{\"351\":1}}],[\"在上面的例子中node\",{\"1\":{\"286\":1}}],[\"在上面的部分中已经简单介绍过\",{\"1\":{\"26\":1}}],[\"在采集任务时会在请求目标地址中添加<name>参数\",{\"1\":{\"100\":1}}],[\"在采集样本数据之前通过relabel\",{\"1\":{\"100\":1}}],[\"在本书中将以gradle为例\",{\"1\":{\"349\":1}}],[\"在本书中我们不会事无巨细的讲述所有事\",{\"1\":{\"5\":1}}],[\"在本书当中\",{\"1\":{\"300\":1}}],[\"在本示例中由于prometheus是部署在monitoring命名空间下\",{\"1\":{\"217\":1}}],[\"在本地可以使用开发者模式在本地快速启动一个单节点的consul环境\",{\"1\":{\"305\":1}}],[\"在本地使用prometheus和nodeexporter搭建了一个主机监控的环境\",{\"1\":{\"271\":1}}],[\"在本地同样通过port\",{\"1\":{\"217\":1}}],[\"在本地运行cadvisor也非常简单\",{\"1\":{\"105\":1}}],[\"在本小节中\",{\"1\":{\"198\":1}}],[\"在本节中\",{\"1\":{\"188\":1}}],[\"在本机通过命令行启动kubernetes集群\",{\"1\":{\"181\":1}}],[\"在本章的前几个小节中笔者已经分别介绍了prometheus的几种服务发现机制\",{\"1\":{\"308\":1}}],[\"在本章的前几个小节中我们主要介绍了prometheus下如何进行白盒监控\",{\"1\":{\"98\":1}}],[\"在本章的第2小节中\",{\"1\":{\"240\":1}}],[\"在本章的\",{\"1\":{\"201\":1,\"205\":1}}],[\"在本章中\",{\"1\":{\"209\":1}}],[\"在本章中将会带来读者学习如何使用grafana创建更加精美的可视化报表\",{\"1\":{\"120\":1}}],[\"在本章中我们学习了如何通过prometheus内置的console\",{\"1\":{\"119\":1}}],[\"在本章中我们将介绍prometheus下的可视化技术\",{\"1\":{\"118\":1}}],[\"在调用collector的register\",{\"1\":{\"96\":1}}],[\"在总共2次请求当中\",{\"1\":{\"95\":5}}],[\"在axes选项中可以控制图标的x轴和y轴相关的行为\",{\"1\":{\"138\":1}}],[\"在aftercompletion方法中\",{\"1\":{\"95\":1}}],[\"在alertmanager使用邮箱通知\",{\"1\":{\"50\":1}}],[\"在alertmanager的全局配置中\",{\"1\":{\"49\":1}}],[\"在alertmanager的配置中会定义一个基于标签匹配规则的告警路由树\",{\"1\":{\"40\":1}}],[\"在alertmanager配置文件的告警路由下\",{\"1\":{\"42\":1}}],[\"在alertmanager配置文件中\",{\"1\":{\"36\":1,\"40\":1}}],[\"在alertmanager中我们可以与邮件\",{\"1\":{\"278\":1}}],[\"在alertmanager中我们可以直接在配置文件的global中定义全局的smtp配置\",{\"1\":{\"50\":1}}],[\"在alertmanager中可以定义一组接收器\",{\"1\":{\"55\":1}}],[\"在alertmanager中可以使用如下配置定义基于webhook的告警接收器receiver\",{\"1\":{\"27\":1}}],[\"在alertmanager中添加slack支持就非常简单了\",{\"1\":{\"49\":1}}],[\"在alertmanager中使用slack\",{\"0\":{\"49\":1}}],[\"在alertmanager中路由负责对告警信息进行分组匹配\",{\"1\":{\"43\":1}}],[\"在alertmanager中通过路由\",{\"1\":{\"26\":1}}],[\"在业务代码中进行监控埋点\",{\"0\":{\"88\":1}}],[\"在consul\",{\"1\":{\"306\":1}}],[\"在consul当中服务可以通过服务定义文件或者是http\",{\"1\":{\"305\":1}}],[\"在console\",{\"1\":{\"134\":1,\"135\":2}}],[\"在consoles目录下创建index\",{\"1\":{\"133\":1}}],[\"在client\",{\"1\":{\"85\":1,\"87\":1,\"88\":1}}],[\"在channel中会显示新的通知信息\",{\"1\":{\"48\":1}}],[\"在国内\",{\"1\":{\"73\":1}}],[\"在国外有大量的it团队使用slack作为团队协作平台\",{\"1\":{\"46\":1}}],[\"在这个例子中\",{\"1\":{\"310\":1}}],[\"在这种情况下\",{\"1\":{\"251\":1,\"367\":1}}],[\"在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知\",{\"1\":{\"62\":1}}],[\"在这里指定了数据源为prometheus\",{\"1\":{\"130\":1}}],[\"在这一章中\",{\"1\":{\"271\":1}}],[\"在这一章节当中我们将重点讨论这些用于获取特定目标监控样本数据的程序exporter\",{\"1\":{\"82\":1}}],[\"在这一小节中\",{\"1\":{\"191\":1}}],[\"在这一小节中我们将学习使用dashboard变量的方式解决以上问题\",{\"1\":{\"127\":1}}],[\"在这一小节中介绍了如何配置和使用prometheus提供的告警能力\",{\"1\":{\"70\":1}}],[\"在这部分\",{\"1\":{\"73\":1,\"180\":1,\"184\":1}}],[\"在主机上运行以下命令\",{\"1\":{\"69\":1}}],[\"在目录\",{\"1\":{\"69\":1}}],[\"在告警规则文件的annotations中使用summary描述告警的概要信息\",{\"1\":{\"67\":1}}],[\"在告警规则文件中\",{\"1\":{\"66\":1}}],[\"在等待期间新产生告警的状态为pending\",{\"1\":{\"66\":1}}],[\"在企业的配置页面可以看到\",{\"1\":{\"51\":2}}],[\"在应用的配置页面可以看到\",{\"1\":{\"51\":3}}],[\"在应用中内置prometheus支持\",{\"0\":{\"93\":1},\"1\":{\"9\":1,\"21\":1}}],[\"在secret创建成功后\",{\"1\":{\"214\":1}}],[\"在singlestat中使用emoji表情字符\",{\"1\":{\"144\":1}}],[\"在smtp配置正确的情况下\",{\"1\":{\"50\":1}}],[\"在slack的基础上也衍生出了大量的chatops相关的技术实践\",{\"1\":{\"46\":1}}],[\"在网络正常的情况下\",{\"1\":{\"48\":1}}],[\"在设置了自定义模板的访问路径后\",{\"1\":{\"45\":1}}],[\"在接下来的部分\",{\"1\":{\"26\":1}}],[\"在全局配置中需要注意的是resolve\",{\"1\":{\"26\":1}}],[\"在http\",{\"0\":{\"252\":1,\"254\":1},\"1\":{\"8\":1,\"20\":1,\"234\":1}}],[\"在单个节点的情况下prometheus能够轻松完成对数以百万的监控指标的处理\",{\"1\":{\"5\":1}}],[\"在\",{\"1\":{\"3\":1,\"49\":1,\"235\":1,\"289\":1,\"309\":1}}],[\"在第6章的\",{\"1\":{\"312\":1}}],[\"在第8章中\",{\"1\":{\"220\":1}}],[\"在第4章中我们介绍了如何基于blackbox\",{\"1\":{\"194\":1}}],[\"在第4章的\",{\"1\":{\"188\":1}}],[\"在第7章中\",{\"1\":{\"185\":1}}],[\"在第7章的\",{\"1\":{\"100\":1}}],[\"在第二个阶段wait中\",{\"1\":{\"148\":1}}],[\"在第二部分的最后我们会介绍如何对prometheus运维管理\",{\"1\":{\"1\":1}}],[\"在第一个阶段silence中\",{\"1\":{\"148\":1}}],[\"在第2章的\",{\"1\":{\"139\":1}}],[\"在第1章以及第2章的内容中\",{\"1\":{\"132\":1}}],[\"在第1章的\",{\"1\":{\"120\":1,\"125\":1,\"204\":1}}],[\"在第1章中\",{\"1\":{\"92\":1}}],[\"在第1章中为了采集主机的监控样本数据\",{\"1\":{\"82\":1}}],[\"在第三部分\",{\"1\":{\"1\":1}}],[\"在敏捷和devops领域有丰富的实践经验\",{\"1\":{\"0\":1}}],[\"第3步\",{\"1\":{\"100\":1}}],[\"第3章\",{\"0\":{\"24\":1},\"1\":{\"5\":1,\"8\":1,\"20\":1}}],[\"第2步\",{\"1\":{\"100\":1}}],[\"第2章\",{\"0\":{\"224\":1},\"1\":{\"5\":1,\"8\":1,\"20\":1}}],[\"第1步\",{\"1\":{\"100\":1}}],[\"第1章\",{\"0\":{\"270\":1},\"1\":{\"5\":1,\"8\":1,\"20\":1}}],[\"第一个可视化面板\",{\"1\":{\"283\":1}}],[\"第一\",{\"1\":{\"178\":1}}],[\"第一种方法是直接跳过ca证书校验过程\",{\"1\":{\"199\":1}}],[\"第一种\",{\"1\":{\"45\":1}}],[\"第一部分\",{\"1\":{\"1\":1}}],[\"第二步\",{\"1\":{\"202\":1}}],[\"第二个关键指标即pod的启动时间\",{\"1\":{\"193\":1}}],[\"第二\",{\"1\":{\"178\":1}}],[\"第二种方式\",{\"1\":{\"45\":1,\"199\":1}}],[\"第二种方式则基于正则表达式\",{\"1\":{\"41\":1}}],[\"第二部分\",{\"1\":{\"1\":1}}],[\"第9章\",{\"0\":{\"208\":1},\"1\":{\"10\":1,\"22\":1}}],[\"第6章\",{\"0\":{\"145\":1},\"1\":{\"5\":1,\"9\":1,\"21\":1}}],[\"第5章\",{\"0\":{\"118\":1},\"1\":{\"5\":1,\"9\":1,\"21\":1}}],[\"第8章\",{\"0\":{\"171\":1},\"1\":{\"3\":6,\"5\":1,\"10\":1,\"22\":1}}],[\"第7章\",{\"0\":{\"302\":1},\"1\":{\"3\":4,\"5\":1,\"9\":1,\"21\":1}}],[\"第4章\",{\"0\":{\"82\":1},\"1\":{\"3\":1,\"5\":1,\"9\":1,\"21\":1}}],[\"tm\",{\"1\":{\"349\":1}}],[\"tmp作为标签名的前缀\",{\"1\":{\"312\":1}}],[\"tmp\",{\"1\":{\"156\":2,\"312\":3}}],[\"tmpl\",{\"1\":{\"45\":3,\"51\":1}}],[\"tmpl获得\",{\"1\":{\"45\":1}}],[\"t`\",{\"1\":{\"265\":1}}],[\"ttl=\",{\"1\":{\"187\":1,\"189\":1}}],[\"t2\",{\"1\":{\"159\":1}}],[\"t1\",{\"1\":{\"159\":1}}],[\"t0\",{\"1\":{\"159\":1}}],[\"ts\",{\"1\":{\"166\":4}}],[\"ts=2018\",{\"1\":{\"150\":7,\"151\":3,\"218\":1,\"273\":6}}],[\"tsdb\",{\"1\":{\"106\":1,\"108\":1,\"139\":16,\"141\":1,\"151\":2,\"160\":5,\"230\":24,\"273\":3,\"294\":1,\"307\":1}}],[\"tcp探针\",{\"0\":{\"321\":1}}],[\"tcp探针等\",{\"1\":{\"289\":1}}],[\"tcp探针等用于检测站点或者服务的可访问性\",{\"1\":{\"98\":1}}],[\"tcp\",{\"1\":{\"99\":2,\"167\":1,\"175\":4,\"181\":5,\"192\":1,\"195\":9,\"202\":1,\"203\":2,\"205\":1,\"206\":2,\"207\":2,\"232\":1,\"314\":1,\"321\":4}}],[\"tcp以及icmp的方式对网络进行探测\",{\"1\":{\"99\":1}}],[\"threadexports\",{\"1\":{\"350\":1}}],[\"threads\",{\"1\":{\"110\":5}}],[\"thresholds将会被警用\",{\"1\":{\"138\":1}}],[\"threshold设置\",{\"1\":{\"138\":1}}],[\"threshold主要用于一些自定义一些样本的阈值\",{\"1\":{\"138\":1}}],[\"throws\",{\"1\":{\"86\":1,\"91\":1,\"93\":1,\"94\":2,\"95\":7,\"96\":1,\"349\":1,\"350\":1}}],[\"than\",{\"1\":{\"67\":1}}],[\"that\",{\"1\":{\"67\":2,\"93\":2}}],[\"thumb\",{\"1\":{\"49\":1}}],[\"thing\",{\"1\":{\"48\":1}}],[\"this\",{\"1\":{\"48\":3,\"72\":1,\"156\":2,\"265\":1,\"273\":1,\"350\":3}}],[\"them\",{\"1\":{\"273\":1}}],[\"these\",{\"1\":{\"265\":1}}],[\"their\",{\"1\":{\"230\":1,\"310\":1}}],[\"they\",{\"1\":{\"23\":1,\"160\":1}}],[\"the\",{\"1\":{\"23\":2,\"27\":4,\"45\":1,\"51\":5,\"67\":2,\"72\":10,\"90\":1,\"93\":4,\"99\":7,\"103\":2,\"105\":1,\"108\":1,\"116\":4,\"135\":13,\"150\":4,\"156\":1,\"160\":4,\"166\":1,\"181\":1,\"188\":1,\"217\":1,\"218\":1,\"227\":1,\"253\":1,\"267\":1,\"273\":5,\"286\":1,\"310\":9,\"314\":3,\"318\":2,\"319\":7,\"321\":7}}],[\"take\",{\"1\":{\"310\":1}}],[\"taken\",{\"1\":{\"99\":1}}],[\"table以及text\",{\"1\":{\"126\":1}}],[\"table\",{\"0\":{\"76\":1},\"1\":{\"76\":3,\"77\":1,\"126\":1}}],[\"tar\",{\"1\":{\"54\":3,\"273\":3,\"285\":3,\"373\":4}}],[\"target以\",{\"1\":{\"309\":1}}],[\"target列表以及状态\",{\"1\":{\"280\":1}}],[\"target页面状态\",{\"1\":{\"187\":1}}],[\"targetport\",{\"1\":{\"175\":1,\"181\":1,\"206\":1}}],[\"target=\",{\"1\":{\"134\":1}}],[\"target=baidu\",{\"1\":{\"99\":1}}],[\"target实例\",{\"1\":{\"100\":1}}],[\"target的值\",{\"1\":{\"100\":1}}],[\"target标签中\",{\"1\":{\"100\":1}}],[\"target参数指定探测目标\",{\"1\":{\"99\":1}}],[\"targets查看所有的采集目标实例\",{\"1\":{\"378\":1}}],[\"targets状态\",{\"1\":{\"280\":1}}],[\"targets直接从prometheus的ui中查看当前所有的任务以及每个任务对应的实例信息\",{\"1\":{\"280\":1}}],[\"targets\",{\"1\":{\"58\":1,\"100\":3,\"106\":1,\"108\":1,\"151\":4,\"156\":1,\"169\":1,\"174\":1,\"273\":2,\"280\":2,\"287\":2,\"307\":5,\"312\":1,\"377\":3,\"378\":1}}],[\"target\",{\"1\":{\"36\":3,\"55\":1,\"100\":11,\"106\":1,\"156\":1,\"190\":4,\"192\":1,\"196\":7,\"197\":7,\"199\":2,\"200\":3,\"201\":4,\"202\":1,\"203\":21,\"207\":7,\"218\":11,\"310\":2,\"312\":2,\"374\":3}}],[\"talking\",{\"1\":{\"51\":1}}],[\"tags\",{\"1\":{\"305\":1,\"310\":1}}],[\"taggedaddresses\",{\"1\":{\"305\":2}}],[\"tag\",{\"1\":{\"16\":1,\"51\":2}}],[\"tracks\",{\"1\":{\"325\":4}}],[\"transport\",{\"1\":{\"314\":1}}],[\"transmit\",{\"1\":{\"105\":1,\"106\":1}}],[\"transfer\",{\"1\":{\"99\":1}}],[\"transform\",{\"1\":{\"31\":1}}],[\"transformtomarkdown将alertmanager告警通知与dingtalk消息进行映射\",{\"1\":{\"32\":1}}],[\"transformtomarkdown\",{\"1\":{\"31\":2,\"32\":1}}],[\"transformer\",{\"1\":{\"31\":1,\"32\":2}}],[\"try\",{\"1\":{\"90\":1,\"352\":2}}],[\"true\",{\"1\":{\"26\":1,\"27\":1,\"49\":1,\"50\":2,\"51\":1,\"93\":1,\"156\":1,\"169\":1,\"187\":1,\"189\":1,\"195\":1,\"196\":1,\"197\":1,\"199\":1,\"200\":1,\"201\":5,\"203\":4,\"205\":4,\"207\":7,\"217\":1,\"246\":1,\"305\":1,\"350\":1,\"361\":1,\"362\":1}}],[\"titles\",{\"1\":{\"135\":2}}],[\"titlelink\",{\"1\":{\"49\":1}}],[\"title\",{\"1\":{\"30\":2,\"31\":3,\"49\":3,\"135\":3}}],[\"time>\",{\"1\":{\"256\":4}}],[\"time=2015\",{\"1\":{\"255\":1}}],[\"time=<rfc3339\",{\"1\":{\"255\":1}}],[\"timescaledb\",{\"1\":{\"167\":1}}],[\"timeseries\",{\"1\":{\"166\":5,\"273\":1}}],[\"timestamp2\",{\"1\":{\"294\":2}}],[\"timestamp1\",{\"1\":{\"294\":2}}],[\"timestamp>\",{\"1\":{\"255\":1,\"257\":2}}],[\"timestamp为可选默认为当前时间\",{\"1\":{\"116\":1}}],[\"timestamp的类型为int64\",{\"1\":{\"116\":1}}],[\"timestamp\",{\"1\":{\"116\":1,\"160\":2,\"166\":3,\"268\":2}}],[\"timecontrol\",{\"1\":{\"135\":1}}],[\"time插件\",{\"1\":{\"112\":1}}],[\"time的设置\",{\"1\":{\"112\":1}}],[\"time的值后\",{\"1\":{\"112\":1}}],[\"timer\",{\"1\":{\"90\":3,\"95\":1,\"352\":2}}],[\"time\",{\"1\":{\"28\":5,\"72\":3,\"93\":1,\"99\":4,\"112\":2,\"126\":1,\"135\":1,\"141\":1,\"156\":1,\"160\":2,\"166\":2,\"188\":4,\"201\":1,\"205\":1,\"230\":1,\"268\":2,\"286\":2,\"305\":1,\"349\":1,\"350\":1,\"378\":1}}],[\"timeout的全局设置\",{\"1\":{\"255\":1,\"257\":1}}],[\"timeout=<duration>\",{\"1\":{\"255\":1,\"257\":1}}],[\"timeout\",{\"1\":{\"26\":2,\"51\":1,\"55\":1,\"99\":2,\"102\":2,\"103\":3,\"151\":1,\"165\":2,\"210\":1,\"214\":2,\"218\":2,\"273\":1,\"307\":1,\"317\":2,\"318\":3}}],[\"tee\",{\"1\":{\"305\":1}}],[\"temp\",{\"1\":{\"229\":1}}],[\"template中还可以使用模板组件prom\",{\"1\":{\"135\":1}}],[\"template中我们可以在页面中使用内置的promconsole\",{\"1\":{\"135\":1}}],[\"template的语言\",{\"1\":{\"134\":1}}],[\"template有关的两个启动参数为\",{\"1\":{\"133\":1}}],[\"template页面的菜单与prometheus\",{\"1\":{\"134\":1}}],[\"template页面\",{\"1\":{\"133\":1}}],[\"template模板语言\",{\"1\":{\"120\":1}}],[\"template虽然能满足一定的可视化需求\",{\"1\":{\"120\":1}}],[\"template实现基本的可视化能力\",{\"1\":{\"119\":1}}],[\"template创建可视化页面\",{\"1\":{\"118\":1}}],[\"template能力以及grafana这一可视化工具实现监控数据可视化\",{\"1\":{\"118\":1}}],[\"template即可\",{\"1\":{\"49\":1}}],[\"templates\",{\"1\":{\"26\":2,\"45\":4,\"51\":1,\"133\":1}}],[\"template\",{\"0\":{\"132\":1},\"1\":{\"9\":1,\"21\":1,\"45\":4,\"49\":6,\"50\":1,\"51\":6,\"132\":1,\"134\":5,\"135\":2,\"175\":1,\"181\":1,\"186\":1,\"195\":1,\"201\":1,\"203\":1,\"205\":1,\"207\":1,\"217\":1}}],[\"terminating\",{\"1\":{\"181\":1,\"186\":1,\"187\":1}}],[\"te6ccfx4l\",{\"1\":{\"48\":3,\"49\":1}}],[\"team\",{\"1\":{\"42\":1,\"213\":1,\"214\":1,\"217\":2,\"218\":1,\"219\":1}}],[\"textformat\",{\"1\":{\"350\":2}}],[\"text\",{\"1\":{\"30\":3,\"31\":3,\"45\":4,\"48\":5,\"49\":2,\"116\":1,\"117\":1,\"134\":1,\"144\":2}}],[\"type则说明当前指标的数据类型\",{\"1\":{\"286\":1}}],[\"types\",{\"1\":{\"166\":1}}],[\"type=simple\",{\"1\":{\"374\":1}}],[\"type=clusterip\",{\"1\":{\"181\":1}}],[\"type=\",{\"1\":{\"134\":1}}],[\"type指定特定的规范版本\",{\"1\":{\"117\":1}}],[\"type注释行必须出现在指标的第一个样本之前\",{\"1\":{\"116\":1}}],[\"type>\",{\"1\":{\"116\":1,\"189\":1}}],[\"type开始\",{\"1\":{\"116\":1}}],[\"type\",{\"1\":{\"28\":2,\"30\":1,\"31\":3,\"32\":1,\"85\":1,\"86\":3,\"87\":1,\"93\":3,\"99\":11,\"102\":1,\"103\":2,\"105\":2,\"108\":1,\"109\":2,\"111\":3,\"112\":1,\"116\":6,\"117\":1,\"135\":1,\"139\":1,\"175\":2,\"181\":3,\"188\":2,\"192\":1,\"195\":1,\"201\":1,\"202\":1,\"203\":2,\"205\":2,\"206\":1,\"217\":3,\"227\":2,\"230\":2,\"240\":1,\"267\":2,\"269\":4,\"286\":2,\"305\":1,\"314\":1,\"317\":1,\"318\":2,\"349\":3,\"350\":2}}],[\"tls\",{\"1\":{\"26\":1,\"50\":1,\"99\":1,\"102\":1,\"165\":1,\"187\":6,\"190\":2,\"192\":1,\"195\":2,\"199\":3,\"200\":2,\"202\":1,\"305\":2,\"317\":1,\"321\":5}}],[\"tuning\",{\"1\":{\"16\":1}}],[\"tutorials\",{\"1\":{\"13\":1}}],[\"tombstones\",{\"1\":{\"159\":1}}],[\"tombstone\",{\"1\":{\"159\":1}}],[\"toggle=\",{\"1\":{\"134\":1}}],[\"toggle\",{\"1\":{\"134\":2}}],[\"top\",{\"1\":{\"134\":1}}],[\"topk和bottomk则用于对样本值进行排序\",{\"1\":{\"226\":1,\"368\":1}}],[\"topk\",{\"1\":{\"95\":1,\"226\":3,\"228\":1,\"368\":3}}],[\"tooltip用于控制当鼠标移动到图形时\",{\"1\":{\"138\":1}}],[\"too\",{\"1\":{\"110\":1,\"116\":1}}],[\"took\",{\"1\":{\"99\":1}}],[\"total查询时间序列时\",{\"1\":{\"260\":1}}],[\"total时间序列中满足标签instance为localhost\",{\"1\":{\"259\":1}}],[\"total的所有时间序列\",{\"1\":{\"259\":1,\"360\":1}}],[\"total表达式会查询出所有满足表达式条件的时间序列\",{\"1\":{\"244\":1}}],[\"total获取当前主机可用的内存空间大小\",{\"1\":{\"244\":1}}],[\"total获取当前实例各类指令执行的次数\",{\"1\":{\"109\":1}}],[\"total作为后缀\",{\"1\":{\"228\":1}}],[\"total反映了当前缓冲池中的内存页的总页数\",{\"1\":{\"111\":1}}],[\"total我们可以实现\",{\"1\":{\"95\":1}}],[\"total结束\",{\"1\":{\"95\":1}}],[\"total\",{\"1\":{\"93\":3,\"95\":7,\"105\":7,\"106\":5,\"109\":11,\"110\":2,\"111\":2,\"167\":2,\"226\":6,\"228\":3,\"244\":1,\"245\":6,\"246\":3,\"259\":7,\"260\":3,\"261\":4,\"262\":1,\"264\":1,\"266\":4,\"268\":6,\"269\":3,\"325\":3,\"352\":2,\"357\":7,\"360\":4,\"361\":3,\"368\":6}}],[\"token配置项直接指定令牌字符串\",{\"1\":{\"102\":1,\"317\":1}}],[\"token的服务也可以通过bearer\",{\"1\":{\"102\":1,\"317\":1}}],[\"token=xxxx\",{\"1\":{\"30\":1}}],[\"token\",{\"1\":{\"26\":1,\"102\":1,\"165\":6,\"186\":1,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"317\":1}}],[\"todo\",{\"1\":{\"23\":1,\"322\":1}}],[\"to\",{\"0\":{\"400\":1},\"1\":{\"13\":1,\"15\":1,\"16\":1,\"23\":3,\"27\":5,\"31\":1,\"33\":1,\"34\":1,\"48\":1,\"50\":3,\"51\":11,\"67\":2,\"72\":4,\"85\":1,\"99\":5,\"100\":3,\"103\":1,\"135\":16,\"144\":2,\"160\":1,\"165\":2,\"167\":1,\"181\":3,\"201\":1,\"205\":1,\"218\":1,\"249\":3,\"273\":8,\"310\":3,\"318\":1,\"321\":1,\"365\":3}}],[\"t\",{\"1\":{\"1\":2,\"5\":2,\"118\":2,\"119\":2,\"199\":1,\"239\":1,\"265\":1,\"350\":11}}],[\"cst\",{\"1\":{\"305\":1}}],[\"csdn\",{\"1\":{\"18\":1}}],[\"cp\",{\"1\":{\"285\":1,\"373\":1}}],[\"cpu占用率前5位的服务有哪些\",{\"1\":{\"295\":1}}],[\"cpu占用时间是一个只增不减的度量指标\",{\"1\":{\"286\":1}}],[\"cpu的数据类型是计数器\",{\"1\":{\"286\":1}}],[\"cpu的注释表明当前指标是cpu0上idle进程占用cpu的总时间\",{\"1\":{\"286\":1}}],[\"cpu和node\",{\"1\":{\"267\":1}}],[\"cpu样本在最近两分钟的平均增长率\",{\"1\":{\"238\":1}}],[\"cpu都是counter类型的监控指标\",{\"1\":{\"228\":1}}],[\"cpu所获取到的样本数据却不同\",{\"1\":{\"227\":1}}],[\"cpu使用率\",{\"1\":{\"180\":1,\"184\":1}}],[\"cpu使用时间\",{\"1\":{\"95\":1}}],[\"cpu0\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"268\":2,\"286\":1,\"309\":1,\"310\":3}}],[\"cpu=\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"268\":2,\"286\":1,\"309\":1,\"310\":3}}],[\"cpus\",{\"1\":{\"116\":1,\"227\":1,\"267\":1,\"286\":1}}],[\"cpu累积占用时间\",{\"1\":{\"105\":2}}],[\"cpu总量\",{\"1\":{\"105\":1}}],[\"cpu\",{\"1\":{\"4\":1,\"69\":4,\"95\":1,\"104\":1,\"105\":12,\"106\":2,\"116\":3,\"126\":2,\"127\":2,\"128\":2,\"129\":1,\"138\":2,\"151\":4,\"167\":1,\"227\":3,\"229\":1,\"236\":1,\"238\":4,\"248\":1,\"262\":3,\"267\":3,\"268\":2,\"282\":5,\"286\":4,\"309\":1,\"310\":3,\"369\":1,\"370\":1,\"378\":4}}],[\"cd\",{\"1\":{\"273\":1,\"285\":1,\"373\":1}}],[\"cc的secret内容\",{\"1\":{\"210\":1}}],[\"cc的内容\",{\"1\":{\"210\":1}}],[\"cc\",{\"1\":{\"210\":7}}],[\"czn2c\",{\"1\":{\"186\":2}}],[\"charts\",{\"1\":{\"397\":1}}],[\"channel添加一个名为incoming\",{\"1\":{\"48\":1}}],[\"channel\",{\"1\":{\"45\":2,\"48\":3,\"49\":2}}],[\"chown\",{\"1\":{\"373\":1}}],[\"chef\",{\"1\":{\"313\":1}}],[\"check\",{\"1\":{\"150\":2,\"290\":2}}],[\"chunk\",{\"1\":{\"230\":16}}],[\"chunks\",{\"1\":{\"159\":2,\"230\":1}}],[\"chronix\",{\"1\":{\"167\":1}}],[\"c++\",{\"1\":{\"114\":1,\"347\":1}}],[\"cnf\",{\"1\":{\"110\":1}}],[\"cncf基金会certified\",{\"1\":{\"0\":1}}],[\"celsius\",{\"1\":{\"229\":1}}],[\"ceph\",{\"1\":{\"114\":1,\"396\":5}}],[\"ce\",{\"1\":{\"105\":1}}],[\"certificate\",{\"1\":{\"199\":1}}],[\"cert\",{\"1\":{\"102\":1,\"317\":1}}],[\"certs\",{\"1\":{\"102\":1,\"181\":1,\"317\":1}}],[\"cycle\",{\"1\":{\"72\":1}}],[\"crittcal\",{\"1\":{\"290\":1}}],[\"critical\",{\"1\":{\"36\":2,\"55\":1,\"150\":1}}],[\"cratedb\",{\"1\":{\"167\":1}}],[\"crt\",{\"1\":{\"102\":1,\"186\":1,\"187\":6,\"190\":2,\"192\":1,\"199\":3,\"200\":2,\"202\":1,\"317\":1}}],[\"createcontext\",{\"1\":{\"350\":2}}],[\"createindex\",{\"1\":{\"305\":2}}],[\"created\",{\"1\":{\"167\":1,\"174\":1,\"175\":2,\"181\":2,\"186\":3,\"201\":2,\"205\":2,\"210\":1,\"213\":1,\"214\":2,\"216\":1,\"217\":1,\"219\":3,\"223\":5}}],[\"create\",{\"1\":{\"37\":1,\"39\":1,\"160\":1,\"174\":1,\"175\":1,\"181\":2,\"186\":1,\"195\":1,\"201\":1,\"205\":1,\"210\":1,\"213\":1,\"214\":2,\"216\":1,\"217\":1,\"219\":1,\"223\":1,\"350\":1,\"372\":1,\"393\":8,\"400\":1}}],[\"clashes\",{\"1\":{\"156\":1}}],[\"classloadingexports\",{\"1\":{\"350\":1}}],[\"classloading\",{\"1\":{\"349\":1}}],[\"class=\",{\"1\":{\"134\":11}}],[\"classes\",{\"1\":{\"93\":7}}],[\"class\",{\"1\":{\"85\":2,\"86\":1,\"89\":2,\"90\":2,\"91\":1,\"93\":2,\"94\":2,\"95\":4,\"96\":2,\"349\":1,\"350\":2,\"351\":1,\"352\":4}}],[\"clone\",{\"1\":{\"223\":1}}],[\"cloudwatch\",{\"1\":{\"298\":1}}],[\"cloudwatch的支持\",{\"1\":{\"122\":1}}],[\"cloud在基于google的\",{\"1\":{\"235\":1}}],[\"cloud\",{\"1\":{\"114\":1}}],[\"close\",{\"1\":{\"32\":1,\"350\":3}}],[\"clusterrolebinding\",{\"1\":{\"186\":3,\"219\":2,\"223\":1}}],[\"clusterrole\",{\"1\":{\"186\":4,\"219\":3,\"223\":1}}],[\"clusterip\",{\"1\":{\"175\":1,\"181\":2,\"192\":1,\"195\":1,\"202\":1,\"203\":2,\"205\":1,\"206\":2}}],[\"cluster\",{\"1\":{\"42\":1,\"149\":6,\"150\":7,\"175\":1,\"181\":6,\"192\":1,\"195\":1,\"196\":1,\"197\":1,\"202\":1,\"203\":5,\"305\":1}}],[\"client还内置了多种类型构造器\",{\"1\":{\"352\":1}}],[\"client中http\",{\"1\":{\"350\":1}}],[\"client相关的依赖\",{\"1\":{\"93\":1}}],[\"client\",{\"0\":{\"348\":1,\"350\":1},\"1\":{\"27\":1,\"32\":3,\"84\":1,\"86\":2,\"87\":2,\"91\":1,\"96\":3,\"218\":1,\"232\":2,\"305\":1,\"349\":3,\"350\":3,\"351\":1,\"352\":1}}],[\"currently\",{\"1\":{\"93\":1}}],[\"current\",{\"1\":{\"67\":1,\"69\":2,\"72\":1,\"151\":2,\"181\":1,\"201\":1,\"205\":1,\"216\":1}}],[\"curl\",{\"1\":{\"30\":1,\"48\":2,\"54\":1,\"86\":1,\"87\":1,\"150\":3,\"188\":1,\"201\":1,\"205\":1,\"255\":1,\"257\":1,\"273\":1,\"285\":1,\"305\":2,\"373\":1}}],[\"customexporter继承自io\",{\"1\":{\"96\":1}}],[\"customexporter\",{\"1\":{\"86\":1,\"96\":4}}],[\"custom\",{\"1\":{\"15\":1,\"45\":1,\"96\":2,\"102\":1,\"129\":1,\"198\":1,\"207\":1,\"221\":1,\"317\":1}}],[\"c\",{\"1\":{\"28\":4,\"33\":2,\"167\":1}}],[\"cgi\",{\"1\":{\"26\":1,\"51\":1}}],[\"couchdb\",{\"1\":{\"298\":1}}],[\"could\",{\"1\":{\"103\":1,\"318\":1}}],[\"count作为后缀\",{\"1\":{\"230\":1}}],[\"count相同\",{\"1\":{\"116\":1}}],[\"count指标表示\",{\"1\":{\"116\":1}}],[\"count以及值的汇总\",{\"1\":{\"95\":1}}],[\"count\",{\"1\":{\"93\":2,\"95\":5,\"116\":2,\"135\":2,\"139\":1,\"167\":1,\"193\":1,\"199\":1,\"226\":6,\"230\":2,\"240\":1,\"349\":2,\"368\":6}}],[\"counter是对client\",{\"1\":{\"352\":1}}],[\"counter是一个简单但有强大的工具\",{\"1\":{\"228\":1}}],[\"counter类型的指标其工作方式和计数器一样\",{\"1\":{\"228\":1}}],[\"counter类型的metrics指标在命名中我们使用\",{\"1\":{\"95\":1}}],[\"counter可视化\",{\"1\":{\"138\":1}}],[\"counter与gauge的使用方法一致\",{\"1\":{\"89\":1}}],[\"counter\",{\"0\":{\"228\":1},\"1\":{\"88\":1,\"93\":1,\"95\":2,\"105\":7,\"109\":1,\"116\":1,\"227\":2,\"267\":1,\"286\":2,\"352\":3}}],[\"countermetricfamily\",{\"1\":{\"85\":1}}],[\"codelab\",{\"1\":{\"217\":5}}],[\"codes\",{\"1\":{\"103\":2,\"135\":1,\"314\":1,\"318\":2}}],[\"codes进行定义\",{\"1\":{\"103\":1,\"318\":1}}],[\"code=\",{\"1\":{\"95\":21,\"246\":2,\"250\":6,\"251\":4,\"259\":2,\"260\":2,\"266\":1,\"294\":2,\"357\":4,\"360\":3,\"361\":2,\"366\":6,\"367\":4}}],[\"code\",{\"1\":{\"85\":1,\"89\":2,\"90\":3,\"95\":3,\"99\":4,\"226\":1,\"250\":8,\"251\":3,\"352\":4,\"366\":8,\"367\":3,\"368\":1}}],[\"collapse\",{\"1\":{\"134\":5}}],[\"collapsed\",{\"1\":{\"134\":1}}],[\"collected\",{\"1\":{\"298\":1}}],[\"collectd\",{\"1\":{\"114\":1}}],[\"collections\",{\"1\":{\"96\":3,\"350\":3}}],[\"collection\",{\"1\":{\"93\":6,\"349\":6,\"350\":1}}],[\"collect\",{\"1\":{\"85\":2,\"96\":1,\"350\":2,\"351\":1}}],[\"collectorregistry\",{\"1\":{\"91\":2}}],[\"collectorregistry负责维护当前系统中所有的collector实例\",{\"1\":{\"86\":1}}],[\"collector\",{\"1\":{\"85\":2,\"93\":1,\"96\":3,\"349\":1,\"350\":3,\"351\":1}}],[\"column\",{\"1\":{\"77\":1}}],[\"colorwheel\",{\"1\":{\"135\":1}}],[\"colorscheme\",{\"1\":{\"135\":1}}],[\"color\",{\"1\":{\"49\":2,\"135\":3}}],[\"concatenated\",{\"1\":{\"310\":2}}],[\"concig\",{\"1\":{\"165\":1}}],[\"consulmetadata\",{\"1\":{\"310\":1}}],[\"consul中服务所在的数据中心\",{\"1\":{\"310\":1}}],[\"consul地址\",{\"1\":{\"310\":1}}],[\"consul作为一个通用的服务发现和注册中心\",{\"1\":{\"306\":1}}],[\"consul也提供了一个web\",{\"1\":{\"305\":1}}],[\"consul还支持用户使用http\",{\"1\":{\"305\":1}}],[\"consul还提供了内置的dns服务\",{\"1\":{\"305\":1}}],[\"consul域名查询node\",{\"1\":{\"305\":1}}],[\"consul域名的方式进行访问\",{\"1\":{\"305\":1}}],[\"consul与prometheus同样使用go语言进行开发\",{\"1\":{\"305\":1}}],[\"consul初体验\",{\"0\":{\"305\":1}}],[\"consul是由hashicorp开发的一个支持多数据中心的分布式服务发现和键值对存储服务的开源软件\",{\"1\":{\"304\":1}}],[\"consul\",{\"1\":{\"277\":1,\"280\":1,\"298\":1,\"305\":20,\"306\":1,\"310\":13,\"311\":2}}],[\"consoles菜单\",{\"1\":{\"133\":1}}],[\"console\",{\"1\":{\"120\":1,\"133\":2,\"134\":1}}],[\"constant\",{\"1\":{\"105\":1,\"129\":1}}],[\"conf\",{\"1\":{\"167\":1}}],[\"confluence\",{\"1\":{\"114\":1}}],[\"confident\",{\"1\":{\"105\":1}}],[\"config设置为hashmod时\",{\"1\":{\"312\":1}}],[\"config对metadata标签的处理方式\",{\"1\":{\"310\":1}}],[\"config配置如下所示\",{\"1\":{\"310\":1}}],[\"config配置\",{\"1\":{\"310\":2}}],[\"config实现了对kubernetes下各类资源的自动发现\",{\"1\":{\"198\":1}}],[\"configmaps\",{\"1\":{\"219\":1}}],[\"configmap\",{\"1\":{\"174\":2,\"175\":1,\"187\":2,\"190\":1}}],[\"config指定相关的证书信息\",{\"1\":{\"102\":1,\"317\":1}}],[\"config查看alerting配置是否生效\",{\"1\":{\"58\":1}}],[\"config中设置\",{\"1\":{\"199\":1}}],[\"config中定义send\",{\"1\":{\"50\":1}}],[\"config中定义相应的接收人邮箱地址\",{\"1\":{\"50\":1}}],[\"config中覆盖即可\",{\"1\":{\"50\":1}}],[\"config中进行定义\",{\"1\":{\"49\":1}}],[\"config的action除了默认的replace以外\",{\"1\":{\"311\":1}}],[\"config的role为endpoints指定当前的服务发现模式\",{\"1\":{\"207\":1}}],[\"config的role为service指定服务发现模式\",{\"1\":{\"203\":1}}],[\"config的模式为node\",{\"1\":{\"187\":1}}],[\"config的主要配置如下\",{\"1\":{\"49\":1}}],[\"config的具体配置格式如下\",{\"1\":{\"27\":1}}],[\"config>\",{\"1\":{\"26\":1,\"27\":2,\"43\":8,\"50\":1,\"165\":3,\"321\":1}}],[\"config\",{\"1\":{\"26\":1,\"27\":2,\"51\":1,\"56\":1,\"99\":1,\"102\":1,\"106\":1,\"108\":1,\"149\":2,\"150\":3,\"151\":2,\"156\":1,\"165\":1,\"167\":1,\"174\":4,\"175\":4,\"187\":9,\"190\":4,\"192\":2,\"195\":1,\"199\":3,\"200\":2,\"202\":1,\"210\":1,\"214\":1,\"273\":2,\"305\":1,\"307\":1,\"317\":1,\"321\":1,\"393\":1}}],[\"configs的方式静态的定义监控目标\",{\"1\":{\"313\":1}}],[\"configs的监控采集任务\",{\"1\":{\"307\":1}}],[\"configs来添加自定义的relabeling过程\",{\"1\":{\"309\":1}}],[\"configs定义当中通过server定义了consul服务的访问地址\",{\"1\":{\"306\":1}}],[\"configs节点下添加以下内容\",{\"1\":{\"287\":1}}],[\"configs配置中第一步用于判断当前endpoints是否为kube\",{\"1\":{\"202\":1}}],[\"configs对采集任务进行动态设置\",{\"1\":{\"100\":1}}],[\"configs用于定义一组接收告警的邮箱地址即可\",{\"1\":{\"50\":1}}],[\"configs即可\",{\"1\":{\"49\":1}}],[\"configs则是在需要对请求进行ssl配置时使用\",{\"1\":{\"27\":1}}],[\"configs\",{\"1\":{\"23\":2,\"27\":1,\"34\":2,\"40\":1,\"43\":8,\"45\":2,\"49\":1,\"50\":2,\"51\":1,\"55\":1,\"58\":1,\"100\":5,\"106\":1,\"108\":1,\"150\":1,\"151\":5,\"156\":3,\"165\":1,\"169\":2,\"174\":2,\"187\":7,\"189\":1,\"190\":5,\"192\":2,\"196\":2,\"197\":2,\"199\":6,\"200\":4,\"201\":2,\"202\":2,\"203\":5,\"207\":5,\"214\":3,\"218\":4,\"273\":3,\"280\":4,\"287\":3,\"306\":1,\"307\":3,\"310\":6,\"311\":3,\"312\":5,\"377\":4}}],[\"configured\",{\"1\":{\"181\":1,\"186\":2,\"187\":1,\"219\":1,\"310\":2}}],[\"configure\",{\"1\":{\"15\":1}}],[\"configuration\",{\"0\":{\"13\":1},\"1\":{\"27\":1,\"150\":1,\"273\":4,\"321\":1}}],[\"connecting\",{\"1\":{\"181\":1}}],[\"connection\",{\"1\":{\"110\":3,\"321\":2}}],[\"connections以及connection\",{\"1\":{\"110\":1}}],[\"connections以及threads\",{\"1\":{\"110\":1}}],[\"connections限制以内\",{\"1\":{\"110\":1}}],[\"connections限制了当前服务器允许的最大客户端连接数量\",{\"1\":{\"110\":1}}],[\"connections的值也会增加\",{\"1\":{\"110\":1}}],[\"connections\",{\"1\":{\"110\":8,\"273\":1}}],[\"connections配置\",{\"1\":{\"110\":1}}],[\"connects的数量不断增加时\",{\"1\":{\"110\":1}}],[\"connects\",{\"1\":{\"110\":3}}],[\"connected\",{\"1\":{\"110\":5,\"167\":1}}],[\"connect\",{\"1\":{\"99\":1,\"103\":1,\"195\":1,\"318\":1}}],[\"containing\",{\"1\":{\"273\":1}}],[\"contain\",{\"1\":{\"199\":1}}],[\"containercreating\",{\"1\":{\"181\":2,\"214\":1}}],[\"containerport\",{\"1\":{\"175\":1,\"181\":1,\"201\":1,\"205\":1,\"217\":1}}],[\"containers\",{\"1\":{\"175\":1,\"181\":1,\"195\":1,\"201\":1,\"203\":1,\"205\":1,\"217\":1}}],[\"container\",{\"1\":{\"104\":1,\"105\":26,\"106\":6,\"108\":1,\"134\":1,\"167\":1,\"179\":1,\"180\":1,\"183\":1,\"187\":1,\"207\":4}}],[\"control\",{\"1\":{\"186\":1}}],[\"controller等等\",{\"1\":{\"179\":1,\"183\":1}}],[\"controller会尝试自动修复\",{\"1\":{\"178\":1}}],[\"controller\",{\"1\":{\"178\":1,\"179\":3,\"183\":3,\"187\":1,\"189\":1,\"207\":1}}],[\"continue\",{\"1\":{\"40\":1,\"51\":1}}],[\"content\",{\"1\":{\"30\":1,\"32\":1,\"99\":4,\"102\":1,\"117\":3,\"294\":2,\"310\":1,\"317\":1,\"350\":4}}],[\"context\",{\"1\":{\"28\":1}}],[\"cortex\",{\"1\":{\"167\":1}}],[\"corporation\",{\"1\":{\"349\":1}}],[\"corp\",{\"1\":{\"26\":1,\"51\":5}}],[\"coreos率先引入了operator的概念\",{\"1\":{\"220\":1}}],[\"coreos\",{\"1\":{\"14\":1,\"16\":1,\"75\":2,\"210\":2,\"213\":2,\"214\":3,\"216\":2,\"217\":3,\"218\":1,\"219\":2,\"223\":1,\"397\":4}}],[\"com>\",{\"1\":{\"105\":1}}],[\"com进行探测\",{\"1\":{\"99\":1}}],[\"com对baidu\",{\"1\":{\"99\":1}}],[\"compressed\",{\"1\":{\"166\":2}}],[\"compacted\",{\"1\":{\"160\":1}}],[\"compaction\",{\"1\":{\"139\":17,\"141\":1,\"230\":17}}],[\"complex\",{\"1\":{\"116\":2}}],[\"completed\",{\"1\":{\"273\":1}}],[\"complete\",{\"1\":{\"99\":1}}],[\"compose定义并启动influxdb数据库服务\",{\"1\":{\"167\":1}}],[\"compose定义并启动mysql以及mysqld\",{\"1\":{\"108\":1}}],[\"compose\",{\"1\":{\"108\":1,\"167\":2}}],[\"compose启动测试用的mysql实例以及mysqld\",{\"1\":{\"108\":1}}],[\"components\",{\"0\":{\"392\":1,\"399\":1},\"1\":{\"181\":1,\"232\":1}}],[\"component=web\",{\"1\":{\"273\":1}}],[\"component=k8s\",{\"1\":{\"218\":1}}],[\"component=dispatcher\",{\"1\":{\"150\":3,\"151\":3}}],[\"component=cluster\",{\"1\":{\"150\":1}}],[\"component\",{\"1\":{\"45\":1,\"96\":2}}],[\"compile\",{\"1\":{\"85\":1,\"86\":1,\"87\":1,\"91\":1,\"93\":3,\"349\":4}}],[\"comes\",{\"1\":{\"48\":1}}],[\"command\",{\"1\":{\"109\":1,\"167\":2,\"175\":1}}],[\"command=~\",{\"1\":{\"109\":1}}],[\"command=\",{\"1\":{\"109\":7}}],[\"commands\",{\"1\":{\"109\":13}}],[\"commandlinerunner\",{\"1\":{\"93\":1,\"94\":1,\"96\":1}}],[\"common\",{\"1\":{\"114\":1,\"166\":1}}],[\"commonannotations`\",{\"1\":{\"28\":1}}],[\"commonannotations\",{\"1\":{\"27\":1,\"28\":1,\"31\":1}}],[\"commonlabels`\",{\"1\":{\"28\":1}}],[\"commonlabels\",{\"1\":{\"27\":1,\"28\":1}}],[\"community\",{\"1\":{\"13\":1}}],[\"com\",{\"1\":{\"13\":1,\"14\":1,\"15\":2,\"16\":5,\"17\":1,\"26\":5,\"28\":2,\"29\":1,\"30\":1,\"31\":1,\"32\":2,\"33\":1,\"34\":1,\"45\":1,\"48\":5,\"49\":1,\"50\":1,\"51\":1,\"54\":1,\"75\":2,\"100\":2,\"102\":1,\"109\":3,\"123\":1,\"144\":1,\"149\":1,\"150\":1,\"166\":4,\"167\":1,\"181\":1,\"210\":2,\"213\":2,\"214\":3,\"216\":2,\"217\":3,\"218\":2,\"219\":2,\"223\":1,\"273\":1,\"283\":1,\"285\":1,\"317\":1,\"349\":1,\"373\":1,\"397\":1,\"400\":1}}],[\"capture\",{\"1\":{\"310\":2}}],[\"cask\",{\"1\":{\"181\":1}}],[\"caller=web\",{\"1\":{\"273\":1}}],[\"caller=dispatch\",{\"1\":{\"150\":3,\"151\":3}}],[\"caller=main\",{\"1\":{\"150\":3,\"218\":1,\"273\":5}}],[\"caller=cluster\",{\"1\":{\"150\":1}}],[\"ca\",{\"1\":{\"102\":2,\"186\":1,\"187\":12,\"190\":4,\"192\":2,\"199\":6,\"200\":4,\"202\":2,\"317\":2}}],[\"cached\",{\"1\":{\"378\":1}}],[\"cache\",{\"1\":{\"87\":1}}],[\"catalog\",{\"1\":{\"305\":2}}],[\"cat\",{\"1\":{\"58\":1,\"69\":1,\"151\":1,\"210\":1}}],[\"cadvisor地址\",{\"1\":{\"200\":2}}],[\"cadvisor地址可以获取到cadvisor的监控指标\",{\"1\":{\"200\":1}}],[\"cadvisor能够获取当前节点上运行的所有容器的资源使用情况\",{\"1\":{\"200\":1}}],[\"cadvisor的relabel配置\",{\"1\":{\"190\":1}}],[\"cadvisor接口获取cadvisor的样本数据\",{\"1\":{\"190\":1}}],[\"cadvisor数据采集状态\",{\"1\":{\"190\":1}}],[\"cadvisor会自动采集当前节点上容器cpu\",{\"1\":{\"188\":1}}],[\"cadvisorversion=\",{\"1\":{\"105\":1}}],[\"cadvisorrevision=\",{\"1\":{\"105\":1}}],[\"cadvisor是一个简单易用的工具\",{\"1\":{\"105\":1}}],[\"cadvisor是google开源的一款用于展示和分析容器运行状态的可视化工具\",{\"1\":{\"105\":1}}],[\"cadvisor可视化\",{\"1\":{\"105\":1}}],[\"cadvisor\",{\"0\":{\"104\":1},\"1\":{\"9\":1,\"21\":1,\"105\":8,\"106\":1,\"190\":4,\"200\":4,\"232\":1,\"241\":2,\"307\":1,\"399\":1}}],[\"cannot\",{\"1\":{\"199\":1,\"218\":1}}],[\"can\",{\"1\":{\"1\":2,\"5\":2,\"118\":2,\"119\":2,\"135\":3}}],[\"曾作为敏捷和devops技术教练向多家大型企业提供咨询和培训\",{\"1\":{\"0\":1}}],[\"郑云龙\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
